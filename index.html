<h1 id="-">بررسی و تحلیل کرنل لینوکس</h1>
<p><strong>تحقیق و نگارش: مهدی رادفر</strong><br><strong>تاریخ: اردیبهشت ۱۴۰۴</strong></p>
<hr>
<h2 id="-">فهرست مطالب</h2>
<ul>
<li><a href="#بررسی-و-تحلیل-کرنل-لینوکس">بررسی و تحلیل کرنل لینوکس</a><ul>
<li><a href="#فهرست-مطالب">فهرست مطالب</a></li>
<li><a href="#مقدمه">مقدمه</a></li>
<li><a href="#مقدمه-1">مقدمه</a><ul>
<li><a href="#اهمیت-کرنل-در-سیستمعامل">اهمیت کرنل در سیستم‌عامل</a></li>
<li><a href="#جایگاه-لینوکس-در-دنیای-سیستمعاملها">جایگاه لینوکس در دنیای سیستم‌عامل‌ها</a></li>
<li><a href="#هدف-و-ساختار-این-تحقیق">هدف و ساختار این تحقیق</a></li>
<li><a href="#جایگاه-لینوکس-در-دنیای-سیستمعاملها-1">جایگاه لینوکس در دنیای سیستم‌عامل‌ها</a></li>
</ul>
</li>
<li><a href="#تاریخچه-پیدایش-لینوکس">تاریخچه پیدایش لینوکس</a><ul>
<li><a href="#زمینههای-شکلگیری-پروژه-لینوکس">زمینه‌های شکل‌گیری پروژه لینوکس</a></li>
<li><a href="#یونیکس-و-تأثیر-آن-بر-لینوکس">یونیکس و تأثیر آن بر لینوکس</a></li>
<li><a href="#پروژه-گنو-و-رابطه-آن-با-لینوکس">پروژه گنو و رابطه آن با لینوکس</a></li>
<li><a href="#لینوس-توروالدز-و-ایده-اولیه-کرنل-لینوکس">لینوس توروالدز و ایده اولیه کرنل لینوکس</a></li>
<li><a href="#اولین-نسخههای-کرنل-لینوکس">اولین نسخه‌های کرنل لینوکس</a></li>
<li><a href="#تکامل-تدریجی-لینوکس">تکامل تدریجی لینوکس</a></li>
</ul>
</li>
<li><a href="#معماری-کرنل-لینوکس">معماری کرنل لینوکس</a><ul>
<li><a href="#کرنل-مونولیتیک-در-مقابل-میکروکرنل">کرنل مونولیتیک در مقابل میکروکرنل</a></li>
<li><a href="#مزایا-و-معایب-معماری-مونولیتیک-لینوکس">مزایا و معایب معماری مونولیتیک لینوکس</a></li>
<li><a href="#ساختار-لایهای-کرنل-لینوکس">ساختار لایه‌ای کرنل لینوکس</a></li>
<li><a href="#ماژولهای-کرنل">ماژول‌های کرنل</a></li>
<li><a href="#فضای-کرنل-و-فضای-کاربر">فضای کرنل و فضای کاربر</a></li>
<li><a href="#سیستم-فراخوانی-سیستمی">سیستم فراخوانی سیستمی</a></li>
<li><a href="#خلاصه-معماری-کرنل-لینوکس">خلاصه معماری کرنل لینوکس</a></li>
</ul>
</li>
<li><a href="#ویژگیهای-اصلی-کرنل-لینوکس">ویژگی‌های اصلی کرنل لینوکس</a><ul>
<li><a href="#چند-وظیفهای-پیشگیرانه">چند وظیفه‌ای پیشگیرانه</a></li>
<li><a href="#پشتیبانی-از-چند-پردازنده">پشتیبانی از چند پردازنده</a></li>
<li><a href="#قابلیت-حمل">قابلیت حمل</a></li>
<li><a href="#استانداردهای-posix">استانداردهای POSIX</a></li>
<li><a href="#پشتیبانی-از-سختافزارهای-متنوع">پشتیبانی از سخت‌افزارهای متنوع</a></li>
<li><a href="#مقیاسپذیری">مقیاس‌پذیری</a></li>
</ul>
</li>
<li><a href="#خلاصه-ویژگیهای-اصلی-کرنل-لینوکس">خلاصه ویژگی‌های اصلی کرنل لینوکس</a></li>
<li><a href="#بررسی-کد-کرنل-لینوکس">بررسی کد کرنل لینوکس</a><ul>
<li><a href="#زبان-برنامهنویسی-c-و-اسمبلی-در-کرنل">زبان برنامه‌نویسی C و اسمبلی در کرنل</a></li>
<li><a href="#ساختار-درختی-کد-منبع">ساختار درختی کد منبع</a></li>
<li><a href="#استانداردهای-کدنویسی">استانداردهای کدنویسی</a></li>
<li><a href="#تحلیل-بخشهای-کلیدی-کد-کرنل">تحلیل بخش‌های کلیدی کد کرنل</a><ul>
<li><a href="#1-فراخوانی-سیستمی-system-call">1. فراخوانی سیستمی (System Call)</a></li>
<li><a href="#2-زمانبندی-فرآیندها">2. زمانبندی فرآیندها</a></li>
<li><a href="#3-مدیریت-حافظه">3. مدیریت حافظه</a></li>
<li><a href="#4-سیستم-فایل-مجازی-vfs">4. سیستم فایل مجازی (VFS)</a></li>
</ul>
</li>
<li><a href="#بررسی-نمونه-کدهای-کرنل">بررسی نمونه کدهای کرنل</a><ul>
<li><a href="#1-مدیریت-وقفهها">1. مدیریت وقفه‌ها</a></li>
</ul>
</li>
<li><a href="#صفحهبندی-و-جدول-صفحات">صفحه‌بندی و جدول صفحات</a></li>
<li><a href="#فضای-آدرس-پروسه">فضای آدرس پروسه</a></li>
<li><a href="#مدیریت-حافظه-نهان">مدیریت حافظه نهان</a></li>
<li><a href="#تخصیص-و-آزادسازی-حافظه">تخصیص و آزادسازی حافظه</a></li>
<li><a href="#صفحه-گردانی">صفحه گردانی</a></li>
<li><a href="#زبالهروبی-و-جمعآوری-حافظه">زباله‌روبی و جمع‌آوری حافظه</a></li>
</ul>
</li>
<li><a href="#زمانبندی-فرآیندها">زمانبندی فرآیندها</a><ul>
<li><a href="#فرآیندها-و-نخها-در-لینوکس">فرآیندها و نخ‌ها در لینوکس</a></li>
<li><a href="#الگوریتمهای-زمانبندی">الگوریتم‌های زمانبندی</a></li>
<li><a href="#کلاسهای-زمانبندی">کلاس‌های زمانبندی</a></li>
<li><a href="#زمانبند-کاملاً-قابل-پیشبینی">زمانبند کاملاً قابل پیش‌بینی</a></li>
<li><a href="#زمانبندی-بلادرنگ">زمانبندی بلادرنگ</a></li>
<li><a href="#سیاستهای-زمانبندی">سیاست‌های زمانبندی</a></li>
<li><a href="#توزیع-بار-بین-پردازندهها">توزیع بار بین پردازنده‌ها</a></li>
</ul>
</li>
<li><a href="#سیستم-فایل-در-لینوکس">سیستم فایل در لینوکس</a><ul>
<li><a href="#معماری-vfs">معماری VFS</a></li>
<li><a href="#انواع-سیستم-فایل-در-لینوکس">انواع سیستم فایل در لینوکس</a></li>
<li><a href="#ext2-ext3-و-ext4">ext2، ext3 و ext4</a></li>
<li><a href="#btrfs-و-zfs">Btrfs و ZFS</a></li>
<li><a href="#سیستمهای-فایل-شبکه">سیستم‌های فایل شبکه</a></li>
<li><a href="#عملکرد-ورودیخروجی">عملکرد ورودی/خروجی</a></li>
<li><a href="#کش-و-بافر-سیستم-فایل">کش و بافر سیستم فایل</a></li>
</ul>
</li>
<li><a href="#مدیریت-دستگاهها">مدیریت دستگاه‌ها</a><ul>
<li><a href="#درایورهای-دستگاه">درایورهای دستگاه</a></li>
<li><a href="#سیستمهای-فایل-دستگاه">سیستم‌های فایل دستگاه</a></li>
<li><a href="#مدل-درایور-لینوکس">مدل درایور لینوکس</a></li>
<li><a href="#hotplug-و-پشتیبانی-از-اتصال-داغ">hotplug و پشتیبانی از اتصال داغ</a></li>
<li><a href="#مدیریت-انرژی">مدیریت انرژی</a></li>
<li><a href="#درایورهای-گرافیکی">درایورهای گرافیکی</a></li>
<li><a href="#تعامل-با-سختافزار">تعامل با سخت‌افزار</a></li>
</ul>
</li>
<li><a href="#امنیت-در-کرنل-لینوکس">امنیت در کرنل لینوکس</a><ul>
<li><a href="#مدل-امنیتی-لینوکس">مدل امنیتی لینوکس</a></li>
<li><a href="#selinux-و-apparmor">SELinux و AppArmor</a></li>
<li><a href="#مجوزها-و-کنترل-دسترسی">مجوزها و کنترل دسترسی</a></li>
<li><a href="#فضایهای-نام-و-کانتینرها">فضای‌های نام و کانتینرها</a></li>
<li><a href="#مشکلات-امنیتی-و-وصلهها">مشکلات امنیتی و وصله‌ها</a></li>
<li><a href="#استراتژیهای-امنیتی">استراتژی‌های امنیتی</a></li>
<li><a href="#کرنل-هاردنینگ">کرنل هاردنینگ</a></li>
</ul>
</li>
<li><a href="#فرآیند-توسعه-کرنل-لینوکس">فرآیند توسعه کرنل لینوکس</a><ul>
<li><a href="#مدل-توسعه-متنباز">مدل توسعه متن‌باز</a></li>
<li><a href="#گردش-کار-توسعه-کرنل">گردش کار توسعه کرنل</a></li>
<li><a href="#سیستم-کنترل-نسخه-git">سیستم کنترل نسخه Git</a></li>
<li><a href="#روند-بررسی-و-ادغام-کد">روند بررسی و ادغام کد</a></li>
<li><a href="#چرخه-انتشار-کرنل">چرخه انتشار کرنل</a></li>
<li><a href="#پشتیبانی-بلندمدت">پشتیبانی بلندمدت</a></li>
<li><a href="#مشارکتکنندگان-اصلی-و-شرکتها">مشارکت‌کنندگان اصلی و شرکت‌ها</a></li>
<li><a href="#توزیعهای-لینوکس">توزیع‌های لینوکس</a></li>
<li><a href="#اندروید-و-سیستمعاملهای-مبتنی-بر-لینوکس">اندروید و سیستم‌عامل‌های مبتنی بر لینوکس</a></li>
<li><a href="#لینوکس-در-سرورها-و-مراکز-داده">لینوکس در سرورها و مراکز داده</a></li>
<li><a href="#اینترنت-اشیا-و-سیستمهای-نهفته">اینترنت اشیا و سیستم‌های نهفته</a></li>
<li><a href="#ابررایانهها">ابررایانه‌ها</a></li>
<li><a href="#تأثیر-بر-صنعت-و-جامعه">تأثیر بر صنعت و جامعه</a></li>
<li><a href="#نوآوریهای-الهام-گرفته-از-لینوکس">نوآوری‌های الهام گرفته از لینوکس</a></li>
</ul>
</li>
<li><a href="#نتیجهگیری">نتیجه‌گیری</a><ul>
<li><a href="#لینوکس-001-و-اولین-نسخهها">لینوکس 0.01 و اولین نسخه‌ها</a></li>
<li><a href="#لینوکس-10-و-تثبیت-پروژه">لینوکس 1.0 و تثبیت پروژه</a></li>
<li><a href="#لینوکس-20-و-پشتیبانی-از-چندپردازنده">لینوکس 2.0 و پشتیبانی از چندپردازنده</a></li>
<li><a href="#لینوکس-26-و-تحولات-بزرگ">لینوکس 2.6 و تحولات بزرگ</a></li>
<li><a href="#تغییر-به-سیستم-شمارهگذاری-جدید">تغییر به سیستم شماره‌گذاری جدید</a></li>
<li><a href="#نسخههای-جدید-و-ویژگیهای-کلیدی">نسخه‌های جدید و ویژگی‌های کلیدی</a></li>
<li><a href="#تکامل-api-و-abi">تکامل API و ABI</a></li>
</ul>
</li>
<li><a href="#تاثیر-کرنل-لینوکس-بر-دنیای-کامپیوتر">تاثیر کرنل لینوکس بر دنیای کامپیوتر</a><ul>
<li><a href="#لینوکس-001-و-اولین-نسخهها-1">لینوکس 0.01 و اولین نسخه‌ها</a></li>
<li><a href="#لینوکس-10-و-تثبیت-پروژه-1">لینوکس 1.0 و تثبیت پروژه</a></li>
<li><a href="#لینوکس-20-و-پشتیبانی-از-چندپردازنده-1">لینوکس 2.0 و پشتیبانی از چندپردازنده</a></li>
<li><a href="#لینوکس-26-و-تحولات-بزرگ-1">لینوکس 2.6 و تحولات بزرگ</a></li>
<li><a href="#تغییر-به-سیستم-شمارهگذاری-جدید-1">تغییر به سیستم شماره‌گذاری جدید</a></li>
<li><a href="#نسخههای-جدید-و-ویژگیهای-کلیدی-1">نسخه‌های جدید و ویژگی‌های کلیدی</a></li>
<li><a href="#تکامل-api-و-abi-1">تکامل API و ABI</a></li>
</ul>
</li>
<li><a href="#تاثیر-کرنل-لینوکس-بر-دنیای-کامپیوتر-1">تاثیر کرنل لینوکس بر دنیای کامپیوتر</a><ul>
<li><a href="#توزیعهای-لینوکس-1">توزیع‌های لینوکس</a></li>
<li><a href="#اندروید-و-سیستمعاملهای-مبتنی-بر-لینوکس-1">اندروید و سیستم‌عامل‌های مبتنی بر لینوکس</a></li>
<li><a href="#لینوکس-در-سرورها-و-مراکز-داده-1">لینوکس در سرورها و مراکز داده</a></li>
<li><a href="#اینترنت-اشیا-و-سیستمهای-نهفته-1">اینترنت اشیا و سیستم‌های نهفته</a></li>
<li><a href="#ابررایانهها-1">ابررایانه‌ها</a></li>
<li><a href="#تأثیر-بر-صنعت-و-جامعه-1">تأثیر بر صنعت و جامعه</a></li>
<li><a href="#نوآوریهای-الهام-گرفته-از-لینوکس-1">نوآوری‌های الهام گرفته از لینوکس</a></li>
</ul>
</li>
<li><a href="#نسخههای-مهم-کرنل-لینوکس">نسخه‌های مهم کرنل لینوکس</a><ul>
<li><a href="#لینوکس-001-و-اولین-نسخهها-2">لینوکس 0.01 و اولین نسخه‌ها</a></li>
<li><a href="#لینوکس-10-و-تثبیت-پروژه-2">لینوکس 1.0 و تثبیت پروژه</a></li>
<li><a href="#لینوکس-20-و-پشتیبانی-از-چندپردازنده-2">لینوکس 2.0 و پشتیبانی از چندپردازنده</a></li>
<li><a href="#لینوکس-26-و-تحولات-بزرگ-2">لینوکس 2.6 و تحولات بزرگ</a></li>
<li><a href="#تغییر-به-سیستم-شمارهگذاری-جدید-2">تغییر به سیستم شماره‌گذاری جدید</a></li>
<li><a href="#نسخههای-جدید-و-ویژگیهای-کلیدی-2">نسخه‌های جدید و ویژگی‌های کلیدی</a></li>
<li><a href="#تکامل-api-و-abi-2">تکامل API و ABI</a></li>
</ul>
</li>
<li><a href="#تاثیر-کرنل-لینوکس-بر-دنیای-کامپیوتر-2">تاثیر کرنل لینوکس بر دنیای کامپیوتر</a><ul>
<li><a href="#توزیعهای-لینوکس-2">توزیع‌های لینوکس</a></li>
<li><a href="#اندروید-و-سیستمعاملهای-مبتنی-بر-لینوکس-2">اندروید و سیستم‌عامل‌های مبتنی بر لینوکس</a></li>
<li><a href="#لینوکس-در-سرورها-و-مراکز-داده-2">لینوکس در سرورها و مراکز داده</a></li>
<li><a href="#اینترنت-اشیا-و-سیستمهای-نهفته-2">اینترنت اشیا و سیستم‌های نهفته</a></li>
<li><a href="#ابررایانهها-2">ابررایانه‌ها</a></li>
<li><a href="#تأثیر-بر-صنعت-و-جامعه-2">تأثیر بر صنعت و جامعه</a></li>
<li><a href="#نوآوریهای-الهام-گرفته-از-لینوکس-2">نوآوری‌های الهام گرفته از لینوکس</a></li>
</ul>
</li>
<li><a href="#چالشهای-پیش-روی-کرنل-لینوکس">چالش‌های پیش روی کرنل لینوکس</a><ul>
<li><a href="#پیچیدگی-روزافزون-کد">پیچیدگی روزافزون کد</a></li>
<li><a href="#حفظ-سازگاری">حفظ سازگاری</a></li>
<li><a href="#امنیت-و-حریم-خصوصی">امنیت و حریم خصوصی</a></li>
<li><a href="#سختافزارهای-اختصاصی">سخت‌افزارهای اختصاصی</a></li>
<li><a href="#مسائل-حقوقی-و-مالکیت-معنوی">مسائل حقوقی و مالکیت معنوی</a></li>
<li><a href="#تنوع-معماریها">تنوع معماری‌ها</a></li>
<li><a href="#رقابت-با-سایر-سیستمعاملها">رقابت با سایر سیستم‌عامل‌ها</a></li>
</ul>
</li>
<li><a href="#آینده-کرنل-لینوکس">آینده کرنل لینوکس</a><ul>
<li><a href="#جهتگیریهای-آینده">جهت‌گیری‌های آینده</a></li>
<li><a href="#فناوریهای-نوظهور">فناوری‌های نوظهور</a></li>
<li><a href="#لینوکس-و-محاسبات-ابری">لینوکس و محاسبات ابری</a></li>
<li><a href="#کرنل-لینوکس-و-هوش-مصنوعی">کرنل لینوکس و هوش مصنوعی</a></li>
<li><a href="#برنامههای-بلندمدت">برنامه‌های بلندمدت</a></li>
<li><a href="#چالشهای-آینده">چالش‌های آینده</a></li>
<li><a href="#نوآوریهای-پیشبینی-شده">نوآوری‌های پیش‌بینی شده</a></li>
</ul>
</li>
<li><a href="#نتیجهگیری-1">نتیجه‌گیری</a></li>
<li><a href="#منابع">منابع</a></li>
</ul>
</li>
<li><a href="#مدیریت-حافظه-در-کرنل-لینوکس">مدیریت حافظه در کرنل لینوکس</a><ul>
<li><a href="#حافظه-فیزیکی-و-حافظه-مجازی">حافظه فیزیکی و حافظه مجازی</a></li>
<li><a href="#صفحه‌بندی-و-جدول-صفحات">صفحه‌بندی و جدول صفحات</a></li>
<li><a href="#فضای-آدرس-پروسه">فضای آدرس پروسه</a></li>
<li><a href="#مدیریت-حافظه-نهان">مدیریت حافظه نهان</a></li>
<li><a href="#تخصیص-و-آزادسازی-حافظه">تخصیص و آزادسازی حافظه</a></li>
<li><a href="#صفحه-گردانی">صفحه گردانی</a></li>
<li><a href="#زباله‌روبی-و-جمع‌آوری-حافظه">زباله‌روبی و جمع‌آوری حافظه</a></li>
</ul>
</li>
<li><a href="#زمانبندی-فرآیندها">زمانبندی فرآیندها</a><ul>
<li><a href="#فرآیندها-و-نخ‌ها-در-لینوکس">فرآیندها و نخ‌ها در لینوکس</a></li>
<li><a href="#الگوریتم‌های-زمانبندی">الگوریتم‌های زمانبندی</a></li>
<li><a href="#کلاس‌های-زمانبندی">کلاس‌های زمانبندی</a></li>
<li><a href="#زمانبند-کاملاً-قابل-پیش‌بینی">زمانبند کاملاً قابل پیش‌بینی</a></li>
<li><a href="#زمانبندی-بلادرنگ">زمانبندی بلادرنگ</a></li>
<li><a href="#سیاست‌های-زمانبندی">سیاست‌های زمانبندی</a></li>
<li><a href="#توزیع-بار-بین-پردازنده‌ها">توزیع بار بین پردازنده‌ها</a></li>
</ul>
</li>
<li><a href="#سیستم-فایل-در-لینوکس">سیستم فایل در لینوکس</a><ul>
<li><a href="#معماری-VFS">معماری VFS</a></li>
<li><a href="#انواع-سیستم-فایل-در-لینوکس">انواع سیستم فایل در لینوکس</a></li>
<li><a href="#ext2-ext3-و-ext4">ext2، ext3 و ext4</a></li>
<li><a href="#Btrfs-و-ZFS">Btrfs و ZFS</a></li>
<li><a href="#سیستم‌های-فایل-شبکه">سیستم‌های فایل شبکه</a></li>
<li><a href="#عملکرد-ورودی-خروجی">عملکرد ورودی/خروجی</a></li>
<li><a href="#کش-و-بافر-سیستم-فایل">کش و بافر سیستم فایل</a></li>
</ul>
</li>
<li><a href="#مدیریت-دستگاه‌ها">مدیریت دستگاه‌ها</a><ul>
<li><a href="#درایورهای-دستگاه">درایورهای دستگاه</a></li>
<li><a href="#سیستم‌های-فایل-دستگاه">سیستم‌های فایل دستگاه</a></li>
<li><a href="#مدل-درایور-لینوکس">مدل درایور لینوکس</a></li>
<li><a href="#hotplug-و-پشتیبانی-از-اتصال-داغ">hotplug و پشتیبانی از اتصال داغ</a></li>
<li><a href="#مدیریت-انرژی">مدیریت انرژی</a></li>
<li><a href="#درایورهای-گرافیکی">درایورهای گرافیکی</a></li>
<li><a href="#تعامل-با-سخت‌افزار">تعامل با سخت‌افزار</a></li>
</ul>
</li>
<li><a href="#امنیت-در-کرنل-لینوکس">امنیت در کرنل لینوکس</a><ul>
<li><a href="#مدل-امنیتی-لینوکس">مدل امنیتی لینوکس</a></li>
<li><a href="#SELinux-و-AppArmor">SELinux و AppArmor</a></li>
<li><a href="#مجوزها-و-کنترل-دسترسی">مجوزها و کنترل دسترسی</a></li>
<li><a href="#فضای‌های-نام-و-کانتینرها">فضای‌های نام و کانتینرها</a></li>
<li><a href="#مشکلات-امنیتی-و-وصله‌ها">مشکلات امنیتی و وصله‌ها</a></li>
<li><a href="#استراتژی‌های-امنیتی">استراتژی‌های امنیتی</a></li>
<li><a href="#کرنل-هاردنینگ">کرنل هاردنینگ</a></li>
</ul>
</li>
<li><a href="#فرآیند-توسعه-کرنل-لینوکس">فرآیند توسعه کرنل لینوکس</a><ul>
<li><a href="#مدل-توسعه-متن‌باز">مدل توسعه متن‌باز</a></li>
<li><a href="#گردش-کار-توسعه-کرنل">گردش کار توسعه کرنل</a></li>
<li><a href="#سیستم-کنترل-نسخه-Git">سیستم کنترل نسخه Git</a></li>
<li><a href="#روند-بررسی-و-ادغام-کد">روند بررسی و ادغام کد</a></li>
<li><a href="#چرخه-انتشار-کرنل">چرخه انتشار کرنل</a></li>
<li><a href="#پشتیبانی-بلندمدت">پشتیبانی بلندمدت</a></li>
<li><a href="#مشارکت‌کنندگان-اصلی-و-شرکت‌ها">مشارکت‌کنندگان اصلی و شرکت‌ها</a></li>
</ul>
</li>
<li><a href="#نسخه‌های-مهم-کرنل-لینوکس">نسخه‌های مهم کرنل لینوکس</a><ul>
<li><a href="#لینوکس-0.01-و-اولین-نسخه‌ها">لینوکس 0.01 و اولین نسخه‌ها</a></li>
<li><a href="#لینوکس-1.0-و-تثبیت-پروژه">لینوکس 1.0 و تثبیت پروژه</a></li>
<li><a href="#لینوکس-2.0-و-پشتیبانی-از-چندپردازنده">لینوکس 2.0 و پشتیبانی از چندپردازنده</a></li>
<li><a href="#لینوکس-2.6-و-تحولات-بزرگ">لینوکس 2.6 و تحولات بزرگ</a></li>
<li><a href="#تغییر-به-سیستم-شماره‌گذاری-جدید">تغییر به سیستم شماره‌گذاری جدید</a></li>
<li><a href="#نسخه‌های-جدید-و-ویژگی‌های-کلیدی">نسخه‌های جدید و ویژگی‌های کلیدی</a></li>
<li><a href="#تکامل-API-و-ABI">تکامل API و ABI</a></li>
</ul>
</li>
<li><a href="#تاثیر-کرنل-لینوکس-بر-دنیای-کامپیوتر">تاثیر کرنل لینوکس بر دنیای کامپیوتر</a><ul>
<li><a href="#توزیع‌های-لینوکس">توزیع‌های لینوکس</a></li>
<li><a href="#اندروید-و-سیستم‌عامل‌های-مبتنی-بر-لینوکس">اندروید و سیستم‌عامل‌های مبتنی بر لینوکس</a></li>
<li><a href="#لینوکس-در-سرورها-و-مراکز-داده">لینوکس در سرورها و مراکز داده</a></li>
<li><a href="#اینترنت-اشیا-و-سیستم‌های-نهفته">اینترنت اشیا و سیستم‌های نهفته</a></li>
<li><a href="#ابررایانه‌ها">ابررایانه‌ها</a></li>
<li><a href="#تأثیر-بر-صنعت-و-جامعه">تأثیر بر صنعت و جامعه</a></li>
<li><a href="#نوآوری‌های-الهام-گرفته-از-لینوکس">نوآوری‌های الهام گرفته از لینوکس</a></li>
</ul>
</li>
<li><a href="#چالش‌های-پیش-روی-کرنل-لینوکس">چالش‌های پیش روی کرنل لینوکس</a><ul>
<li><a href="#پیچیدگی-روزافزون-کد">پیچیدگی روزافزون کد</a></li>
<li><a href="#حفظ-سازگاری">حفظ سازگاری</a></li>
<li><a href="#امنیت-و-حریم-خصوصی">امنیت و حریم خصوصی</a></li>
<li><a href="#سخت‌افزارهای-اختصاصی">سخت‌افزارهای اختصاصی</a></li>
<li><a href="#مسائل-حقوقی-و-مالکیت-معنوی">مسائل حقوقی و مالکیت معنوی</a></li>
<li><a href="#تنوع-معماری‌ها">تنوع معماری‌ها</a></li>
<li><a href="#رقابت-با-سایر-سیستم‌عامل‌ها">رقابت با سایر سیستم‌عامل‌ها</a></li>
</ul>
</li>
<li><a href="#آینده-کرنل-لینوکس">آینده کرنل لینوکس</a><ul>
<li><a href="#جهت‌گیری‌های-آینده">جهت‌گیری‌های آینده</a></li>
<li><a href="#فناوری‌های-نوظهور">فناوری‌های نوظهور</a></li>
<li><a href="#لینوکس-و-محاسبات-ابری">لینوکس و محاسبات ابری</a></li>
<li><a href="#کرنل-لینوکس-و-هوش-مصنوعی">کرنل لینوکس و هوش مصنوعی</a></li>
<li><a href="#برنامه‌های-بلندمدت">برنامه‌های بلندمدت</a></li>
<li><a href="#چالش‌های-آینده">چالش‌های آینده</a></li>
<li><a href="#نوآوری‌های-پیش‌بینی-شده">نوآوری‌های پیش‌بینی شده</a></li>
</ul>
</li>
<li><a href="#نتیجه‌گیری">نتیجه‌گیری</a></li>
<li><a href="#منابع">منابع</a></li>
</ul>
<hr>
<h2 id="-">مقدمه</h2>
<h2 id="-">مقدمه</h2>
<h3 id="-">اهمیت کرنل در سیستم‌عامل</h3>
<p>کرنل یا هسته سیستم‌عامل، قلب تپنده هر سیستم کامپیوتری است که وظیفه مدیریت منابع سخت‌افزاری و ایجاد یک لایه انتزاعی برای برنامه‌های کاربردی را بر عهده دارد. کرنل به عنوان واسط بین سخت‌افزار و نرم‌افزار، نقشی حیاتی در عملکرد کل سیستم ایفا می‌کند. بدون کرنل کارآمد، حتی قدرتمندترین سخت‌افزارها نیز نمی‌توانند به درستی مورد استفاده قرار گیرند.</p>
<p>کرنل مسئولیت‌های متعددی دارد که از جمله مهم‌ترین آنها می‌توان به موارد زیر اشاره کرد:</p>
<ul>
<li><strong>مدیریت حافظه</strong>: تخصیص و آزادسازی حافظه، پیاده‌سازی حافظه مجازی، و محافظت از فضای آدرس پروسه‌ها</li>
<li><strong>زمانبندی پردازنده</strong>: تعیین اینکه کدام فرآیند در چه زمانی باید اجرا شود</li>
<li><strong>مدیریت فایل‌ها</strong>: ارائه واسط برای ذخیره‌سازی و بازیابی اطلاعات</li>
<li><strong>مدیریت دستگاه‌ها</strong>: ارتباط با سخت‌افزارهای متصل به سیستم از طریق درایورها</li>
<li><strong>ارتباطات بین فرآیندی</strong>: فراهم کردن مکانیزم‌هایی برای تبادل داده بین پروسه‌ها</li>
<li><strong>امنیت و کنترل دسترسی</strong>: اطمینان از دسترسی صحیح به منابع سیستم</li>
</ul>
<p>تصمیمات طراحی در سطح کرنل تأثیر مستقیمی بر کارایی، امنیت، قابلیت اطمینان و انعطاف‌پذیری کل سیستم‌عامل دارد. به همین دلیل، مطالعه و بررسی کرنل یک سیستم‌عامل می‌تواند بینش عمیقی از عملکرد داخلی آن سیستم و فلسفه طراحی آن ارائه دهد.</p>
<h3 id="-">جایگاه لینوکس در دنیای سیستم‌عامل‌ها</h3>
<p>لینوکس امروزه به یکی از مهم‌ترین و پرکاربردترین سیستم‌عامل‌های جهان تبدیل شده است. این سیستم‌عامل متن‌باز که با الهام از یونیکس توسعه یافته، در طیف گسترده‌ای از دستگاه‌ها از ابررایانه‌ها گرفته تا گوشی‌های هوشمند (از طریق اندروید) و دستگاه‌های اینترنت اشیا (IoT) مورد استفاده قرار می‌گیرد.</p>
<p>برخی از دلایل اهمیت و موفقیت لینوکس عبارتند از:</p>
<ul>
<li><strong>متن‌باز بودن</strong>: کد منبع لینوکس آزادانه در دسترس عموم قرار دارد که امکان بررسی، اصلاح و بهبود آن را توسط هزاران توسعه‌دهنده در سراسر جهان فراهم می‌کند.</li>
<li><strong>پایداری و امنیت</strong>: لینوکس به دلیل معماری داخلی خود و مدل توسعه آن، از پایداری و امنیت بالایی برخوردار است.</li>
<li><strong>انعطاف‌پذیری</strong>: قابلیت سفارشی‌سازی بالای لینوکس امکان استفاده از آن را در شرایط و محیط‌های مختلف فراهم می‌کند.</li>
<li><strong>کارایی</strong>: بهینه‌سازی مداوم کد کرنل لینوکس باعث شده است که این سیستم‌عامل از کارایی بالایی در استفاده از منابع سخت‌افزاری برخوردار باشد.</li>
<li><strong>پشتیبانی از سخت‌افزارهای متنوع</strong>: لینوکس تقریباً از تمامی معماری‌های پردازنده و انواع مختلف سخت‌افزار پشتیبانی می‌کند.</li>
</ul>
<p>امروزه، لینوکس سیستم‌عامل غالب در زمینه‌های متعددی مانند سرورها، ابررایانه‌ها، محاسبات ابری و دستگاه‌های هوشمند است. بیش از ۹۰ درصد سرورهای وب و تقریباً تمامی ابررایانه‌های جهان از لینوکس استفاده می‌کنند. همچنین، اندروید به عنوان یک سیستم‌عامل مبتنی بر کرنل لینوکس، پرطرفدارترین سیستم‌عامل موبایل در جهان محسوب می‌شود.</p>
<h3 id="-">هدف و ساختار این تحقیق</h3>
<p>هدف اصلی این تحقیق، ارائه یک بررسی جامع و عمیق از کرنل لینوکس است. در این نوشتار، به جنبه‌های مختلف کرنل لینوکس از تاریخچه پیدایش گرفته تا معماری داخلی، ویژگی‌های کلیدی، فرآیند توسعه و آینده آن پرداخته می‌شود.</p>
<p>این تحقیق به گونه‌ای ساختاربندی شده است که هم برای افراد تازه‌کار در زمینه لینوکس قابل فهم باشد و هم برای متخصصان و توسعه‌دهندگان با تجربه، اطلاعات ارزشمندی در بر داشته باشد. در طول این مقاله، نمونه‌هایی از کد منبع کرنل لینوکس ارائه و تحلیل خواهد شد تا درک بهتری از عملکرد داخلی آن فراهم شود.</p>
<p>ساختار این تحقیق به شرح زیر است:</p>
<ul>
<li>ابتدا با <strong>تاریخچه پیدایش لینوکس</strong> آغاز می‌کنیم تا زمینه‌های شکل‌گیری و تکامل این پروژه مهم را بررسی کنیم.</li>
<li>سپس به بررسی <strong>معماری کرنل لینوکس</strong> می‌پردازیم و مفاهیمی مانند کرنل مونولیتیک، ماژول‌ها و فضای کرنل و کاربر را توضیح می‌دهیم.</li>
<li>در ادامه، <strong>ویژگی‌های اصلی کرنل لینوکس</strong> را مورد بحث قرار می‌دهیم.</li>
<li>بخش مهمی از این تحقیق به <strong>بررسی کد کرنل لینوکس</strong> اختصاص دارد، جایی که به زبان برنامه‌نویسی، ساختار کد و استانداردهای کدنویسی می‌پردازیم.</li>
<li>سپس، سیستم‌های کلیدی کرنل لینوکس مانند <strong>مدیریت حافظه</strong>، <strong>زمانبندی فرآیندها</strong>، <strong>سیستم فایل</strong> و <strong>مدیریت دستگاه‌ها</strong> را با جزئیات بررسی می‌کنیم.</li>
<li>موضوع مهم <strong>امنیت در کرنل لینوکس</strong> نیز مورد بحث قرار می‌گیرد.</li>
<li><strong>فرآیند توسعه کرنل لینوکس</strong> و مدل متن‌باز آن به همراه <strong>نسخه‌های مهم کرنل</strong> بررسی می‌شود.</li>
<li>در نهایت، <strong>تأثیر کرنل لینوکس بر دنیای کامپیوتر</strong>، <strong>چالش‌های پیش رو</strong> و <strong>آینده کرنل لینوکس</strong> مورد بحث قرار می‌گیرد.</li>
</ul>
<p>این تحقیق با هدف ارائه یک منبع جامع و به‌روز در زمینه کرنل لینوکس تهیه شده است و امید است که بتواند دیدگاه عمیق‌تری نسبت به این سیستم‌عامل قدرتمند ارائه دهد.</p>
<h3 id="-">جایگاه لینوکس در دنیای سیستم‌عامل‌ها</h3>
<p>لینوکس امروزه به یکی از مهم‌ترین و پرکاربردترین سیستم‌عامل‌های جهان تبدیل شده است. این سیستم‌عامل متن‌باز که با الهام از یونیکس توسعه یافته، در طیف گسترده‌ای از دستگاه‌ها از ابررایانه‌ها گرفته تا گوشی‌های هوشمند (از طریق اندروید) و دستگاه‌های اینترنت اشیا (IoT) مورد استفاده قرار می‌گیرد.</p>
<p>برخی از دلایل اهمیت و موفقیت لینوکس عبارتند از:</p>
<ul>
<li><strong>متن‌باز بودن</strong>: کد منبع لینوکس آزادانه در دسترس عموم قرار دارد که امکان بررسی، اصلاح و بهبود آن را توسط هزاران توسعه‌دهنده در سراسر جهان فراهم می‌کند.</li>
<li><strong>پایداری و امنیت</strong>: لینوکس به دلیل معماری داخلی خود و مدل توسعه آن، از پایداری و امنیت بالایی برخوردار است.</li>
<li><strong>انعطاف‌پذیری</strong>: قابلیت سفارشی‌سازی بالای لینوکس امکان استفاده از آن را در شرایط و محیط‌های مختلف فراهم می‌کند.</li>
<li><strong>کارایی</strong>: بهینه‌سازی مداوم کد کرنل لینوکس باعث شده است که این سیستم‌عامل از کارایی بالایی در استفاده از منابع سخت‌افزاری برخوردار باشد.</li>
<li><strong>پشتیبانی از سخت‌افزارهای متنوع</strong>: لینوکس تقریباً از تمامی معماری‌های پردازنده و انواع مختلف سخت‌افزار پشتیبانی می‌کند.</li>
</ul>
<p>امروزه، لینوکس سیستم‌عامل غالب در زمینه‌های متعددی مانند سرورها، ابررایانه‌ها، محاسبات ابری و دستگاه‌های هوشمند است. بیش از ۹۰ درصد سرورهای وب و تقریباً تمامی ابررایانه‌های جهان از لینوکس استفاده می‌کنند. همچنین، اندروید به عنوان یک سیستم‌عامل مبتنی بر کرنل لینوکس، پرطرفدارترین سیستم‌عامل موبایل در جهان محسوب می‌شود.</p>
<p> برنامه‌نویسی، ساختار کد و استانداردهای کدنویسی می‌پردازیم.</p>
<ul>
<li>سپس، سیستم‌های کلیدی کرنل لینوکس مانند <strong>مدیریت حافظه</strong>، <strong>زمانبندی فرآیندها</strong>، <strong>سیستم فایل</strong> و <strong>مدیریت دستگاه‌ها</strong> را با جزئیات بررسی می‌کنیم.</li>
<li>موضوع مهم <strong>امنیت در کرنل لینوکس</strong> نیز مورد بحث قرار می‌گیرد.</li>
<li><strong>فرآیند توسعه کرنل لینوکس</strong> و مدل متن‌باز آن به همراه <strong>نسخه‌های مهم کرنل</strong> بررسی می‌شود.</li>
<li>در نهایت، <strong>تأثیر کرنل لینوکس بر دنیای کامپیوتر</strong>، <strong>چالش‌های پیش رو</strong> و <strong>آینده کرنل لینوکس</strong> مورد بحث قرار می‌گیرد.</li>
</ul>
<p>این تحقیق با هدف ارائه یک منبع جامع و به‌روز در زمینه کرنل لینوکس تهیه شده است و امید است که بتواند دیدگاه عمیق‌تری نسبت به این سیستم‌عامل قدرتمند ارائه دهد.</p>
<h2 id="-">تاریخچه پیدایش لینوکس</h2>
<h3 id="-">زمینه‌های شکل‌گیری پروژه لینوکس</h3>
<p>در اواخر دهه ۱۹۸۰ و اوایل دهه ۱۹۹۰، دنیای سیستم‌عامل‌ها با چالش‌هایی مواجه بود. سیستم‌عامل‌های تجاری مانند یونیکس گران‌قیمت و محدود به سخت‌افزارهای خاص بودند، و سیستم‌عامل‌هایی مانند MS-DOS و ویندوز هنوز از قابلیت‌های پیشرفته‌ای مانند چندوظیفه‌ای کامل، حافظه مجازی و امنیت کافی برخوردار نبودند.</p>
<p>در این دوران، نیاز به یک سیستم‌عامل قدرتمند، ارزان و قابل دسترس که قابلیت‌های یونیکس را داشته باشد، به‌شدت احساس می‌شد. به‌ویژه در محیط‌های آکادمیک و تحقیقاتی، دسترسی به سیستم‌عاملی با کد منبع باز می‌توانست زمینه‌ای برای یادگیری، پژوهش و توسعه‌های بیشتر فراهم کند.</p>
<p>این زمینه باعث شد چندین پروژه با هدف ایجاد سیستم‌عامل‌های آزاد و متن‌باز شکل بگیرند. از جمله مهم‌ترین آنها، پروژه گنو (GNU) بود که توسط ریچارد استالمن در سال ۱۹۸۳ آغاز شده بود، با هدف ایجاد یک سیستم‌عامل کاملاً آزاد و متن‌باز مشابه یونیکس.</p>
<h3 id="-">یونیکس و تأثیر آن بر لینوکس</h3>
<p>یونیکس (UNIX) به عنوان یک سیستم‌عامل چندکاربره و چندوظیفه‌ای در اوایل دهه ۱۹۷۰ در آزمایشگاه‌های بل توسط کن تامپسون، دنیس ریچی و دیگران توسعه یافت. این سیستم‌عامل با فلسفه طراحی خاص خود که بر پایه سادگی، ماژولار بودن و استفاده از ابزارهای کوچک اما قدرتمند بود، تأثیر عمیقی بر دنیای کامپیوتر گذاشت.</p>
<p>برخی از اصول طراحی یونیکس که بعدها در لینوکس نیز دنبال شد، عبارتند از:</p>
<ol>
<li><strong>هر برنامه فقط یک کار را انجام دهد، اما آن کار را به خوبی انجام دهد</strong></li>
<li><strong>همه چیز یک فایل است</strong> (حتی دستگاه‌های سخت‌افزاری)</li>
<li><strong>ایجاد برنامه‌های کوچک که با یکدیگر همکاری می‌کنند</strong></li>
<li><strong>استفاده از متن ساده برای ذخیره داده‌ها</strong></li>
<li><strong>طراحی نرم‌افزار به گونه‌ای که با دیگر برنامه‌ها سازگار باشد</strong></li>
</ol>
<p>با گسترش استفاده از یونیکس در محیط‌های دانشگاهی و تجاری، این سیستم‌عامل به یک استاندارد در صنعت کامپیوتر تبدیل شد. با این حال، قیمت بالا و محدودیت‌های مجوز، دسترسی به این سیستم‌عامل قدرتمند را برای بسیاری از کاربران محدود می‌کرد. همین امر زمینه‌ساز تلاش‌هایی برای ایجاد نسخه‌های آزاد و سازگار با یونیکس شد.</p>
<p>لینوکس با الهام از ایده‌ها و معماری یونیکس طراحی شد، اما برخلاف یونیکس، به صورت آزاد و متن‌باز توسعه یافت. این رویکرد باعث شد که لینوکس به سرعت توسط جامعه‌ای از توسعه‌دهندگان در سراسر جهان پذیرفته و گسترش یابد.</p>
<h3 id="-">پروژه گنو و رابطه آن با لینوکس</h3>
<p>پروژه گنو (GNU&#39;s Not Unix) در سال ۱۹۸۳ توسط ریچارد استالمن با هدف ایجاد یک سیستم‌عامل کاملاً آزاد و متن‌باز آغاز شد. استالمن که از روند رو به رشد نرم‌افزارهای انحصاری ناراضی بود، بنیاد نرم‌افزار آزاد (FSF) را تأسیس کرد و توسعه ابزارها و نرم‌افزارهای سیستمی آزاد را آغاز نمود.</p>
<p>تا اوایل دهه ۱۹۹۰، پروژه گنو موفق به توسعه بسیاری از ابزارهای ضروری سیستم‌عامل شده بود، از جمله:</p>
<ul>
<li>کامپایلر GCC (GNU Compiler Collection)</li>
<li>پوسته Bash (Bourne Again SHell)</li>
<li>ادیتور متنی Emacs</li>
<li>کتابخانه‌های سیستمی</li>
<li>ابزارهای کاربردی مختلف</li>
</ul>
<p>با این حال، یک جزء اساسی همچنان ناقص بود: کرنل سیستم‌عامل. پروژه گنو در حال توسعه کرنل خود به نام GNU Hurd بود، اما این پروژه با پیچیدگی‌های زیادی مواجه شده و پیشرفت آن کند بود.</p>
<p>در همین زمان بود که لینوس توروالدز کرنل لینوکس را منتشر کرد. این کرنل به سرعت با نرم‌افزارهای پروژه گنو ترکیب شد و یک سیستم‌عامل کامل و کاربردی به وجود آورد که امروزه به آن GNU/Linux می‌گوییم.</p>
<p>رابطه بین گنو و لینوکس یک رابطه همزیستی بوده است: کرنل لینوکس یک پلتفرم برای اجرای نرم‌افزارهای گنو فراهم کرد، و ابزارهای گنو، لینوکس را از یک کرنل ساده به یک سیستم‌عامل کامل تبدیل کردند. این ترکیب باعث شد که آرمان ریچارد استالمن در مورد یک سیستم‌عامل کاملاً آزاد، سریع‌تر از آنچه انتظار می‌رفت، محقق شود.</p>
<h3 id="-">لینوس توروالدز و ایده اولیه کرنل لینوکس</h3>
<p>لینوس توروالدز، دانشجوی 21 ساله فنلاندی در دانشگاه هلسینکی، در سال 1991 پروژه‌ای را آغاز کرد که بعدها به کرنل لینوکس تبدیل شد. او در آن زمان به سیستم‌عامل Minix علاقه‌مند بود، سیستم‌عاملی آموزشی که توسط اندرو تاننباوم برای اهداف آموزشی توسعه یافته بود.</p>
<p>توروالدز از محدودیت‌های Minix ناراضی بود و می‌خواست سیستم‌عاملی ایجاد کند که بتواند از تمام قابلیت‌های پردازنده Intel 80386 استفاده کند. او در ابتدا قصد داشت فقط یک شبیه‌ساز ترمینال بنویسد که بتواند از طریق آن به سرورهای یونیکس دانشگاه متصل شود، اما به تدریج پروژه او گسترش یافت.</p>
<p>در 25 آگوست 1991، توروالدز پیام معروف خود را در گروه خبری comp.os.minix منتشر کرد:</p>
<blockquote>
<p>&quot;سلام به همه کسانی که از Minix استفاده می‌کنند. من در حال ساخت یک سیستم‌عامل (رایگان) (فقط یک سرگرمی، چیزی حرفه‌ای مثل GNU نخواهد بود) برای کلون‌های AT 386(486) هستم...&quot;</p>
</blockquote>
<p>در این پیام، او از پروژه خود به عنوان یک سرگرمی یاد کرد و ادعا نمود که چیزی در حد و اندازه گنو نخواهد بود. این تخمین متواضعانه، یکی از بزرگترین اشتباهات پیش‌بینی در تاریخ کامپیوتر بود!</p>
<p>انگیزه اصلی توروالدز از نوشتن لینوکس، یادگیری بیشتر درباره معماری پردازنده‌های x86 و همچنین ایجاد یک سیستم‌عامل مطابق با نیازهای خودش بود. او نمی‌خواست به محدودیت‌های سیستم‌های موجود محدود شود و آزادی بیشتری برای تجربه و یادگیری می‌خواست.</p>
<h3 id="-">اولین نسخه‌های کرنل لینوکس</h3>
<p>اولین نسخه عمومی لینوکس، نسخه 0.01، در سپتامبر 1991 منتشر شد. این نسخه بسیار ابتدایی بود و تنها شامل حداقل امکانات مورد نیاز بود. کد منبع آن حدود 10,000 خط بود و حتی قادر به اجرای خودش نبود (یعنی نمی‌توانست روی خودش کامپایل شود).</p>
<p>برخی از ویژگی‌های این نسخه اولیه عبارت بودند از:</p>
<ul>
<li>پشتیبانی ابتدایی از سیستم فایل</li>
<li>درایورهای محدود برای سخت‌افزار</li>
<li>قابلیت اجرای برنامه‌های ساده در خط فرمان</li>
<li>مدیریت حافظه و فرآیندها به صورت بسیار ابتدایی</li>
</ul>
<p>نسخه 0.01 فقط روی سخت‌افزار خاصی کار می‌کرد و نیاز به Minix برای اجرا داشت (به عنوان میزبان برای کامپایل و راه‌اندازی).</p>
<p>با انتشار کد منبع، تعداد زیادی از برنامه‌نویسان در سراسر جهان به پروژه علاقه‌مند شدند و شروع به مشارکت در توسعه آن کردند. این مشارکت باعث شد که لینوکس به سرعت پیشرفت کند.</p>
<p>نسخه 0.02 در اکتبر 1991 منتشر شد و شامل بهبودهایی در سیستم فایل و پشتیبانی از سخت‌افزارهای بیشتر بود. در این مرحله، توروالدز تصمیم گرفت کرنل را تحت مجوز GPL (General Public License) منتشر کند، مجوزی که توسط بنیاد نرم‌افزار آزاد برای پروژه گنو ایجاد شده بود.</p>
<p>در دسامبر 1991، نسخه 0.11 منتشر شد که اولین نسخه‌ای بود که می‌توانست مستقل از Minix اجرا شود. این نقطه عطفی برای پروژه بود، زیرا لینوکس دیگر به سیستم‌عامل دیگری وابسته نبود.</p>
<p>نسخه 0.12 در ژانویه 1992 منتشر شد و شامل پشتیبانی از درایورهای بیشتر، بهبود عملکرد و پایداری بیشتر بود. در این زمان، تعداد کاربران لینوکس به چند صد نفر رسیده بود.</p>
<p>فرآیند توسعه با سرعت ادامه یافت و در مارس 1992، نسخه 0.95 منتشر شد که قابلیت‌هایی مانند پشتیبانی از سیستم فایل ext، مدیریت حافظه مجازی و پشتیبانی از پروتکل‌های شبکه TCP/IP را به همراه داشت.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * A sample of early Linux kernel code (version 0.01) - main.c
 * This code shows the kernel's entry point and initialization
 */</span>

<span class="hljs-comment">/*
 * (C) 1991 Linus Torvalds
 */</span>

<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(void) {
    <span class="hljs-comment">/* 
     * Initialize the console, memory system, and scheduling
     * These function calls represent the core initialization 
     * sequence of the early Linux kernel
     */</span>
    <span class="hljs-selector-tag">tty_init</span>();            <span class="hljs-comment">/* Console initialization */</span>
    <span class="hljs-selector-tag">mem_init</span>();            <span class="hljs-comment">/* Memory management setup */</span>
    <span class="hljs-selector-tag">sched_init</span>();          <span class="hljs-comment">/* Process scheduler initialization */</span>

    <span class="hljs-comment">/* Start the first process (init) */</span>
    <span class="hljs-selector-tag">move_to_user_mode</span>();
    <span class="hljs-selector-tag">if</span> (!fork()) {         <span class="hljs-comment">/* Fork failed */</span>
        <span class="hljs-selector-tag">init</span>();
    }

    <span class="hljs-comment">/* This point is never reached */</span>
    <span class="hljs-selector-tag">for</span>(;;);
}
</code></pre>
<p>این کد نمونه‌ای ساده‌شده از ورودی اصلی کرنل در نسخه‌های اولیه است که نشان می‌دهد چگونه کرنل راه‌اندازی می‌شود و سیستم‌های اصلی مانند کنسول، مدیریت حافظه و زمانبندی فرآیندها را آغاز می‌کند.</p>
<h3 id="-">تکامل تدریجی لینوکس</h3>
<p>پس از انتشار نسخه‌های اولیه، لینوکس به سرعت تکامل یافت. با افزایش تعداد توسعه‌دهندگان و کاربران، قابلیت‌ها و پایداری سیستم نیز بهبود یافت. برخی از مراحل کلیدی در تکامل لینوکس عبارتند از:</p>
<p><strong>نسخه 1.0 (مارس 1994):</strong></p>
<ul>
<li>اولین نسخه رسمی و پایدار</li>
<li>پشتیبانی از سیستم فایل‌های متعدد</li>
<li>بهبود عملکرد شبکه</li>
<li>پشتیبانی بهتر از سخت‌افزارهای مختلف</li>
<li>پایداری قابل توجه برای استفاده در محیط‌های تولیدی</li>
</ul>
<p><strong>نسخه 2.0 (ژوئن 1996):</strong></p>
<ul>
<li>پشتیبانی از چندپردازنده (SMP - Symmetric Multi-Processing)</li>
<li>بهبود مدیریت حافظه</li>
<li>افزایش پشتیبانی از سخت‌افزارها</li>
<li>پشتیبانی بهتر از پروتکل‌های شبکه</li>
</ul>
<p><strong>نسخه 2.2 (ژانویه 1999):</strong></p>
<ul>
<li>بهبود عملکرد SMP</li>
<li>پشتیبانی از معماری‌های پردازنده بیشتر</li>
<li>افزایش پشتیبانی از پروتکل‌های شبکه</li>
<li>سیستم صف ورودی/خروجی جدید</li>
</ul>
<p><strong>نسخه 2.4 (ژانویه 2001):</strong></p>
<ul>
<li>پشتیبانی از USB و FireWire</li>
<li>پشتیبانی بهتر از دستگاه‌های موبایل</li>
<li>پشتیبانی از ISA Plug and Play</li>
<li>بهبود عملکرد برای سرورها</li>
</ul>
<p><strong>نسخه 2.6 (دسامبر 2003):</strong></p>
<ul>
<li>طراحی مجدد زمانبندی O(1)</li>
<li>بهبود قابل توجه در مقیاس‌پذیری</li>
<li>پشتیبانی از NUMA (Non-Uniform Memory Access)</li>
<li>درایورهای دستگاه قابل بارگذاری در حین اجرا (hotplug)</li>
<li>کاهش زمان پاسخ دسکتاپ</li>
</ul>
<p>در طول این سال‌ها، مدل توسعه لینوکس نیز تکامل یافت. در ابتدا، توروالدز شخصاً تمام کدها را بررسی و ادغام می‌کرد، اما با افزایش پیچیدگی و اندازه پروژه، یک مدل سلسله مراتبی توسعه به وجود آمد. در این مدل، توسعه‌دهندگان ارشد مسئولیت بخش‌های خاصی از کرنل را بر عهده گرفتند.</p>
<p>سیستم کنترل نسخه نیز تغییر کرد. در ابتدا، فایل‌های تغییرات (patch) از طریق ایمیل مبادله می‌شدند. سپس از سیستم‌هایی مانند CVS و BitKeeper استفاده شد. در نهایت، در سال 2005، توروالدز سیستم کنترل نسخه Git را ایجاد کرد که امروزه نه تنها برای توسعه لینوکس، بلکه برای بسیاری از پروژه‌های نرم‌افزاری دیگر در سراسر جهان استفاده می‌شود.</p>
<p>با گذشت زمان، لینوکس از یک پروژه شخصی کوچک به یک سیستم‌عامل قدرتمند و همه‌جانبه تبدیل شد که در طیف گسترده‌ای از دستگاه‌ها، از ابررایانه‌ها گرفته تا گوشی‌های هوشمند، اجرا می‌شود. امروزه، هزاران توسعه‌دهنده از شرکت‌های مختلف در سراسر جهان در توسعه کرنل لینوکس مشارکت می‌کنند، و این روند تکاملی همچنان ادامه دارد.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Evolution of the Linux networking stack 
 * Comparison between early versions and modern implementation
 */</span>

<span class="hljs-comment">/* Early version (circa 1992) - simplified */</span>
<span class="hljs-keyword">int</span> tcp_rcv(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span></span> *skb) {
    <span class="hljs-comment">/* Basic error checking */</span>
    <span class="hljs-keyword">if</span> (!skb || !skb-&gt;data) 
        <span class="hljs-keyword">return</span> -EINVAL;

    <span class="hljs-comment">/* Simple, linear processing of packet */</span>
    process_tcp_header(skb);
    process_tcp_options(skb);
    process_tcp_data(skb);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* Modern version - conceptual representation */</span>
<span class="hljs-keyword">int</span> tcp_v4_rcv(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sk_buff</span></span> *skb) {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span></span> *th;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock</span></span> *sk;

    <span class="hljs-comment">/* Extensive checksum and validation */</span>
    <span class="hljs-keyword">if</span> (!pskb_may_pull(skb, <span class="hljs-keyword">sizeof</span>(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">tcphdr</span></span>)) || 
        __tcp_checksum_complete(skb))
        goto discard_it;

    <span class="hljs-comment">/* Complex header processing */</span>
    th = tcp_hdr(skb);

    <span class="hljs-comment">/* Socket lookup using efficient hash tables */</span>
    sk = __inet_lookup_skb(&amp;tcp_hashinfo, skb, th-&gt;source, th-&gt;dest);

    <span class="hljs-comment">/* State machine handling with sophisticated locking */</span>
    <span class="hljs-keyword">if</span> (sk_fullsock(sk)) {
        <span class="hljs-keyword">if</span> (sk-&gt;sk_state == TCP_TIME_WAIT) {
            <span class="hljs-comment">/* Time-wait state handling */</span>
            tcp_v4_time_wait(skb, sk);
            goto discard_it;
        }

        <span class="hljs-comment">/* Socket delivery with NAPI, epoll, and other modern features */</span>
        <span class="hljs-keyword">if</span> (tcp_filter(sk, skb))
            goto discard_it;

        <span class="hljs-comment">/* Manage TCP window scaling, timestamps, SACK */</span>
        tcp_options_write((__be32 *)(th + <span class="hljs-number">1</span>),
                         tp, &amp;opts);

        <span class="hljs-comment">/* Handle congestion control algorithms */</span>
        tcp_cong_control(sk, skb, ack, rtt_us);
    }

    <span class="hljs-comment">/* Complex error handling and more... */</span>

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

discard_it:
    <span class="hljs-comment">/* Reference counting and memory management */</span>
    kfree_skb(skb);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>این نمونه‌کد نشان‌دهنده تفاوت بین پیاده‌سازی ساده و اولیه پشته شبکه TCP در لینوکس و نسخه مدرن و پیچیده آن است. تکامل کد کرنل لینوکس شامل بهبودهای زیادی در کارایی، قابلیت‌های پیشرفته، مدیریت خطا و ساختارهای داده پیچیده شده است.</p>
<h2 id="-">معماری کرنل لینوکس</h2>
<h3 id="-">کرنل مونولیتیک در مقابل میکروکرنل</h3>
<p>کرنل‌ها از نظر معماری به چند دسته تقسیم می‌شوند که دو طراحی اصلی آنها کرنل مونولیتیک و میکروکرنل هستند. این دو معماری از نظر فلسفی و عملی تفاوت‌های اساسی با یکدیگر دارند.</p>
<p><strong>کرنل مونولیتیک (Monolithic Kernel):</strong>
کرنل مونولیتیک یک معماری است که در آن تمامی سرویس‌های سیستم‌عامل (مدیریت حافظه، زمانبندی، سیستم فایل، درایورها) در یک فضای آدرس واحد و در حالت هسته (kernel mode) اجرا می‌شوند. در این معماری:</p>
<ul>
<li>تمام کد کرنل به صورت یک فایل اجرایی بزرگ کامپایل می‌شود</li>
<li>تعاملات بین اجزای کرنل با هزینه کمتری انجام می‌شود (فراخوانی تابع معمولی)</li>
<li>دسترسی مستقیم به تمام منابع سخت‌افزاری وجود دارد</li>
<li>معمولاً سرعت اجرای بالاتری دارد</li>
</ul>
<p><strong>میکروکرنل (Microkernel):</strong>
میکروکرنل یک معماری است که در آن فقط حداقل عملکردهای ضروری (مانند مدیریت پایه حافظه، ارتباطات بین فرآیندی و زمانبندی اولیه) در هسته قرار می‌گیرند و بقیه سرویس‌ها (مانند سیستم فایل، درایورها، پروتکل‌های شبکه) به صورت فرآیندهای کاربر اجرا می‌شوند. در این معماری:</p>
<ul>
<li>هسته کوچک‌تر و ساده‌تر است</li>
<li>اجزای سیستم از طریق ارسال پیام با یکدیگر ارتباط برقرار می‌کنند</li>
<li>ثبات و امنیت بیشتری دارد (خرابی یک سرویس می‌تواند بدون تأثیر بر کل سیستم برطرف شود)</li>
<li>معمولاً سربار ارتباطی بیشتری دارد و کندتر است</li>
</ul>
<p>لینوکس از معماری مونولیتیک استفاده می‌کند، اما با قابلیت بارگذاری ماژول‌های کرنل در زمان اجرا، تا حدی انعطاف‌پذیری معماری ماژولار را نیز به ارمغان آورده است. این طراحی که گاهی &quot;کرنل مونولیتیک ماژولار&quot; نامیده می‌شود، مزایای هر دو رویکرد را ترکیب کرده است.</p>
<p>بحث معروفی بین لینوس توروالدز (توسعه دهنده لینوکس) و اندرو تاننباوم (طراح Minix با معماری میکروکرنل) در اوایل دهه ۱۹۹۰ در مورد مزایا و معایب این دو رویکرد درگرفت. تاننباوم معتقد بود که میکروکرنل آینده سیستم‌عامل‌ها را تشکیل می‌دهد، در حالی که توروالدز از مزایای عملکردی کرنل مونولیتیک دفاع می‌کرد. تاریخ نشان داد که هر دو دیدگاه ارزش‌های خود را دارند و در حوزه‌های مختلف کاربرد دارند.</p>
<h3 id="-">مزایا و معایب معماری مونولیتیک لینوکس</h3>
<p>طراحی مونولیتیک لینوکس مزایا و معایب خاص خود را دارد که در طول زمان با بلوغ پروژه و اضافه شدن ویژگی‌هایی مانند ماژول‌های قابل بارگذاری کرنل، تعادل بهتری بین آنها ایجاد شده است.</p>
<p><strong>مزایا:</strong></p>
<ol>
<li><p><strong>کارایی بالا</strong>: به دلیل اجرای تمام کد کرنل در یک فضای آدرس واحد، تعاملات بین اجزای کرنل با هزینه کمتری انجام می‌شود. فراخوانی‌های تابع مستقیم بسیار سریع‌تر از ارسال پیام بین فرآیندها هستند.</p>
</li>
<li><p><strong>دسترسی مستقیم به سخت‌افزار</strong>: تمام بخش‌های کرنل می‌توانند مستقیماً به تمام منابع سخت‌افزاری دسترسی داشته باشند، که باعث ساده‌تر شدن توسعه و کارایی بیشتر می‌شود.</p>
</li>
<li><p><strong>اشتراک آسان داده‌ها</strong>: ساختارهای داده می‌توانند به راحتی بین بخش‌های مختلف کرنل به اشتراک گذاشته شوند.</p>
</li>
<li><p><strong>بهینه‌سازی سراسری</strong>: امکان بهینه‌سازی کد در سطح کل کرنل وجود دارد.</p>
</li>
<li><p><strong>انعطاف‌پذیری با ماژول‌ها</strong>: سیستم ماژول‌های لینوکس اجازه می‌دهد بخش‌های کرنل به صورت پویا بارگذاری و حذف شوند، که انعطاف‌پذیری را افزایش می‌دهد.</p>
</li>
</ol>
<p><strong>معایب:</strong></p>
<ol>
<li><p><strong>پیچیدگی</strong>: با بزرگ شدن کرنل، مدیریت و توسعه آن پیچیده‌تر می‌شود. پایگاه کد کرنل لینوکس امروزه بسیار بزرگ و پیچیده است.</p>
</li>
<li><p><strong>خطرات ثبات</strong>: یک اشکال در هر بخش از کرنل می‌تواند کل سیستم را دچار مشکل کند. هیچ جداسازی حافظه‌ای بین اجزای مختلف کرنل وجود ندارد.</p>
</li>
<li><p><strong>چالش‌های امنیتی</strong>: آسیب‌پذیری در یک بخش از کرنل می‌تواند کل سیستم را در معرض خطر قرار دهد.</p>
</li>
<li><p><strong>نیاز به راه‌اندازی مجدد برای به‌روزرسانی‌های اساسی</strong>: برخی تغییرات در کرنل نیازمند راه‌اندازی مجدد سیستم هستند، هرچند با قابلیت‌هایی مانند kpatch و kGraft می‌توان برخی وصله‌ها را بدون راه‌اندازی مجدد اعمال کرد.</p>
</li>
<li><p><strong>مسائل مقیاس‌پذیری</strong>: مشکلات مقیاس‌پذیری می‌تواند در سیستم‌های چندپردازنده بزرگ رخ دهد، هرچند توسعه‌دهندگان لینوکس تلاش زیادی برای بهبود این مسائل انجام داده‌اند.</p>
</li>
</ol>
<p>لینوکس برای کاهش معایب معماری مونولیتیک، راهکارهایی را اتخاذ کرده است:</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of Linux kernel module structure
 * This shows how Linux combines monolithic architecture with modularity
 */</span>

<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init.h&gt;</span></span>

<span class="hljs-comment">/* Module metadata */</span>
MODULE_LICENSE(<span class="hljs-string">"GPL"</span>);
MODULE_AUTHOR(<span class="hljs-string">"Author Name"</span>);
MODULE_DESCRIPTION(<span class="hljs-string">"Example kernel module"</span>);
MODULE_VERSION(<span class="hljs-string">"1.0"</span>);

<span class="hljs-comment">/* Module initialization function */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __<span class="hljs-function">init <span class="hljs-title">example_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    printk(KERN_INFO <span class="hljs-string">"Example module loaded\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* Module cleanup function */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __<span class="hljs-function"><span class="hljs-built_in">exit</span> <span class="hljs-title">example_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    printk(KERN_INFO <span class="hljs-string">"Example module unloaded\n"</span>);
}

<span class="hljs-comment">/* Register init/exit functions */</span>
module_init(example_init);
module_exit(example_exit);
</code></pre>
<p>این کد یک نمونه ساده از ساختار یک ماژول کرنل لینوکس را نشان می‌دهد. ماژول‌های کرنل به لینوکس اجازه می‌دهند که مزایای انعطاف‌پذیری معماری ماژولار را در یک کرنل مونولیتیک ترکیب کند.</p>
<h3 id="-">ساختار لایه‌ای کرنل لینوکس</h3>
<p>کرنل لینوکس، علی‌رغم ماهیت مونولیتیک خود، دارای یک ساختار لایه‌ای است که به سازماندهی و مدیریت پیچیدگی آن کمک می‌کند. این لایه‌بندی بیشتر یک مفهوم منطقی است، زیرا در عمل، اجزای کرنل می‌توانند مستقیماً با یکدیگر ارتباط برقرار کنند.</p>
<p>لایه‌های اصلی کرنل لینوکس به شرح زیر هستند (از بالا به پایین):</p>
<p><strong>۱. لایه فراخوانی سیستمی (System Call Interface)</strong>:</p>
<ul>
<li>واسط بین فضای کاربر و فضای کرنل</li>
<li>نقطه ورودی به کرنل برای برنامه‌های کاربردی</li>
<li>تبدیل درخواست‌های برنامه‌ها به عملیات کرنل</li>
</ul>
<p><strong>۲. لایه مدیریت فرآیند (Process Management)</strong>:</p>
<ul>
<li>مدیریت ایجاد، تعلیق، ادامه و خاتمه فرآیندها</li>
<li>زمانبندی فرآیندها برای اجرا روی پردازنده‌ها</li>
<li>سیستم‌های مرتبط با ارتباطات بین فرآیندی (IPC)</li>
</ul>
<p><strong>۳. لایه حافظه مجازی (Virtual Memory)</strong>:</p>
<ul>
<li>مدیریت فضای آدرس مجازی برای فرآیندها</li>
<li>پیاده‌سازی صفحه‌بندی و سازوکارهای مرتبط</li>
<li>مدیریت صفحه گردانی و سیاست‌های تعویض</li>
</ul>
<p><strong>۴. لایه سیستم فایل (File System)</strong>:</p>
<ul>
<li>ارائه سیستم فایل مجازی (VFS) به عنوان یک لایه انتزاعی</li>
<li>پشتیبانی از انواع مختلف سیستم‌های فایل (ext4, XFS, Btrfs و غیره)</li>
<li>مدیریت فایل‌ها، دایرکتوری‌ها و مجوزها</li>
</ul>
<p><strong>۵. لایه کش و بافر (Caching Layer)</strong>:</p>
<ul>
<li>ذخیره موقت داده‌ها برای بهبود کارایی</li>
<li>مدیریت کش دیسک و بافرها</li>
<li>سیاست‌های همگام‌سازی داده‌ها با دیسک</li>
</ul>
<p><strong>۶. لایه شبکه (Network Stack)</strong>:</p>
<ul>
<li>پیاده‌سازی پروتکل‌های شبکه</li>
<li>مدیریت اتصالات و بسته‌های شبکه</li>
<li>پشتیبانی از سوکت‌ها و واسط‌های شبکه</li>
</ul>
<p><strong>۷. لایه درایورهای دستگاه (Device Drivers)</strong>:</p>
<ul>
<li>ارتباط با سخت‌افزارهای متصل به سیستم</li>
<li>مدیریت انواع مختلف دستگاه‌ها (بلوکی، کاراکتری و غیره)</li>
<li>پیاده‌سازی رابط‌های خاص سخت‌افزار</li>
</ul>
<p><strong>۸. لایه مدیریت معماری (Architecture Management)</strong>:</p>
<ul>
<li>کد وابسته به معماری سخت‌افزاری خاص</li>
<li>مدیریت وقفه‌ها و تایمرها</li>
<li>راه‌اندازی و مدیریت سخت‌افزار پایه</li>
</ul>
<p>این لایه‌بندی به توسعه‌دهندگان کمک می‌کند تا با یک ساختار منطقی مشخص کار کنند، هرچند در عمل، مرز بین این لایه‌ها گاهی مبهم است و اجزای مختلف می‌توانند فراتر از محدوده لایه خود عمل کنند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Simplified representation of layered interactions in Linux kernel
 * Shows how a system call travels through kernel layers
 */</span>

<span class="hljs-comment">/* User space application making a system call */</span>
<span class="hljs-keyword">int</span> main() {
    <span class="hljs-keyword">int</span> fd = open(<span class="hljs-string">"/path/to/file"</span>, O_RDONLY);  <span class="hljs-comment">// User application calling open()</span>
    <span class="hljs-comment">// ...</span>
}

<span class="hljs-comment">/* System Call Interface Layer */</span>
SYSCALL_DEFINE3(open, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, filename, <span class="hljs-keyword">int</span>, flags, umode_t, mode)
{
    <span class="hljs-comment">/* Validate user parameters */</span>
    <span class="hljs-keyword">if</span> (IS_ERR(filename))
        <span class="hljs-keyword">return</span> PTR_ERR(filename);

    <span class="hljs-comment">/* Process Management Layer (checking permissions) */</span>
    <span class="hljs-keyword">if</span> (!may_open_file(current, filename, flags))
        <span class="hljs-keyword">return</span> -EACCES;

    <span class="hljs-comment">/* File System Layer */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *file = do_filp_open(AT_FDCWD, filename, flags, mode);
    <span class="hljs-keyword">if</span> (IS_ERR(file))
        <span class="hljs-keyword">return</span> PTR_ERR(file);

    <span class="hljs-comment">/* Getting a file descriptor from the process's file table */</span>
    fd = get_unused_fd_flags(flags);
    <span class="hljs-keyword">if</span> (fd &gt;= <span class="hljs-number">0</span>)
        fd_install(fd, file);

    <span class="hljs-keyword">return</span> fd;
}

<span class="hljs-comment">/* File System Layer functions */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *do_filp_open(<span class="hljs-keyword">int</span> dfd, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">filename</span></span> *filename, <span class="hljs-keyword">int</span> flags, umode_t mode)
{
    <span class="hljs-comment">/* VFS operations to find and open the file */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span></span> path;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *file;

    <span class="hljs-comment">/* Path lookup (traversing directories) */</span>
    error = path_lookup(filename, flags, &amp;path);

    <span class="hljs-comment">/* Creating a file structure */</span>
    file = alloc_file(&amp;path, flags, fops);

    <span class="hljs-comment">/* Device Driver Layer - if this is a device file */</span>
    <span class="hljs-keyword">if</span> (S_ISCHR(path.dentry-&gt;d_inode-&gt;i_mode))
        error = chrdev_open(path.dentry-&gt;d_inode, file);

    <span class="hljs-keyword">return</span> file;
}

<span class="hljs-comment">/* Device Driver Layer */</span>
<span class="hljs-keyword">int</span> chrdev_open(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *inode, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *filp)
{
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span> *fops;

    <span class="hljs-comment">/* Find the appropriate driver */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cdev</span></span> *cdev = inode-&gt;i_cdev;

    <span class="hljs-comment">/* Call the specific device driver's open function */</span>
    <span class="hljs-keyword">if</span> (cdev-&gt;ops-&gt;open)
        <span class="hljs-keyword">return</span> cdev-&gt;ops-&gt;open(inode, filp);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* Architecture Specific Layer (hardware interaction) */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> device_specific_open(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *inode, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *filp)
{
    <span class="hljs-comment">/* Hardware specific operations */</span>
    void __iomem *base = ioremap(DEVICE_BASE_ADDR, DEVICE_SIZE);

    <span class="hljs-comment">/* Initialize the hardware */</span>
    writel(DEVICE_INIT_VALUE, base + DEVICE_CONTROL_REG);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>این نمونه کد به صورت ساده‌شده نشان می‌دهد که چگونه یک فراخوانی سیستمی مانند <code>open()</code> از لایه‌های مختلف کرنل عبور می‌کند تا در نهایت به عملیات سخت‌افزاری تبدیل شود.</p>
<h3 id="-">ماژول‌های کرنل</h3>
<p>ماژول‌های کرنل یکی از نوآوری‌های مهم در طراحی لینوکس هستند که به این سیستم‌عامل انعطاف‌پذیری قابل توجهی بخشیده‌اند. ماژول‌ها بخش‌هایی از کد کرنل هستند که می‌توانند به صورت پویا در زمان اجرا بارگذاری یا از حافظه خارج شوند، بدون نیاز به راه‌اندازی مجدد سیستم.</p>
<p><strong>ویژگی‌های اصلی ماژول‌های کرنل:</strong></p>
<ol>
<li><p><strong>بارگذاری پویا</strong>: قابلیت افزودن و حذف عملکردها بدون نیاز به کامپایل مجدد کرنل یا راه‌اندازی مجدد سیستم</p>
</li>
<li><p><strong>بهینه‌سازی منابع</strong>: فقط ماژول‌های مورد نیاز بارگذاری می‌شوند، که باعث صرفه‌جویی در حافظه و منابع سیستم می‌شود</p>
</li>
<li><p><strong>توسعه آسان‌تر</strong>: توسعه‌دهندگان می‌توانند درایورها و ویژگی‌های جدید را بدون تغییر در هسته اصلی کرنل ایجاد کنند</p>
</li>
<li><p><strong>دسترسی کامل به API کرنل</strong>: ماژول‌ها به تمام توابع و ساختارهای داده کرنل دسترسی دارند</p>
</li>
</ol>
<p><strong>انواع ماژول‌های کرنل:</strong></p>
<ul>
<li><strong>درایورهای دستگاه</strong>: بیشترین کاربرد ماژول‌ها، پیاده‌سازی درایورها برای سخت‌افزارهای مختلف است</li>
<li><strong>سیستم‌های فایل</strong>: پشتیبانی از سیستم‌های فایل مختلف اغلب به صورت ماژول پیاده‌سازی می‌شود</li>
<li><strong>پروتکل‌های شبکه</strong>: پروتکل‌های مختلف شبکه می‌توانند به صورت ماژول بارگذاری شوند</li>
<li><strong>ویژگی‌های امنیتی</strong>: ماژول‌های امنیتی مانند SELinux یا AppArmor</li>
<li><strong>ماژول‌های کمکی</strong>: برای اضافه کردن قابلیت‌های متنوع به کرنل</li>
</ul>
<p><strong>مدیریت ماژول‌ها:</strong></p>
<p>لینوکس ابزارهایی برای مدیریت ماژول‌ها ارائه می‌دهد:</p>
<ul>
<li><code>insmod</code>: برای نصب یک ماژول</li>
<li><code>rmmod</code>: برای حذف یک ماژول</li>
<li><code>modprobe</code>: برای نصب یا حذف ماژول با در نظر گرفتن وابستگی‌ها</li>
<li><code>lsmod</code>: برای نمایش لیست ماژول‌های فعال</li>
<li><code>modinfo</code>: برای نمایش اطلاعات درباره یک ماژول</li>
</ul>
<p><strong>وابستگی‌های ماژول:</strong></p>
<p>ماژول‌ها می‌توانند به یکدیگر وابسته باشند. لینوکس از این وابستگی‌ها آگاه است و هنگام بارگذاری یک ماژول، ماژول‌های وابسته به آن را نیز بارگذاری می‌کند. همچنین، هنگام حذف یک ماژول، اطمینان حاصل می‌کند که هیچ ماژول دیگری به آن وابسته نباشد.</p>
<p><strong>امنیت ماژول‌ها:</strong></p>
<p>از آنجا که ماژول‌ها با امتیازات کامل کرنل اجرا می‌شوند، می‌توانند خطرات امنیتی ایجاد کنند. به همین دلیل:</p>
<ul>
<li>فقط کاربر ریشه (root) می‌تواند ماژول‌ها را نصب یا حذف کند</li>
<li>در بسیاری از توزیع‌های لینوکس، ماژول‌ها باید امضای دیجیتال داشته باشند</li>
<li>قابلیت بارگذاری ماژول می‌تواند برای افزایش امنیت غیرفعال شود</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of module dependencies in Linux
 * Shows how modules can export symbols for other modules to use
 */</span>

<span class="hljs-comment">/* In module_a.c */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init.h&gt;</span></span>

<span class="hljs-comment">/* Function to be exported */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">shared_function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span> </span>{
    printk(KERN_INFO <span class="hljs-string">"Shared function called with value: %d\n"</span>, value);
    <span class="hljs-keyword">return</span> value * <span class="hljs-number">2</span>;
}

<span class="hljs-comment">/* Export the symbol so other modules can use it */</span>
EXPORT_SYMBOL(shared_function);

MODULE_LICENSE(<span class="hljs-string">"GPL"</span>);
MODULE_AUTHOR(<span class="hljs-string">"Author Name"</span>);
MODULE_DESCRIPTION(<span class="hljs-string">"Module A with exported function"</span>);

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __<span class="hljs-function">init <span class="hljs-title">mod_a_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    printk(KERN_INFO <span class="hljs-string">"Module A loaded\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __<span class="hljs-function"><span class="hljs-built_in">exit</span> <span class="hljs-title">mod_a_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    printk(KERN_INFO <span class="hljs-string">"Module A unloaded\n"</span>);
}

module_init(mod_a_init);
module_exit(mod_a_exit);

<span class="hljs-comment">/* In module_b.c - depends on module_a */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/module.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/kernel.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;linux/init.h&gt;</span></span>

<span class="hljs-comment">/* Declare the external function */</span>
<span class="hljs-function"><span class="hljs-keyword">extern</span> <span class="hljs-keyword">int</span> <span class="hljs-title">shared_function</span><span class="hljs-params">(<span class="hljs-keyword">int</span> value)</span></span>;

MODULE_LICENSE(<span class="hljs-string">"GPL"</span>);
MODULE_AUTHOR(<span class="hljs-string">"Author Name"</span>);
MODULE_DESCRIPTION(<span class="hljs-string">"Module B that depends on Module A"</span>);
<span class="hljs-comment">/* Declare dependency */</span>
MODULE_DEPENDS(<span class="hljs-string">"module_a"</span>);

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __<span class="hljs-function">init <span class="hljs-title">mod_b_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    <span class="hljs-keyword">int</span> result;
    printk(KERN_INFO <span class="hljs-string">"Module B loaded\n"</span>);

    <span class="hljs-comment">/* Call the function from module_a */</span>
    result = shared_function(<span class="hljs-number">10</span>);
    printk(KERN_INFO <span class="hljs-string">"Result from shared function: %d\n"</span>, result);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __<span class="hljs-function"><span class="hljs-built_in">exit</span> <span class="hljs-title">mod_b_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span> </span>{
    printk(KERN_INFO <span class="hljs-string">"Module B unloaded\n"</span>);
}

module_init(mod_b_init);
module_exit(mod_b_exit);
</code></pre>
<p>این مثال نشان می‌دهد که چگونه ماژول‌ها می‌توانند توابع و سمبل‌های خود را برای استفاده سایر ماژول‌ها صادر کنند و چگونه وابستگی‌ها مدیریت می‌شوند.</p>
<h3 id="-">فضای کرنل و فضای کاربر</h3>
<p>یکی از مفاهیم اساسی در طراحی سیستم‌عامل لینوکس، تفکیک بین &quot;فضای کرنل&quot; و &quot;فضای کاربر&quot; است. این جداسازی برای امنیت، پایداری و حفاظت از منابع سیستم ضروری است.</p>
<p><strong>فضای کرنل (Kernel Space):</strong></p>
<p>فضای کرنل بخشی از حافظه سیستم است که فقط برای کرنل سیستم‌عامل رزرو شده است. در این فضا:</p>
<ul>
<li>کد کرنل و داده‌های آن قرار دارند</li>
<li>دسترسی مستقیم به سخت‌افزار وجود دارد</li>
<li>تمام سطوح دسترسی CPU (حلقه‌های 0 تا 3 در معماری x86) در دسترس هستند</li>
<li>کد با بالاترین امتیازات (حلقه 0) اجرا می‌شود</li>
<li>ماژول‌های کرنل در این فضا بارگذاری و اجرا می‌شوند</li>
<li>خطاها در این فضا می‌توانند باعث سقوط کل سیستم شوند</li>
</ul>
<p><strong>فضای کاربر (User Space):</strong></p>
<p>فضای کاربر بخشی از حافظه است که برنامه‌های کاربردی در آن اجرا می‌شوند. در این فضا:</p>
<ul>
<li>برنامه‌های کاربردی، کتابخانه‌ها و داده‌های آنها قرار دارند</li>
<li>دسترسی مستقیم به سخت‌افزار وجود ندارد</li>
<li>کد با محدودترین امتیازات (حلقه 3 در معماری x86) اجرا می‌شود</li>
<li>خطاها فقط به برنامه مربوطه محدود می‌شوند و کل سیستم را تحت تأثیر قرار نمی‌دهند</li>
<li>دسترسی به منابع سیستم از طریق فراخوانی‌های سیستمی انجام می‌شود</li>
</ul>
<p><strong>تعامل بین فضای کاربر و کرنل:</strong></p>
<p>برنامه‌های کاربردی برای دسترسی به منابع سیستم (مانند فایل‌ها، شبکه، حافظه، سخت‌افزار) باید با کرنل ارتباط برقرار کنند. این ارتباط از طریق &quot;فراخوانی‌های سیستمی&quot; انجام می‌شود:</p>
<ol>
<li>برنامه کاربر درخواستی را از طریق فراخوانی سیستمی ارسال می‌کند</li>
<li>CPU از حالت کاربر (حلقه 3) به حالت کرنل (حلقه 0) تغییر وضعیت می‌دهد (context switch)</li>
<li>کرنل درخواست را بررسی، اعتبارسنجی و پردازش می‌کند</li>
<li>کرنل نتیجه را به فضای کاربر برمی‌گرداند</li>
<li>CPU به حالت کاربر بازمی‌گردد</li>
</ol>
<p><strong>مکانیزم‌های حفاظتی:</strong></p>
<p>لینوکس از چندین مکانیزم برای محافظت از فضای کرنل استفاده می‌کند:</p>
<ul>
<li><strong>حفاظت حافظه</strong>: MMU (Memory Management Unit) از دسترسی غیرمجاز به حافظه جلوگیری می‌کند</li>
<li><strong>سطوح امتیازات پردازنده</strong>: با استفاده از حلقه‌های حفاظتی CPU، دسترسی به دستورات حساس محدود می‌شود</li>
<li><strong>فضای آدرس مجازی</strong>: هر فرآیند فضای آدرس مجازی خود را دارد و نمی‌تواند به فضای دیگر فرآیندها دسترسی پیدا کند</li>
<li><strong>کنترل دسترسی</strong>: بررسی مجوزها و توانایی‌ها قبل از انجام عملیات</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of userspace to kernel space transition via system call
 * This demonstrates how processes cross the boundary between user and kernel space
 */</span>

<span class="hljs-comment">/* User space C code calling write() system call */</span>
#<span class="hljs-keyword">include</span> &lt;unistd.<span class="hljs-keyword">h</span>&gt;
#<span class="hljs-keyword">include</span> &lt;string.<span class="hljs-keyword">h</span>&gt;

int main() {
    <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *message = <span class="hljs-string">"Hello, Kernel!"</span>;
    write(1, message, <span class="hljs-built_in">strlen</span>(message));  <span class="hljs-comment">// System call to write to stdout (fd=1)</span>
    <span class="hljs-keyword">return</span> 0;
}

<span class="hljs-comment">/* Inside the kernel: system call implementation */</span>
SYSCALL_DEFINE3(write, unsigned int, fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, buf, size_t, <span class="hljs-keyword">count</span>)
{
    struct <span class="hljs-keyword">file</span> *<span class="hljs-keyword">file</span>;
    ssize_t <span class="hljs-keyword">ret</span> = -EBADF;

    <span class="hljs-comment">/* Get file from file descriptor - security check happens here */</span>
    <span class="hljs-keyword">file</span> = fget_light(fd, &amp;fput_needed);
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">file</span>)
        goto <span class="hljs-keyword">out</span>;

    <span class="hljs-comment">/* Verify user space buffer is accessible and valid */</span>
    <span class="hljs-keyword">if</span> (!access_ok(VERIFY_READ, buf, <span class="hljs-keyword">count</span>)) {
        <span class="hljs-keyword">ret</span> = -EFAULT;
        goto out_put;
    }

    <span class="hljs-comment">/* Perform the actual writing operation */</span>
    <span class="hljs-keyword">ret</span> = vfs_write(<span class="hljs-keyword">file</span>, buf, <span class="hljs-keyword">count</span>, &amp;pos);

out_put:
    fput_light(<span class="hljs-keyword">file</span>, fput_needed);
<span class="hljs-keyword">out</span>:
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;
}
</code></pre>
<p>این نمونه کد نشان می‌دهد که چگونه یک برنامه در فضای کاربر با فراخوانی تابع <code>write()</code> به کرنل مراجعه می‌کند و چگونه کرنل بررسی‌های امنیتی را انجام می‌دهد تا از دسترسی معتبر اطمینان حاصل کند.</p>
<h3 id="-">سیستم فراخوانی سیستمی</h3>
<p>فراخوانی‌های سیستمی (System Calls) واسط اصلی بین فضای کاربر و فضای کرنل هستند. این فراخوانی‌ها، API کرنل را برای برنامه‌های کاربردی فراهم می‌کنند تا بتوانند از خدماتی مانند عملیات ورودی/خروجی، مدیریت فرآیند، مدیریت حافظه و دسترسی به سخت‌افزار استفاده کنند.</p>
<p><strong>ویژگی‌های فراخوانی‌های سیستمی:</strong></p>
<ol>
<li><strong>نقطه ورود کنترل‌شده</strong>: تنها راه ورود امن به کرنل از فضای کاربر هستند</li>
<li><strong>انتزاع سخت‌افزار</strong>: جزئیات پیچیده سخت‌افزار را از برنامه‌های کاربردی پنهان می‌کنند</li>
<li><strong>کنترل دسترسی</strong>: کرنل می‌تواند درخواست‌ها را اعتبارسنجی کرده و از دسترسی‌های غیرمجاز جلوگیری کند</li>
<li><strong>هزینه عملکردی</strong>: فراخوانی‌های سیستمی نسبت به فراخوانی‌های تابع معمولی هزینه اجرایی بیشتری دارند</li>
<li><strong>پایداری API</strong>: فراخوانی‌های سیستمی به عنوان بخشی از ABI (Application Binary Interface) لینوکس، نسبتاً پایدار هستند</li>
</ol>
<p><strong>دسته‌بندی فراخوانی‌های سیستمی در لینوکس:</strong></p>
<p>لینوکس بیش از 300 فراخوانی سیستمی دارد که می‌توان آنها را به گروه‌های زیر تقسیم کرد:</p>
<ul>
<li><strong>مدیریت فرآیند</strong>: <code>fork()</code>, <code>exec()</code>, <code>exit()</code>, <code>wait()</code>, <code>kill()</code></li>
<li><strong>مدیریت حافظه</strong>: <code>brk()</code>, <code>mmap()</code>, <code>munmap()</code></li>
<li><strong>عملیات فایل</strong>: <code>open()</code>, <code>read()</code>, <code>write()</code>, <code>close()</code>, <code>stat()</code></li>
<li><strong>مدیریت دایرکتوری</strong>: <code>mkdir()</code>, <code>rmdir()</code>, <code>link()</code>, <code>unlink()</code></li>
<li><strong>ارتباطات بین فرآیندی</strong>: <code>pipe()</code>, <code>socket()</code>, <code>shmget()</code></li>
<li><strong>مدیریت زمان</strong>: <code>time()</code>, <code>gettimeofday()</code>, <code>nanosleep()</code></li>
<li><strong>مدیریت سیستم</strong>: <code>mount()</code>, <code>reboot()</code>, <code>syslog()</code></li>
<li><strong>کنترل دسترسی</strong>: <code>chmod()</code>, <code>chown()</code>, <code>setuid()</code></li>
</ul>
<p><strong>مکانیزم فراخوانی سیستمی:</strong></p>
<p>روند یک فراخوانی سیستمی به طور کلی به شرح زیر است:</p>
<ol>
<li><strong>آماده‌سازی پارامترها</strong>: برنامه کاربردی پارامترهای لازم را در رجیسترهای CPU یا پشته قرار می‌دهد</li>
<li><strong>ایجاد وقفه نرم‌افزاری</strong>: از طریق دستور خاص معماری (مثلاً <code>syscall</code> در x86_64 یا <code>svc</code> در ARM)</li>
<li><strong>تغییر به حالت کرنل</strong>: CPU به حالت کرنل (حلقه 0) منتقل می‌شود</li>
<li><strong>یافتن کد مناسب</strong>: کرنل شماره فراخوانی سیستمی را بررسی و تابع مربوطه را پیدا می‌کند</li>
<li><strong>اعتبارسنجی پارامترها</strong>: کرنل پارامترهای ارائه شده را بررسی می‌کند</li>
<li><strong>اجرای سرویس</strong>: کرنل درخواست را پردازش می‌کند</li>
<li><strong>بازگشت نتیجه</strong>: کرنل نتیجه را در رجیستر مشخصی قرار می‌دهد</li>
<li><strong>بازگشت به حالت کاربر</strong>: CPU به حالت کاربر (حلقه 3) بازمی‌گردد و اجرای برنامه ادامه می‌یابد</li>
</ol>
<p><strong>پیاده‌سازی فراخوانی‌های سیستمی در لینوکس:</strong></p>
<p>در کد منبع کرنل لینوکس، فراخوانی‌های سیستمی به وسیله ماکروی <code>SYSCALL_DEFINEx</code> تعریف می‌شوند، که در آن <code>x</code> نشان‌دهنده تعداد پارامترهای فراخوانی سیستمی است.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of system call implementation in Linux kernel
 * Shows how the open() system call is defined
 */</span>

<span class="hljs-comment">/* System call definition for open() */</span>
SYSCALL_DEFINE3(open, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, filename, <span class="hljs-keyword">int</span>, flags, <span class="hljs-keyword">umode_t</span>, mode)
{
    <span class="hljs-comment">/* Convert user-provided filename to kernel struct */</span>
    <span class="hljs-keyword">struct</span> filename *tmp = getname(filename);
    <span class="hljs-keyword">int</span> fd;

    <span class="hljs-comment">/* Check for errors in filename */</span>
    <span class="hljs-keyword">if</span> (IS_ERR(tmp))
        <span class="hljs-keyword">return</span> PTR_ERR(tmp);

    <span class="hljs-comment">/* Call the actual implementation */</span>
    fd = do_sys_open(AT_FDCWD, tmp, flags, mode);
    putname(tmp);
    <span class="hljs-keyword">return</span> fd;
}

<span class="hljs-comment">/* Actual implementation that does the work */</span>
<span class="hljs-function"><span class="hljs-keyword">long</span> <span class="hljs-title">do_sys_open</span><span class="hljs-params">(<span class="hljs-keyword">int</span> dfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *filename, <span class="hljs-keyword">int</span> flags, <span class="hljs-keyword">umode_t</span> mode)</span>
</span>{
    <span class="hljs-keyword">struct</span> open_flags op;
    <span class="hljs-keyword">int</span> fd;

    <span class="hljs-comment">/* Validate flags */</span>
    <span class="hljs-keyword">int</span> ret = build_open_flags(flags, mode, &amp;op);
    <span class="hljs-keyword">if</span> (ret)
        <span class="hljs-keyword">return</span> ret;

    <span class="hljs-comment">/* Allocate a new file descriptor */</span>
    fd = get_unused_fd_flags(flags);
    <span class="hljs-keyword">if</span> (fd &gt;= <span class="hljs-number">0</span>) {
        <span class="hljs-keyword">struct</span> file *f = do_filp_open(dfd, filename, &amp;op);
        <span class="hljs-keyword">if</span> (IS_ERR(f)) {
            put_unused_fd(fd);
            fd = PTR_ERR(f);
        } <span class="hljs-keyword">else</span> {
            <span class="hljs-comment">/* Associate the file descriptor with the file */</span>
            fd_install(fd, f);
        }
    }

    <span class="hljs-keyword">return</span> fd;
}
</code></pre>
<p><strong>لایه‌های کتابخانه‌ای:</strong></p>
<p>برنامه‌های کاربردی معمولاً به جای فراخوانی مستقیم سیستمی، از توابع کتابخانه‌ای مانند کتابخانه استاندارد C (glibc) استفاده می‌کنند. این کتابخانه‌ها یک لایه انتزاعی اضافی ارائه می‌دهند که:</p>
<ul>
<li>فراخوانی‌های سیستمی را ساده‌تر می‌کنند</li>
<li>سازگاری بین پلتفرم‌های مختلف را فراهم می‌کنند</li>
<li>در برخی موارد، با بافرینگ و پردازش‌های دیگر، کارایی را بهبود می‌بخشند</li>
</ul>
<p>به عنوان مثال، تابع <code>printf()</code> در کتابخانه C در نهایت از فراخوانی سیستمی <code>write()</code> برای نمایش متن استفاده می‌کند، اما پیش از آن، قالب‌بندی متن را انجام می‌دهد.</p>
<p><strong>مقایسه با سایر سیستم‌عامل‌ها:</strong></p>
<p>تقریباً تمام سیستم‌عامل‌های مدرن از مفهوم فراخوانی سیستمی استفاده می‌کنند، اما تعداد، نام و رفتار آنها متفاوت است. برای مثال:</p>
<ul>
<li><strong>Windows</strong>: از مکانیزم متفاوتی به نام Windows API استفاده می‌کند که در آن، فراخوانی‌ها پیچیده‌تر و لایه‌ای‌تر هستند</li>
<li><strong>macOS/iOS</strong>: از فراخوانی‌های سیستمی سازگار با UNIX همراه با اضافات خاص اپل استفاده می‌کند</li>
<li><strong>BSD</strong>: فراخوانی‌های سیستمی مشابه با لینوکس دارد اما با تفاوت‌های جزئی</li>
</ul>
<p><strong>تغییرات و تکامل:</strong></p>
<p>سیستم فراخوانی سیستمی لینوکس به مرور زمان تکامل یافته است:</p>
<ul>
<li>برخی فراخوانی‌های قدیمی منسوخ شده‌اند</li>
<li>نسخه‌های جدیدتر با پارامترهای بیشتر یا رفتار بهبود یافته اضافه شده‌اند (مانند <code>openat()</code> به جای <code>open()</code>)</li>
<li>مکانیزم‌های جدیدی مانند <code>ioctl()</code> برای عملیات اختصاصی دستگاه‌ها اضافه شده‌اند</li>
<li>معرفی syscall multiplexer مانند <code>socketcall()</code> برای کاهش تعداد نقاط ورودی</li>
</ul>
<p>توسعه‌دهندگان کرنل لینوکس تلاش می‌کنند تا سازگاری رو به عقب را حفظ کنند، به این معنی که برنامه‌های قدیمی‌تر همچنان باید با نسخه‌های جدیدتر کرنل کار کنند، بدون نیاز به تغییر یا کامپایل مجدد.</p>
<h3 id="-">خلاصه معماری کرنل لینوکس</h3>
<p>معماری کرنل لینوکس یک طراحی مونولیتیک با قابلیت‌های ماژولار است که در عین حفظ کارایی بالا، انعطاف‌پذیری قابل توجهی را فراهم می‌کند. ویژگی‌های کلیدی این معماری عبارتند از:</p>
<ol>
<li><p><strong>کرنل مونولیتیک ماژولار</strong>: یک معماری کرنل واحد که با سیستم ماژول‌ها قابلیت گسترش پویا را دارد</p>
</li>
<li><p><strong>ساختار لایه‌ای منطقی</strong>: سازماندهی کد در لایه‌های مختلف از فراخوانی‌های سیستمی تا درایورهای سخت‌افزاری</p>
</li>
<li><p><strong>جداسازی فضای کاربر و کرنل</strong>: تفکیک امنیتی بین برنامه‌های کاربردی و کد امتیاز بالای کرنل</p>
</li>
<li><p><strong>واسط فراخوانی سیستمی</strong>: مکانیزم کنترل‌شده برای تعامل بین برنامه‌های کاربردی و کرنل</p>
</li>
<li><p><strong>سیستم ماژول‌های پویا</strong>: امکان افزودن و حذف قابلیت‌ها بدون نیاز به راه‌اندازی مجدد</p>
</li>
</ol>
<p>این معماری به لینوکس اجازه داده است تا ضمن حفظ عملکرد بالا، در طیف گسترده‌ای از دستگاه‌ها از ریزپردازنده‌های نهفته تا ابررایانه‌ها مورد استفاده قرار گیرد. تعادل بین کارایی معماری مونولیتیک و انعطاف‌پذیری سیستم ماژولار، یکی از دلایل اصلی موفقیت لینوکس بوده است.</p>
<p>طراحی هوشمندانه معماری کرنل لینوکس، امکان توسعه سریع و مداوم این سیستم‌عامل را فراهم کرده است، به طوری که در طول بیش از سه دهه، کرنل لینوکس توانسته است با تغییرات سریع فناوری همگام شده و همزمان سازگاری با کدهای قدیمی را حفظ کند.</p>
<h2 id="-">ویژگی‌های اصلی کرنل لینوکس</h2>
<p>کرنل لینوکس دارای ویژگی‌های متعددی است که آن را به یک انتخاب مناسب برای طیف گسترده‌ای از کاربردها، از سیستم‌های نهفته گرفته تا ابررایانه‌ها، تبدیل کرده است. در این بخش، مهم‌ترین ویژگی‌های کرنل لینوکس را بررسی می‌کنیم.</p>
<h3 id="-">چند وظیفه‌ای پیشگیرانه</h3>
<p>یکی از ویژگی‌های اصلی کرنل لینوکس، پشتیبانی از چند وظیفه‌ای پیشگیرانه (Preemptive Multitasking) است. در این نوع چند وظیفه‌ای، کرنل می‌تواند اجرای یک فرآیند را متوقف کرده و به فرآیند دیگری زمان پردازنده تخصیص دهد، حتی اگر فرآیند اول تمایلی به واگذاری پردازنده نداشته باشد.</p>
<p><strong>مزایای چند وظیفه‌ای پیشگیرانه:</strong></p>
<ul>
<li><strong>پاسخگویی بهتر سیستم</strong>: فرآیندهای با اولویت بالاتر می‌توانند سریع‌تر به منابع پردازنده دسترسی پیدا کنند</li>
<li><strong>توزیع عادلانه‌تر منابع</strong>: یک فرآیند نمی‌تواند به طور نامحدود پردازنده را اشغال کند</li>
<li><strong>قابلیت اطمینان بیشتر</strong>: حتی اگر یک برنامه وارد حلقه بی‌نهایت شود، سیستم همچنان پاسخگو خواهد بود</li>
</ul>
<p>لینوکس از الگوریتم‌های پیچیده زمانبندی استفاده می‌کند که بر اساس اولویت‌ها، مدت زمان اجرا، و سایر فاکتورها فرآیندها را زمانبندی می‌کنند. همچنین، کرنل لینوکس از نسخه 2.6 به بعد، قابلیت پیشگیری کامل (Fully Preemptible) را ارائه می‌دهد که حتی کد کرنل نیز می‌تواند تحت شرایط خاصی پیشگیری شود.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of scheduler code in Linux that demonstrates preemption
 * Simplified version of schedule() function
 */</span>
asmlinkage __visible void __sched <span class="hljs-keyword">schedule(void)
</span>{
    struct task_struct *prev, *next<span class="hljs-comment">;</span>
    struct rq *rq<span class="hljs-comment">;</span>
    int cpu<span class="hljs-comment">;</span>

    cpu = smp_processor_id()<span class="hljs-comment">;</span>
    rq = cpu_rq(cpu)<span class="hljs-comment">;</span>
    prev = rq-&gt;curr<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* Find the highest priority task that is ready to run */</span>
    next = pick_next_task(rq, prev)<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* If a different task is selected, switch to it */</span>
    if (likely(prev != next)) {
        rq-&gt;curr = next<span class="hljs-comment">;</span>
        <span class="hljs-comment">/* Context switch - save current state and load new task state */</span>
        context_switch(rq, prev, next)<span class="hljs-comment">;</span>
    }
}
</code></pre>
<p>این نمونه کد ساده‌شده نشان می‌دهد چگونه لینوکس به طور دوره‌ای تابع <code>schedule()</code> را فراخوانی می‌کند تا فرآیند با بالاترین اولویت را انتخاب کرده و در صورت لزوم، تعویض زمینه (context switch) انجام دهد.</p>
<h3 id="-">پشتیبانی از چند پردازنده</h3>
<p>لینوکس از نسخه 2.0 (1996) از سیستم‌های چندپردازنده‌ای (SMP - Symmetric Multi-Processing) پشتیبانی می‌کند. این قابلیت به لینوکس اجازه می‌دهد تا از منابع محاسباتی چندین پردازنده (یا هسته پردازشی) به طور همزمان استفاده کند.</p>
<p><strong>ویژگی‌های پشتیبانی چندپردازنده‌ای در لینوکس:</strong></p>
<ul>
<li><strong>مقیاس‌پذیری</strong>: قابلیت استفاده مؤثر از تعداد زیادی پردازنده (از چند هسته تا هزاران هسته در ابررایانه‌ها)</li>
<li><strong>تعادل بار</strong>: توزیع هوشمند فرآیندها بین پردازنده‌های موجود</li>
<li><strong>تخصیص منابع پویا</strong>: تخصیص پردازنده‌ها به فرآیندها بر اساس نیاز و بار سیستم</li>
<li><strong>قفل‌های ظریف</strong>: استفاده از مکانیزم‌های قفل‌گذاری با سطوح مختلف برای بهینه‌سازی هم‌روندی</li>
<li><strong>جداسازی NUMA</strong>: آگاهی از توپولوژی حافظه غیریکنواخت (Non-Uniform Memory Access) برای بهینه‌سازی دسترسی‌های حافظه</li>
</ul>
<p>کرنل لینوکس در طول زمان، پشتیبانی خود از سیستم‌های چندپردازنده‌ای را به طور قابل توجهی بهبود بخشیده است. در نسخه‌های اولیه، یک قفل بزرگ کرنل (Big Kernel Lock) تنها یک پردازنده را به اجرای کد کرنل محدود می‌کرد، اما در نسخه‌های جدیدتر، با استفاده از قفل‌های ظریف‌تر و تکنیک‌های پیشرفته هم‌روندی، کرنل می‌تواند به طور همزمان روی چندین پردازنده اجرا شود.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of fine-grained locking in the Linux kernel
 * Demonstrates how Linux uses various locking mechanisms for SMP
 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *find_task_by_pid_ns(pid_t nr, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pid_namespace</span></span> *ns)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *task;

    <span class="hljs-comment">/* Use RCU (Read-Copy-Update) for lockless read access */</span>
    rcu_read_lock();

    task = pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);

    rcu_read_unlock();

    <span class="hljs-keyword">return</span> task;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> write_task_data(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *task, void __user *buffer, size_t size)
{
    <span class="hljs-keyword">int</span> ret;

    <span class="hljs-comment">/* Use spinlock for short critical section on SMP systems */</span>
    spin_lock_irq(&amp;task-&gt;sighand-&gt;siglock);

    <span class="hljs-comment">/* Access protected data */</span>
    ret = copy_to_user(buffer, &amp;task-&gt;signal-&gt;data, size);

    spin_unlock_irq(&amp;task-&gt;sighand-&gt;siglock);

    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-comment">/* Using RwLock for data that is read frequently but written rarely */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> modify_shared_resource(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">shared_resource</span></span> *res, <span class="hljs-keyword">int</span> new_value)
{
    <span class="hljs-keyword">int</span> ret;

    <span class="hljs-comment">/* Get write lock (exclusive access) */</span>
    write_lock(&amp;res-&gt;lock);

    <span class="hljs-comment">/* Modify the shared resource */</span>
    res-&gt;value = new_value;
    ret = res-&gt;value;

    write_unlock(&amp;res-&gt;lock);

    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<p>این نمونه کد نشان می‌دهد چگونه لینوکس از انواع مختلف قفل‌ها (RCU، اسپین‌لاک، قفل خواندن/نوشتن) برای مدیریت دسترسی هم‌روند به منابع مشترک در محیط‌های چندپردازنده‌ای استفاده می‌کند.</p>
<h3 id="-">قابلیت حمل</h3>
<p>یکی از قابلیت‌های برجسته کرنل لینوکس، قابلیت حمل (Portability) فوق‌العاده آن است. لینوکس برای طیف گسترده‌ای از معماری‌های پردازنده و پلتفرم‌های سخت‌افزاری پورت (انتقال) شده است، از میکروکنترلرهای کوچک تا ابررایانه‌های قدرتمند.</p>
<p><strong>معماری‌های پردازنده پشتیبانی شده توسط لینوکس:</strong></p>
<ul>
<li><strong>x86 و x86-64</strong> (Intel، AMD)</li>
<li><strong>ARM و ARM64</strong> (Qualcomm، Samsung، Apple، و غیره)</li>
<li><strong>PowerPC و POWER</strong> (IBM)</li>
<li><strong>MIPS</strong> (پیش‌تر از SGI، اکنون در بسیاری از دستگاه‌های نهفته)</li>
<li><strong>SPARC</strong> (Oracle، پیش‌تر Sun)</li>
<li><strong>RISC-V</strong> (معماری متن‌باز جدید)</li>
<li><strong>s390</strong> (سرورهای مین‌فریم IBM)</li>
<li>و بسیاری دیگر...</li>
</ul>
<p><strong>عوامل کلیدی قابلیت حمل لینوکس:</strong></p>
<ol>
<li><p><strong>جداسازی کد وابسته به معماری</strong>: کرنل لینوکس به طور واضح کد وابسته به سخت‌افزار را از کد مستقل از سخت‌افزار جدا می‌کند. در ساختار درختی کد منبع، دایرکتوری <code>arch/</code> شامل کد خاص هر معماری است، در حالی که بخش‌های دیگر مستقل از معماری هستند.</p>
</li>
<li><p><strong>لایه انتزاعی سخت‌افزار</strong>: لینوکس از چندین لایه انتزاعی استفاده می‌کند تا تفاوت‌های بین پلتفرم‌ها را پنهان کند.</p>
</li>
<li><p><strong>کامپایل متقاطع</strong>: سیستم ساخت لینوکس به راحتی از کامپایل متقاطع (Cross-Compilation) پشتیبانی می‌کند، یعنی می‌توان کرنل را روی یک معماری برای اجرا روی معماری دیگر کامپایل کرد.</p>
</li>
<li><p><strong>معماری ماژولار درایورها</strong>: سیستم درایور دستگاه لینوکس به گونه‌ای طراحی شده است که درایورهای جدید می‌توانند بدون تغییر در هسته کرنل اضافه شوند.</p>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of architecture-specific code in Linux
 * Shows how Linux separates architecture-dependent code
 */</span>

<span class="hljs-comment">/* arch/x86/kernel/process.c - x86 specific process handling */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arch_cpu_idle</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-comment">/* x86 specific CPU idle implementation */</span>
    native_safe_halt();
}

<span class="hljs-comment">/* arch/arm/kernel/process.c - ARM specific process handling */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">arch_cpu_idle</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-comment">/* ARM specific CPU idle implementation */</span>
    cpu_do_idle();
}

<span class="hljs-comment">/* Kernel/sched/idle.c - Architecture-independent code */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">cpu_idle</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-comment">/* Common idle loop code that works on all architectures */</span>
    <span class="hljs-keyword">while</span> (<span class="hljs-number">1</span>) {
        <span class="hljs-keyword">while</span> (!need_resched()) {
            <span class="hljs-comment">/* Call architecture-specific idle function */</span>
            arch_cpu_idle();
        }

        schedule_preempt_disabled();
    }
}
</code></pre>
<p>این نمونه کد نشان می‌دهد چگونه لینوکس یک واسط عمومی (<code>cpu_idle()</code>) تعریف می‌کند که توسط همه معماری‌ها استفاده می‌شود، در حالی که پیاده‌سازی خاص هر معماری (<code>arch_cpu_idle()</code>) در فایل‌های جداگانه قرار می‌گیرد.</p>
<h3 id="-posix">استانداردهای POSIX</h3>
<p>لینوکس به طور گسترده از استانداردهای POSIX (Portable Operating System Interface) پیروی می‌کند. POSIX مجموعه‌ای از استانداردهای IEEE است که سازگاری بین سیستم‌عامل‌های مختلف را تعریف می‌کند.</p>
<p><strong>مزایای پیروی از POSIX:</strong></p>
<ul>
<li><strong>قابلیت حمل برنامه‌ها</strong>: برنامه‌های نوشته شده برای یک سیستم‌عامل سازگار با POSIX می‌توانند به راحتی روی سایر سیستم‌عامل‌های سازگار با POSIX (مانند مک‌او‌اس، FreeBSD و غیره) کامپایل و اجرا شوند.</li>
<li><strong>آشنایی برای توسعه‌دهندگان</strong>: برنامه‌نویسانی که با سیستم‌های UNIX آشنا هستند، می‌توانند به راحتی برای لینوکس برنامه‌نویسی کنند.</li>
<li><strong>استفاده از ابزارها و کتابخانه‌های استاندارد</strong>: امکان استفاده از ابزارها و کتابخانه‌های توسعه یافته برای سیستم‌های سازگار با POSIX.</li>
</ul>
<p><strong>برخی از بخش‌های استاندارد POSIX که لینوکس پیاده‌سازی می‌کند:</strong></p>
<ul>
<li><strong>POSIX.1</strong>: فراخوانی‌های سیستمی پایه</li>
<li><strong>POSIX.1b</strong>: امکانات زمان واقعی</li>
<li><strong>POSIX.1c</strong>: نخ‌ها (Threads)</li>
<li><strong>POSIX.2</strong>: پوسته و ابزارهای خط فرمان</li>
</ul>
<p>البته لازم به ذکر است که لینوکس به طور کامل با تمام جزئیات POSIX سازگار نیست و برخی از گسترش‌های خاص خود را نیز دارد. با این حال، سطح سازگاری با POSIX به قدری بالاست که اکثر برنامه‌های نوشته شده برای UNIX می‌توانند با حداقل تغییرات روی لینوکس کامپایل و اجرا شوند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of POSIX-compliant system calls in Linux
 * Demonstrates standard POSIX APIs implemented in Linux
 */</span>

<span class="hljs-comment">/* POSIX-compliant file operations */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;fcntl.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;unistd.h&gt;</span></span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/stat.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">create_and_write_file</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *path, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *data, <span class="hljs-keyword">size_t</span> size)</span>
</span>{
    <span class="hljs-comment">/* POSIX-defined open() with standard flags */</span>
    <span class="hljs-keyword">int</span> fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, <span class="hljs-number">0644</span>);
    <span class="hljs-keyword">if</span> (fd == <span class="hljs-number">-1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-comment">/* POSIX-defined write() */</span>
    <span class="hljs-keyword">ssize_t</span> written = write(fd, data, size);

    <span class="hljs-comment">/* POSIX-defined close() */</span>
    close(fd);

    <span class="hljs-keyword">return</span> (written == size) ? <span class="hljs-number">0</span> : <span class="hljs-number">-1</span>;
}

<span class="hljs-comment">/* POSIX-compliant process management */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sys/wait.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">execute_command</span><span class="hljs-params">(<span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> *command)</span>
</span>{
    <span class="hljs-keyword">pid_t</span> pid;
    <span class="hljs-keyword">int</span> status;

    <span class="hljs-comment">/* POSIX-defined fork() */</span>
    pid = fork();

    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">-1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

    <span class="hljs-keyword">if</span> (pid == <span class="hljs-number">0</span>) {
        <span class="hljs-comment">/* Child process - POSIX-defined execl() */</span>
        execl(<span class="hljs-string">"/bin/sh"</span>, <span class="hljs-string">"sh"</span>, <span class="hljs-string">"-c"</span>, command, <span class="hljs-literal">NULL</span>);
        <span class="hljs-comment">/* If execl returns, an error occurred */</span>
        _exit(<span class="hljs-number">127</span>);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">/* Parent process - POSIX-defined waitpid() */</span>
        <span class="hljs-keyword">if</span> (waitpid(pid, &amp;status, <span class="hljs-number">0</span>) == <span class="hljs-number">-1</span>)
            <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;

        <span class="hljs-keyword">return</span> WEXITSTATUS(status);
    }
}
</code></pre>
<p>این نمونه کد نشان می‌دهد چگونه لینوکس APIهای استاندارد POSIX مانند <code>open()</code>, <code>write()</code>, <code>close()</code>, <code>fork()</code>, <code>execl()</code>, و <code>waitpid()</code> را پیاده‌سازی می‌کند که باعث می‌شود برنامه‌های نوشته شده برای لینوکس روی سایر سیستم‌های سازگار با POSIX نیز قابل اجرا باشند.</p>
<h3 id="-">پشتیبانی از سخت‌افزارهای متنوع</h3>
<p>یکی از قدرت‌های بزرگ کرنل لینوکس، توانایی آن در پشتیبانی از طیف گسترده‌ای از سخت‌افزارها است. این ویژگی به لینوکس اجازه می‌دهد تا در انواع مختلف دستگاه‌ها، از گوشی‌های هوشمند گرفته تا اتومبیل‌ها، تلویزیون‌های هوشمند، روترها، سرورها و ابررایانه‌ها مورد استفاده قرار گیرد.</p>
<p><strong>عوامل کلیدی در پشتیبانی گسترده از سخت‌افزار:</strong></p>
<ol>
<li><strong>مدل درایور باز</strong>: هر کسی می‌تواند برای سخت‌افزار جدید، درایور لینوکس بنویسد.</li>
<li><strong>تعداد بالای توسعه‌دهندگان</strong>: هزاران توسعه‌دهنده در سراسر جهان به نوشتن و بهبود درایورها کمک می‌کنند.</li>
<li><strong>همکاری شرکت‌ها</strong>: بسیاری از شرکت‌های بزرگ سخت‌افزاری مانند Intel، AMD، NVIDIA، و غیره به طور مستقیم در توسعه درایورهای لینوکس مشارکت می‌کنند.</li>
<li><strong>سیستم ماژولار درایورها</strong>: درایورهای جدید می‌توانند بدون نیاز به تغییر در هسته کرنل اضافه شوند.</li>
<li><strong>چارچوب‌های زیرساختی</strong>: کرنل لینوکس چارچوب‌های متعددی برای انواع مختلف سخت‌افزار (مانند شبکه، گرافیک، صدا، و غیره) ارائه می‌دهد.</li>
</ol>
<p><strong>انواع سخت‌افزارهای پشتیبانی شده:</strong></p>
<ul>
<li><strong>پردازنده‌ها</strong>: از میکروکنترلرهای 8 بیتی تا پردازنده‌های قدرتمند سرور</li>
<li><strong>سیستم‌های حافظه</strong>: DDR, LPDDR, ECC, Non-Volatile Memory (NVM)</li>
<li><strong>دستگاه‌های ذخیره‌سازی</strong>: HDD, SSD, NVMe, eMMC, SD/MMC, USB storage</li>
<li><strong>واسط‌های شبکه</strong>: Ethernet, Wi-Fi, Bluetooth, 5G/4G/3G, ZigBee</li>
<li><strong>کارت‌های گرافیک</strong>: Intel, AMD, NVIDIA, ARM Mali</li>
<li><strong>دستگاه‌های ورودی</strong>: کیبورد، موس، صفحه لمسی، قلم، جویستیک</li>
<li><strong>دستگاه‌های صوتی</strong>: کارت‌های صدا، بلندگوها، میکروفون‌ها</li>
<li><strong>دستگاه‌های USB</strong>: انواع مختلف دستگاه‌های USB</li>
<li><strong>سنسورها</strong>: سنسورهای حرکتی، دما، فشار، و غیره</li>
<li><strong>تجهیزات صنعتی</strong>: PLC، سیستم‌های کنترل صنعتی</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of hardware abstraction in the Linux kernel
 * Shows how Linux provides a unified interface for different hardware types
 */</span>

<span class="hljs-comment">/* Example of block device operations structure */</span>
static const struct block_device_operations <span class="hljs-attr">example_fops</span> = {
    .<span class="hljs-attr">owner</span>          = THIS_MODULE,
    .<span class="hljs-attr">open</span>           = example_open,
    .<span class="hljs-attr">release</span>        = example_release,
    .<span class="hljs-attr">ioctl</span>          = example_ioctl,
    .<span class="hljs-attr">getgeo</span>         = example_getgeo,
};

<span class="hljs-comment">/* Example of character device operations structure */</span>
static const struct file_operations <span class="hljs-attr">example_char_fops</span> = {
    .<span class="hljs-attr">owner</span>          = THIS_MODULE,
    .<span class="hljs-attr">read</span>           = example_read,
    .<span class="hljs-attr">write</span>          = example_write,
    .<span class="hljs-attr">unlocked_ioctl</span> = example_ioctl,
    .<span class="hljs-attr">open</span>           = example_open,
    .<span class="hljs-attr">release</span>        = example_release,
};

<span class="hljs-comment">/* Example of network device operations structure */</span>
static const struct net_device_ops <span class="hljs-attr">example_netdev_ops</span> = {
    .<span class="hljs-attr">ndo_open</span>               = example_net_open,
    .<span class="hljs-attr">ndo_stop</span>               = example_net_close,
    .<span class="hljs-attr">ndo_start_xmit</span>         = example_net_xmit,
    .<span class="hljs-attr">ndo_get_stats</span>          = example_net_stats,
    .<span class="hljs-attr">ndo_set_mac_address</span>    = example_set_mac,
    .<span class="hljs-attr">ndo_validate_addr</span>      = eth_validate_addr,
};

<span class="hljs-comment">/**
 * driver_probe - Generic probe function for a device driver
 * @dev: Device to probe
 *
 * This is called when a device that potentially matches this driver is found
 */</span>
static int example_driver_probe(struct device *dev)
{
    <span class="hljs-comment">/* Identify the exact device and check compatibility */</span>

    <span class="hljs-comment">/* Allocate driver resources */</span>

    <span class="hljs-comment">/* Initialize hardware */</span>

    <span class="hljs-comment">/* Register with the appropriate subsystem */</span>

    return <span class="hljs-number">0</span>;
}
</code></pre>
<p>این نمونه کد نشان می‌دهد چگونه لینوکس از ساختارهای عملیات استاندارد برای انواع مختلف دستگاه‌ها (بلوکی، کاراکتری، شبکه) استفاده می‌کند تا یک واسط یکپارچه برای توسعه‌دهندگان درایور فراهم کند، در حالی که جزئیات پیاده‌سازی برای سخت‌افزارهای خاص را پنهان می‌کند.</p>
<h3 id="-">مقیاس‌پذیری</h3>
<p>کرنل لینوکس برای مقیاس‌پذیری عالی در طیف گسترده‌ای از سخت‌افزارها طراحی شده است. این سیستم‌عامل می‌تواند از دستگاه‌های بسیار کوچک با منابع محدود تا سیستم‌های بسیار بزرگ با صدها هسته پردازنده و ترابایت‌ها حافظه به خوبی کار کند.</p>
<p><strong>جنبه‌های مقیاس‌پذیری کرنل لینوکس:</strong></p>
<ol>
<li><p><strong>مقیاس‌پذیری عمودی (Vertical Scaling)</strong>: توانایی استفاده مؤثر از سیستم‌های با منابع بیشتر (پردازنده‌ها، حافظه، و غیره)</p>
</li>
<li><p><strong>مقیاس‌پذیری افقی (Horizontal Scaling)</strong>: توانایی کار در محیط‌های توزیع‌شده و خوشه‌ای</p>
</li>
<li><p><strong>مقیاس‌پذیری رو به پایین (Scaling Down)</strong>: توانایی کار با منابع محدود در دستگاه‌های کوچک</p>
</li>
</ol>
<p><strong>تکنیک‌های کرنل لینوکس برای مقیاس‌پذیری:</strong></p>
<ul>
<li><strong>زمانبندی پیشرفته پردازنده</strong>: الگوریتم‌های زمانبندی که می‌توانند صدها یا هزاران هسته پردازنده را مدیریت کنند</li>
<li><strong>آگاهی از NUMA</strong>: بهینه‌سازی دسترسی به حافظه در سیستم‌های با معماری دسترسی حافظه غیریکنواخت</li>
<li><strong>قفل‌های بدون انسداد</strong>: استفاده از تکنیک‌های هم‌روندی مانند RCU (Read-Copy-Update) برای کاهش تضاد در سیستم‌های چندپردازنده‌ای</li>
<li><strong>سیستم‌های فایل با قابلیت مقیاس‌پذیری بالا</strong>: ext4, XFS, Btrfs که می‌توانند با حجم‌های بسیار بزرگ داده کار کنند</li>
<li><strong>زیرسیستم شبکه مقیاس‌پذیر</strong>: پشتیبانی از پهنای باند بالا و تعداد زیاد اتصالات همزمان</li>
<li><strong>حافظه نهان هوشمند</strong>: سیستم‌های کش پیشرفته برای بهبود کارایی در محدوده‌های مختلف منابع</li>
<li><strong>پیکربندی‌پذیری</strong>: امکان حذف ویژگی‌های غیرضروری از کرنل برای کاهش اندازه و مصرف منابع</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of Linux scalability features
 * Shows RCU (Read-Copy-Update) mechanism for lockless reads
 */</span>

<span class="hljs-comment">/* Example of RCU usage for a scalable data structure */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_item</span></span> {
    <span class="hljs-keyword">int</span> key;
    <span class="hljs-keyword">int</span> value;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span> list;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span></span> rcu;
};

<span class="hljs-comment">/* Reading data without locking (scales well with many readers) */</span>
<span class="hljs-keyword">int</span> find_item_value(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span> *head, <span class="hljs-keyword">int</span> key)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_item</span></span> *item;
    <span class="hljs-keyword">int</span> value = -<span class="hljs-number">1</span>;

    <span class="hljs-comment">/* RCU read lock is very lightweight and scales to many CPUs */</span>
    rcu_read_lock();

    <span class="hljs-comment">/* Safe to read the list even if another CPU is modifying it */</span>
    list_for_each_entry_rcu(item, head, list) {
        <span class="hljs-keyword">if</span> (item-&gt;key == key) {
            value = item-&gt;value;
            <span class="hljs-keyword">break</span>;
        }
    }

    rcu_read_unlock();
    <span class="hljs-keyword">return</span> value;
}

<span class="hljs-comment">/* Updating data (less frequent operation) */</span>
void update_item(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span> *head, <span class="hljs-keyword">int</span> key, <span class="hljs-keyword">int</span> new_value)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_item</span></span> *old_item, *new_item;

    <span class="hljs-comment">/* Traditional lock for writers - but readers proceed without waiting */</span>
    spin_lock(&amp;write_lock);

    list_for_each_entry(old_item, head, list) {
        <span class="hljs-keyword">if</span> (old_item-&gt;key == key) {
            <span class="hljs-comment">/* Create new version of the item */</span>
            new_item = kmalloc(<span class="hljs-keyword">sizeof</span>(*new_item), GFP_KERNEL);
            new_item-&gt;key = key;
            new_item-&gt;value = new_value;

            <span class="hljs-comment">/* Replace old item with new one */</span>
            list_replace_rcu(&amp;old_item-&gt;list, &amp;new_item-&gt;list);

            <span class="hljs-comment">/* Schedule the old item for cleanup after all readers are done */</span>
            call_rcu(&amp;old_item-&gt;rcu, free_old_item);
            <span class="hljs-keyword">break</span>;
        }
    }

    spin_unlock(&amp;write_lock);
}

<span class="hljs-comment">/* Cleanup function called after grace period */</span>
<span class="hljs-keyword">static</span> void free_old_item(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rcu_head</span></span> *rcu)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_item</span></span> *item = container_of(rcu, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">data_item</span></span>, rcu);
    kfree(item);
}
</code></pre>
<p>این نمونه کد استفاده از مکانیزم RCU در لینوکس را نشان می‌دهد، که یکی از تکنیک‌های کلیدی برای بهبود مقیاس‌پذیری است. RCU به خوانندگان متعدد اجازه می‌دهد بدون نیاز به قفل‌گذاری سنگین، به طور همزمان به داده‌ها دسترسی داشته باشند، در حالی که نویسندگان می‌توانند تغییرات را بدون مسدود کردن خوانندگان اعمال کنند.</p>
<p><strong>نمونه‌های مقیاس‌پذیری لینوکس:</strong></p>
<ul>
<li><p><strong>ابررایانه‌ها</strong>: لینوکس روی بیش از 90% ابررایانه‌های فهرست TOP500 جهان اجرا می‌شود، که نشان‌دهنده قابلیت مقیاس‌پذیری آن در سیستم‌های بسیار بزرگ است.</p>
</li>
<li><p><strong>سرورهای بزرگ</strong>: لینوکس می‌تواند روی سرورهایی با صدها هسته پردازنده و چندین ترابایت حافظه کار کند.</p>
</li>
<li><p><strong>گوشی‌های هوشمند</strong>: همان کرنل (با تنظیمات متفاوت) در اندروید برای دستگاه‌های با منابع محدودتر استفاده می‌شود.</p>
</li>
<li><p><strong>دستگاه‌های IoT</strong>: نسخه‌های سبک لینوکس در دستگاه‌های بسیار کوچک با حافظه و توان پردازشی محدود کار می‌کنند.</p>
</li>
</ul>
<p>لینوکس با ارائه این سطح از مقیاس‌پذیری، انعطاف‌پذیری و کارایی، خود را به عنوان یک انتخاب ایده‌آل برای طیف گسترده‌ای از کاربردها تثبیت کرده است.</p>
<h2 id="-">خلاصه ویژگی‌های اصلی کرنل لینوکس</h2>
<p>کرنل لینوکس با ترکیبی از ویژگی‌های اساسی که در این بخش بررسی کردیم، یک سیستم‌عامل استثنایی و همه‌منظوره ارائه می‌دهد. چند وظیفه‌ای پیشگیرانه، پشتیبانی از چند پردازنده، قابلیت حمل به معماری‌های متنوع، سازگاری با استانداردهای POSIX، پشتیبانی گسترده از سخت‌افزارها و مقیاس‌پذیری فوق‌العاده، همگی به لینوکس اجازه می‌دهند تا در مجموعه متنوعی از محیط‌ها از کوچک‌ترین میکروکنترلرها تا بزرگترین ابررایانه‌ها با موفقیت مورد استفاده قرار گیرد.</p>
<p>علاوه بر این ویژگی‌های فنی، مدل توسعه متن‌باز لینوکس نیز یک مزیت کلیدی است که به این سیستم‌عامل امکان می‌دهد به سرعت تکامل یابد، مشکلات امنیتی را برطرف کند و با فناوری‌های جدید سازگار شود. این ترکیب از ویژگی‌های فنی قدرتمند و مدل توسعه پویا، لینوکس را به یکی از موفق‌ترین پروژه‌های نرم‌افزاری در تاریخ تبدیل کرده است.</p>
<h2 id="-">بررسی کد کرنل لینوکس</h2>
<p>کد منبع کرنل لینوکس یکی از بزرگترین و پیچیده‌ترین پروژه‌های نرم‌افزاری متن‌باز در جهان است. بررسی و تحلیل این کد می‌تواند بینش عمیقی در مورد طراحی سیستم‌عامل، تکنیک‌های برنامه‌نویسی سطح پایین و مدیریت پروژه‌های بزرگ نرم‌افزاری ارائه دهد. در این بخش، به بررسی جنبه‌های مختلف کد کرنل لینوکس می‌پردازیم.</p>
<h3 id="-c-">زبان برنامه‌نویسی C و اسمبلی در کرنل</h3>
<p>کرنل لینوکس عمدتاً به زبان C نوشته شده است، با بخش‌های کوچکی از کد اسمبلی برای وظایف خاص وابسته به معماری. انتخاب زبان C برای توسعه کرنل دلایل متعددی دارد:</p>
<ol>
<li><strong>کارایی بالا</strong>: زبان C کارایی نزدیک به اسمبلی ارائه می‌دهد اما با خوانایی و قابلیت نگهداری بهتر.</li>
<li><strong>کنترل سطح پایین</strong>: امکان دسترسی مستقیم به حافظه، دستکاری بیت‌ها و ارتباط نزدیک با سخت‌افزار.</li>
<li><strong>قابلیت حمل</strong>: کد C می‌تواند با تغییرات اندک برای معماری‌های مختلف کامپایل شود.</li>
<li><strong>استاندارد و گسترده</strong>: C یک زبان استاندارد با کامپایلرهای در دسترس برای تقریباً همه پلتفرم‌ها است.</li>
</ol>
<p>کد اسمبلی در کرنل لینوکس معمولاً در موارد زیر استفاده می‌شود:</p>
<ol>
<li><strong>کد راه‌اندازی</strong>: کد اولیه که هنگام بوت سیستم اجرا می‌شود</li>
<li><strong>روتین‌های تعویض زمینه</strong>: تغییر بین فرآیندها یا بین حالت کاربر و حالت کرنل</li>
<li><strong>دستورات خاص CPU</strong>: دسترسی به دستورات ویژه پردازنده که از طریق C امکان‌پذیر نیست</li>
<li><strong>روتین‌های بحرانی از نظر زمانی</strong>: کدهایی که نیاز به بهینه‌سازی در سطح دستورالعمل دارند</li>
</ol>
<p>مثالی از کد اسمبلی در کرنل لینوکس برای معماری x86:</p>
<pre><code class="lang-asm"><span class="hljs-comment">/*
 * کد اسمبلی برای تعویض زمینه (context switch) در معماری x86-64
 * arch/x86/kernel/entry_64.S
 */</span>
<span class="hljs-symbol">ENTRY</span>(<span class="hljs-keyword">switch_to)
</span>    <span class="hljs-comment">/* ذخیره وضعیت پردازنده فعلی */</span>
    <span class="hljs-keyword">pushq </span>  %rbp
    <span class="hljs-keyword">pushq </span>  %rbx
    <span class="hljs-keyword">pushq </span>  %<span class="hljs-built_in">r12</span>
    <span class="hljs-keyword">pushq </span>  %<span class="hljs-built_in">r13</span>
    <span class="hljs-keyword">pushq </span>  %<span class="hljs-built_in">r14</span>
    <span class="hljs-keyword">pushq </span>  %<span class="hljs-built_in">r15</span>

    <span class="hljs-comment">/* ذخیره اشاره‌گر پشته */</span>
    <span class="hljs-keyword">movq </span>   %rsp, TASK_threadsp(%rdi)

    <span class="hljs-comment">/* بارگذاری وضعیت پردازنده جدید */</span>
    <span class="hljs-keyword">movq </span>   TASK_threadsp(%rsi), %rsp

    <span class="hljs-keyword">popq </span>   %<span class="hljs-built_in">r15</span>
    <span class="hljs-keyword">popq </span>   %<span class="hljs-built_in">r14</span>
    <span class="hljs-keyword">popq </span>   %<span class="hljs-built_in">r13</span>
    <span class="hljs-keyword">popq </span>   %<span class="hljs-built_in">r12</span>
    <span class="hljs-keyword">popq </span>   %rbx
    <span class="hljs-keyword">popq </span>   %rbp

    ret
<span class="hljs-symbol">END</span>(<span class="hljs-keyword">switch_to)</span>
</code></pre>
<p>و یک مثال از کد C معمول در کرنل:</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثالی از کد C در کرنل لینوکس - تابع ساده مدیریت حافظه
 * mm/page_alloc.c
 */</span>
<span class="hljs-function"><span class="hljs-keyword">struct</span> page *<span class="hljs-title">alloc_pages</span><span class="hljs-params">(<span class="hljs-keyword">gfp_t</span> gfp_mask, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> order)</span>
</span>{
    <span class="hljs-keyword">struct</span> page *page;

    <span class="hljs-comment">/* درخواست یک صفحه با ترتیب مشخص */</span>
    page = alloc_pages_current(gfp_mask, order);

    <span class="hljs-comment">/* بررسی موفقیت تخصیص */</span>
    <span class="hljs-keyword">if</span> (unlikely(!page))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

    <span class="hljs-comment">/* پاک کردن صفحه در صورت نیاز */</span>
    <span class="hljs-keyword">if</span> (unlikely(gfp_mask &amp; __GFP_ZERO))
        clear_highpage(page);

    <span class="hljs-keyword">return</span> page;
}
</code></pre>
<p>نکته مهم در مورد کد C کرنل لینوکس این است که از تمام ویژگی‌های استاندارد C استفاده نمی‌کند. برخی محدودیت‌ها عبارتند از:</p>
<ol>
<li>عدم استفاده از کتابخانه استاندارد C (libc)</li>
<li>عدم استفاده از حافظه پویا استاندارد (malloc/free)</li>
<li>حساسیت بالا به سرریز بافر و خطاهای مشابه</li>
<li>استفاده از توابع و ماکروهای خاص کرنل به جای توابع استاندارد</li>
</ol>
<h3 id="-">ساختار درختی کد منبع</h3>
<p>کد منبع کرنل لینوکس به صورت منطقی در یک ساختار درختی با دایرکتوری‌های متعدد سازماندهی شده است. این سازماندهی به مدیریت بهتر کد و تفکیک وظایف کمک می‌کند. ساختار اصلی به شرح زیر است:</p>
<pre><code>/
├── arch/          <span class="hljs-comment"># کد وابسته به معماری (x86, arm, powerpc و غیره)</span>
├── block/         <span class="hljs-comment"># زیرسیستم بلوکی برای دسترسی به دستگاه‌های ذخیره‌سازی</span>
├── certs/         <span class="hljs-comment"># گواهی‌ها برای امضای ماژول‌ها و امنیت</span>
├── crypto/        <span class="hljs-comment"># الگوریتم‌های رمزنگاری</span>
├── Documentation/ <span class="hljs-comment"># مستندات</span>
├── drivers/       <span class="hljs-comment"># درایورهای دستگاه (بزرگترین بخش کرنل)</span>
├── fs/            <span class="hljs-comment"># سیستم‌های فایل</span>
├── <span class="hljs-keyword">include</span>/       <span class="hljs-comment"># فایل‌های هدر</span>
├── init/          <span class="hljs-comment"># کد راه‌اندازی کرنل</span>
├── ipc/           <span class="hljs-comment"># مکانیزم‌های ارتباط بین فرآیندی</span>
├── kernel/        <span class="hljs-comment"># هسته اصلی کرنل (زمانبندی، فرآیندها و غیره)</span>
├── <span class="hljs-class"><span class="hljs-keyword">lib</span>/           <span class="hljs-comment"># کتابخانه‌های عمومی و توابع کمکی</span></span>
├── mm/            <span class="hljs-comment"># زیرسیستم مدیریت حافظه</span>
├── net/           <span class="hljs-comment"># زیرسیستم شبکه</span>
├── samples/       <span class="hljs-comment"># نمونه کدها</span>
├── scripts/       <span class="hljs-comment"># اسکریپت‌های ساخت و تحلیل</span>
├── security/      <span class="hljs-comment"># چارچوب‌های امنیتی (SELinux, AppArmor و غیره)</span>
├── sound/         <span class="hljs-comment"># پشتیبانی از صدا (ALSA)</span>
├── tools/         <span class="hljs-comment"># ابزارهای مختلف</span>
└── virt/          <span class="hljs-comment"># مجازی‌سازی</span>
</code></pre><p>برخی از مهم‌ترین دایرکتوری‌ها را بررسی می‌کنیم:</p>
<p><strong>arch/</strong>: این دایرکتوری شامل کد خاص معماری‌های مختلف است. هر معماری دایرکتوری خود را دارد، مانند <code>arch/x86/</code> برای پردازنده‌های Intel و AMD و <code>arch/arm/</code> برای پردازنده‌های ARM. این بخش شامل کد راه‌اندازی، تعریف وقفه‌ها، مدیریت حافظه خاص معماری و تنظیمات سخت‌افزاری است.</p>
<p><strong>kernel/</strong>: این دایرکتوری شامل کد اصلی کرنل است که مستقل از معماری است. اینجا جایی است که زمانبند، مدیریت فرآیندها، سیگنال‌ها، مدیریت زمان و سایر عملکردهای اساسی کرنل پیاده‌سازی می‌شوند.</p>
<p><strong>mm/</strong>: این دایرکتوری شامل زیرسیستم مدیریت حافظه است. این شامل مدیریت صفحات، حافظه مجازی، تخصیص حافظه، صفحه گردانی و سایر جنبه‌های مدیریت حافظه می‌شود.</p>
<p><strong>fs/</strong>: این دایرکتوری شامل پیاده‌سازی سیستم‌های فایل مختلف (ext4, XFS, Btrfs و غیره) و سیستم فایل مجازی (VFS) است که یک لایه انتزاعی برای همه سیستم‌های فایل فراهم می‌کند.</p>
<p><strong>drivers/</strong>: این بزرگترین بخش کرنل است و شامل درایورها برای انواع مختلف سخت‌افزارها مانند کارت‌های گرافیک، کارت‌های شبکه، کنترلرهای USB، و غیره است. این بخش به زیرشاخه‌های متعددی تقسیم می‌شود، هر کدام مربوط به نوع خاصی از دستگاه.</p>
<p><strong>net/</strong>: این دایرکتوری شامل پیاده‌سازی پروتکل‌های شبکه مانند TCP/IP، سوکت‌ها، فیلترینگ بسته و سایر جنبه‌های شبکه است.</p>
<p><strong>include/</strong>: این دایرکتوری شامل فایل‌های هدر مورد نیاز برای کامپایل کرنل است. زیرشاخه‌های مهم آن عبارتند از:</p>
<ul>
<li><code>include/linux/</code>: هدرهای عمومی کرنل</li>
<li><code>include/asm-generic/</code>: هدرهای مشترک برای تمام معماری‌ها</li>
<li><code>include/uapi/</code>: واسط کاربر-کرنل برای فراخوانی‌های سیستمی</li>
</ul>
<h3 id="-">استانداردهای کدنویسی</h3>
<p>کرنل لینوکس یک سند استاندارد کدنویسی با عنوان &quot;Linux kernel coding style&quot; دارد که در <code>Documentation/process/coding-style.rst</code> یافت می‌شود. این استانداردها اطمینان می‌دهند که کد توسط همه توسعه‌دهندگان بتواند به راحتی خوانده و درک شود.</p>
<p>برخی از قوانین کلیدی عبارتند از:</p>
<ol>
<li><p><strong>عرض تب</strong>: از تب 8 کاراکتری استفاده می‌شود، نه فاصله.</p>
</li>
<li><p><strong>بلاک‌ها</strong>: آکولادها به سبک K&amp;R قرار می‌گیرند، یعنی آکولاد باز در همان خط دستور و آکولاد بسته در یک خط جدید:</p>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-keyword">if</span> (<span class="hljs-keyword">condition</span>) {
    <span class="hljs-comment">/* کد */</span>
} <span class="hljs-keyword">else</span> {
    <span class="hljs-comment">/* کد بیشتر */</span>
}
</code></pre>
<ol>
<li><p><strong>حداکثر طول خط</strong>: خطوط نباید بیش از 80 کاراکتر باشند (با استثناهای خاص).</p>
</li>
<li><p><strong>نامگذاری</strong>: توابع و متغیرها با حروف کوچک نامگذاری می‌شوند، با زیرخط به عنوان جداکننده. ماکروها و enum ها با حروف بزرگ نوشته می‌شوند:</p>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">kernel_function_name</span><span class="hljs-params">(<span class="hljs-keyword">int</span> parameter_name)</span></span>;
<span class="hljs-meta">#<span class="hljs-meta-keyword">define</span> KERNEL_MACRO_NAME 1</span>
</code></pre>
<ol>
<li><p><strong>توضیحات</strong>: توضیحات به سبک C <code>/* */</code> ترجیح داده می‌شوند، هرچند توضیحات خطی <code>//</code> نیز مجاز هستند.</p>
</li>
<li><p><strong>تورفتگی شرطی‌ها</strong>: شرطی‌های متداخل با 8 کاراکتر تورفتگی می‌گیرند:</p>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-keyword">if</span> <span class="hljs-comment">(condition1)</span> {
    <span class="hljs-keyword">if</span> <span class="hljs-comment">(condition2)</span> {
        <span class="hljs-comment">/* کد */</span>
    }
}
</code></pre>
<ol>
<li><p><strong>فضای خالی</strong>: استفاده از فضای خالی برای افزایش خوانایی، مثلاً بعد از کلمات کلیدی و قبل و بعد از عملگرها.</p>
</li>
<li><p><strong>مستندات کد</strong>: استفاده از سیستم kernel-doc برای توضیح توابع، ساختارها و ماکروها.</p>
</li>
</ol>
<p>مثالی از یک تابع با سبک استاندارد کرنل لینوکس:</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * get_device_by_id - پیدا کردن یک دستگاه با شناسه مشخص
 * @id: شناسه دستگاه برای جستجو
 *
 * این تابع جستجوی یک دستگاه با شناسه مشخص را انجام می‌دهد.
 * در صورت موفقیت، یک اشاره‌گر به ساختار دستگاه یا NULL در صورت عدم وجود
 * دستگاه برمی‌گرداند.
 *
 * بازگشت: اشاره‌گر به دستگاه یا NULL در صورت عدم وجود
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> device *get_device_by_id(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> <span class="hljs-keyword">id</span>)
{
    <span class="hljs-keyword">struct</span> device *dev;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags;

    <span class="hljs-keyword">if</span> (unlikely(<span class="hljs-keyword">id</span> == <span class="hljs-number">0</span>))
        <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;

    spin_lock_irqsave(&amp;device_lock, flags);

    list_for_each_entry(dev, &amp;device_list, list) {
        <span class="hljs-keyword">if</span> (dev-&gt;<span class="hljs-keyword">id</span> == <span class="hljs-keyword">id</span>) {
            <span class="hljs-comment">/* دستگاه یافت شد */</span>
            get_device(dev);
            spin_unlock_irqrestore(&amp;device_lock, flags);
            <span class="hljs-keyword">return</span> dev;
        }
    }

    spin_unlock_irqrestore(&amp;device_lock, flags);
    <span class="hljs-keyword">return</span> <span class="hljs-literal">NULL</span>;
}
</code></pre>
<h3 id="-">تحلیل بخش‌های کلیدی کد کرنل</h3>
<p>در این بخش، به بررسی برخی از بخش‌های کلیدی کد کرنل لینوکس می‌پردازیم تا درک بهتری از نحوه پیاده‌سازی عملکردهای مهم پیدا کنیم.</p>
<h4 id="1-system-call-">1. فراخوانی سیستمی (System Call)</h4>
<p>فراخوانی‌های سیستمی واسط بین فضای کاربر و کرنل هستند. بیایید ببینیم چگونه یک فراخوانی سیستمی در کرنل لینوکس تعریف می‌شود:</p>
<pre><code class="lang-c"><span class="hljs-comment">/*
 * فراخوانی سیستمی write() - نوشتن داده به یک فایل
 * kernel/sys.c
 */</span>
SYSCALL_DEFINE3(write, unsigned int, fd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, buf, size_t, <span class="hljs-keyword">count</span>)
{
    struct fd f = fdget_pos(fd);
    ssize_t <span class="hljs-keyword">ret</span> = -EBADF;

    <span class="hljs-keyword">if</span> (f.<span class="hljs-keyword">file</span>) {
        loff_t pos, *ppos = file_ppos(f.<span class="hljs-keyword">file</span>);
        <span class="hljs-keyword">if</span> (ppos) {
            pos = *ppos;
            ppos = &amp;pos;
        }
        <span class="hljs-keyword">ret</span> = vfs_write(f.<span class="hljs-keyword">file</span>, buf, <span class="hljs-keyword">count</span>, ppos);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span> &gt;= 0 &amp;&amp; ppos)
            f.<span class="hljs-keyword">file</span>-&gt;f_pos = pos;
        fdput_pos(f);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;
}
</code></pre>
<p>در این مثال:</p>
<ul>
<li><code>SYSCALL_DEFINE3</code> یک ماکرو است که یک فراخوانی سیستمی با 3 پارامتر تعریف می‌کند.</li>
<li><code>__user</code> یک صفات‌گذار است که نشان می‌دهد اشاره‌گر از فضای کاربر آمده است و باید با دقت بررسی شود.</li>
<li>تابع ابتدا فایل را با استفاده از توصیف‌گر فایل پیدا می‌کند، سپس عملیات نوشتن را انجام می‌دهد و در نهایت نتیجه را برمی‌گرداند.</li>
</ul>
<h4 id="2-">2. زمانبندی فرآیندها</h4>
<p>زمانبند کرنل لینوکس یکی از پیچیده‌ترین بخش‌های آن است. بخشی از کد زمانبند CFS (Completely Fair Scheduler) را بررسی می‌کنیم:</p>
<pre><code class="lang-c"><span class="hljs-comment">/*
 * زمانبند CFS - انتخاب بعدی فرآیند برای اجرا
 * kernel/sched/fair.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *pick_next_task_fair(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *prev)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span></span> *cfs_rq = &amp;rq-&gt;cfs;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span></span> *se;

    <span class="hljs-keyword">if</span> (!cfs_rq-&gt;nr_running)
        <span class="hljs-keyword">return</span> NULL;

    <span class="hljs-comment">/* انتخاب فرآیند با بیشترین اولویت */</span>
    se = pick_next_entity(cfs_rq, NULL);

    <span class="hljs-comment">/* تبدیل entity به task_struct */</span>
    set_next_entity(cfs_rq, se);

    <span class="hljs-keyword">return</span> task_of(se);
}

<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span></span> *pick_next_entity(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span></span> *cfs_rq, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span></span> *curr)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span></span> *left = rb_entry(cfs_rq-&gt;rb_leftmost, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span></span>, run_node);

    <span class="hljs-comment">/* همیشه چپ‌ترین نود در درخت را انتخاب کن (کمترین vruntime) */</span>
    <span class="hljs-keyword">if</span> (!curr)
        <span class="hljs-keyword">return</span> left;

    <span class="hljs-comment">/* مقایسه فرآیند فعلی با چپ‌ترین نود */</span>
    <span class="hljs-keyword">if</span> (entity_before(left, curr))
        <span class="hljs-keyword">return</span> left;

    <span class="hljs-keyword">return</span> curr;
}
</code></pre>
<p>در این نمونه:</p>
<ul>
<li>زمانبند CFS از یک درخت سرخ-سیاه برای نگهداری فرآیندهای قابل اجرا استفاده می‌کند.</li>
<li>فرآیندها بر اساس &quot;زمان اجرای مجازی&quot; (<code>vruntime</code>) مرتب می‌شوند.</li>
<li><code>pick_next_task_fair</code> فرآیند با کمترین <code>vruntime</code> را انتخاب می‌کند (چپ‌ترین نود در درخت).</li>
</ul>
<h4 id="3-">3. مدیریت حافظه</h4>
<p>یکی از عملکردهای اصلی کرنل، تخصیص و مدیریت حافظه است. یک مثال از تخصیص صفحه حافظه:</p>
<pre><code class="lang-c"><span class="hljs-comment">/*
 * تخصیص یک صفحه حافظه
 * mm/page_alloc.c
 */</span>
struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int <span class="hljs-keyword">order,
</span>                int <span class="hljs-keyword">preferred_nid, </span>nodemask_t *nodemask)
{
    struct page *page<span class="hljs-comment">;</span>
    unsigned int cpu<span class="hljs-comment">;</span>
    struct alloc_context ac = {}<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* تنظیم پارامترهای تخصیص */</span>
    gfp_mask &amp;= gfp_allowed_mask<span class="hljs-comment">;</span>
    ac.high_zoneidx = gfp_zone(gfp_mask)<span class="hljs-comment">;</span>
    ac.zonelist = node_zonelist(<span class="hljs-keyword">preferred_nid, </span>gfp_mask)<span class="hljs-comment">;</span>
    ac.nodemask = nodemask<span class="hljs-comment">;</span>
    ac.migratetype = gfpflags_to_migratetype(gfp_mask)<span class="hljs-comment">;</span>

    if (unlikely(!zonelist_zone_count(ac.zonelist))) {
        warn_alloc(gfp_mask, nodemask, <span class="hljs-string">"no zones available"</span>)<span class="hljs-comment">;</span>
        return NULL<span class="hljs-comment">;</span>
    }

    <span class="hljs-comment">/* آیا می‌توانیم از کش CPU استفاده کنیم؟ */</span>
    if (!(gfp_mask &amp; __GFP_THISNODE) &amp;&amp; !ac.nodemask) {
        cpu = get_cpu()<span class="hljs-comment">;</span>
        if (cpu_has_pgoff(cpu) &amp;&amp; <span class="hljs-keyword">order </span>== <span class="hljs-number">0</span>)
            page = cpu_pgoff_alloc(gfp_mask, &amp;ac)<span class="hljs-comment">;</span>
        put_cpu()<span class="hljs-comment">;</span>
        if (page)
            return page<span class="hljs-comment">;</span>
    }

    <span class="hljs-comment">/* مسیر اصلی تخصیص */</span>
    page = get_page_from_freelist(gfp_mask, <span class="hljs-keyword">order, </span>&amp;ac)<span class="hljs-comment">;</span>
    if (likely(page))
        return page<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* مسیر آهسته (کمبود حافظه) */</span>
    return __alloc_pages_slowpath(gfp_mask, <span class="hljs-keyword">order, </span>&amp;ac)<span class="hljs-comment">;</span>
}
</code></pre>
<p>در این نمونه:</p>
<ul>
<li>تابع <code>__alloc_pages_nodemask</code> برای تخصیص یک یا چند صفحه حافظه متوالی استفاده می‌شود.</li>
<li>پارامتر <code>order</code> تعداد صفحات متوالی را مشخص می‌کند (2^order صفحه).</li>
<li>ابتدا سعی می‌کند از کش CPU استفاده کند، سپس از لیست صفحات آزاد، و در نهایت اگر حافظه کافی نباشد، به مسیر آهسته می‌رود که شامل آزادسازی حافظه کش، صفحه گردانی و غیره است.</li>
</ul>
<h4 id="4-vfs-">4. سیستم فایل مجازی (VFS)</h4>
<p>سیستم فایل مجازی یک لایه انتزاعی است که تمام سیستم‌های فایل را یکپارچه می‌کند. مثالی از عملیات خواندن فایل:</p>
<pre><code class="lang-c"><span class="hljs-comment">/*
 * خواندن از یک فایل
 * fs/read_write.c
 */</span>
ssize_t vfs_read(struct <span class="hljs-keyword">file</span> *<span class="hljs-keyword">file</span>, <span class="hljs-keyword">char</span> __user *buf, size_t <span class="hljs-keyword">count</span>, loff_t *pos)
{
    ssize_t <span class="hljs-keyword">ret</span>;

    <span class="hljs-keyword">if</span> (!(<span class="hljs-keyword">file</span>-&gt;f_mode &amp; FMODE_READ))
        <span class="hljs-keyword">return</span> -EBADF;
    <span class="hljs-keyword">if</span> (unlikely(!<span class="hljs-keyword">file</span>-&gt;f_op-&gt;<span class="hljs-keyword">read</span> &amp;&amp; !<span class="hljs-keyword">file</span>-&gt;f_op-&gt;read_iter))
        <span class="hljs-keyword">return</span> -EINVAL;

    <span class="hljs-comment">/* آیا محدودیت اندازه وجود دارد؟ */</span>
    <span class="hljs-keyword">if</span> (unlikely(<span class="hljs-keyword">count</span> &gt; MAX_RW_COUNT))
        <span class="hljs-keyword">count</span> = MAX_RW_COUNT;

    <span class="hljs-comment">/* بررسی مجوزها */</span>
    <span class="hljs-keyword">if</span> (unlikely(!access_ok(buf, <span class="hljs-keyword">count</span>)))
        <span class="hljs-keyword">return</span> -EFAULT;

    <span class="hljs-comment">/* استفاده از رابط مدرن در صورت وجود */</span>
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">file</span>-&gt;f_op-&gt;read_iter) {
        struct kiocb kiocb;
        struct iov_iter iter;

        init_sync_kiocb(&amp;kiocb, <span class="hljs-keyword">file</span>);
        kiocb.ki_pos = *pos;
        iov_iter_init(&amp;iter, <span class="hljs-keyword">READ</span>, &amp;buf, <span class="hljs-keyword">count</span>, <span class="hljs-keyword">count</span>);

        <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">file</span>-&gt;f_op-&gt;read_iter(&amp;kiocb, &amp;iter);
<span class="hljs-comment">        *pos = kiocb.ki_pos;</span>
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">/* استفاده از رابط قدیمی */</span>
        <span class="hljs-keyword">ret</span> = <span class="hljs-keyword">file</span>-&gt;f_op-&gt;<span class="hljs-keyword">read</span>(<span class="hljs-keyword">file</span>, buf, <span class="hljs-keyword">count</span>, pos);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;
}
</code></pre>
<p>در این نمونه:</p>
<ul>
<li><code>vfs_read</code> یک تابع عمومی برای خواندن از هر نوع فایل است، صرف نظر از سیستم فایل زیربنایی.</li>
<li>ابتدا بررسی‌های امنیتی انجام می‌شود (مجوزها، محدودیت‌های اندازه، و غیره).</li>
<li>سپس فراخوانی به تابع خواندن خاص سیستم فایل (<code>read_iter</code> یا <code>read</code>) منتقل می‌شود.</li>
<li>این الگوی انتزاع اجازه می‌دهد کرنل با انواع مختلف سیستم‌های فایل به طور یکسان کار کند.</li>
</ul>
<h3 id="-">بررسی نمونه کدهای کرنل</h3>
<p>در این بخش، به بررسی چند نمونه کد بیشتر از کرنل لینوکس می‌پردازیم تا تکنیک‌های برنامه‌نویسی استفاده شده در آن را بهتر درک کنیم.</p>
<h4 id="1-">1. مدیریت وقفه‌ها</h4>
<p>وقفه‌ها یکی از مکانیزم‌های اساسی برای تعامل با سخت‌افزار هستند. بیایید ببینیم چگونه یک درایور، یک وقفه را ثبت می‌کند:</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * ثبت یک وقفه در کرنل لینوکس
 * drivers/example/example_driver.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> example_probe(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_dev</span></span> *pdev, <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_device_id</span></span> *id)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_device</span></span> *dev;
    <span class="hljs-keyword">int</span> ret, irq;

    <span class="hljs-comment">/* تخصیص و مقداردهی اولیه ساختار دستگاه */</span>
    dev = kzalloc(<span class="hljs-keyword">sizeof</span>(*dev), GFP_KERNEL);
    <span class="hljs-keyword">if</span> (!dev)
        <span class="hljs-keyword">return</span> -ENOMEM;

    <span class="hljs-comment">/* فعال‌سازی دستگاه PCI */</span>
    ret = pci_enable_device(pdev);
    <span class="hljs-keyword">if</span> (ret) {
        dev_err(&amp;pdev-&gt;dev, <span class="hljs-string">"Failed to enable PCI device\n"</span>);
        goto err_free_dev;
    }

    <span class="hljs-comment">/* درخواست منابع I/O */</span>
    ret = pci_request_regions(pdev, DRIVER_NAME);
    <span class="hljs-keyword">if</span> (ret) {
        dev_err(&amp;pdev-&gt;dev, <span class="hljs-string">"Failed to request regions\n"</span>);
        goto err_disable_device;
    }

    <span class="hljs-comment">/* نگاشت فضای آدرس دستگاه */</span>
    dev-&gt;regs = pci_iomap(pdev, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">if</span> (!dev-&gt;regs) {
        dev_err(&amp;pdev-&gt;dev, <span class="hljs-string">"Failed to map registers\n"</span>);
        ret = -ENOMEM;
        goto err_release_regions;
    }

    <span class="hljs-comment">/* دریافت شماره وقفه */</span>
    irq = pdev-&gt;irq;
    <span class="hljs-keyword">if</span> (irq &lt; <span class="hljs-number">0</span>) {
        dev_err(&amp;pdev-&gt;dev, <span class="hljs-string">"No IRQ assigned\n"</span>);
        ret = -ENODEV;
        goto err_unmap;
    }

    <span class="hljs-comment">/* ثبت روتین وقفه */</span>
    ret = request_irq(irq, example_interrupt, IRQF_SHARED,
                     DRIVER_NAME, dev);
    <span class="hljs-keyword">if</span> (ret) {
        dev_err(&amp;pdev-&gt;dev, <span class="hljs-string">"Failed to request IRQ %d\n"</span>, irq);
        goto err_unmap;
    }

    <span class="hljs-comment">/* ذخیره اطلاعات دستگاه */</span>
    pci_set_drvdata(pdev, dev);
    dev-&gt;pdev = pdev;
    dev-&gt;irq = irq;

    <span class="hljs-comment">/* فعال‌سازی وقفه‌ها در دستگاه */</span>
    writel(INTR_ENABLE_ALL, dev-&gt;regs + REG_INTR_ENABLE);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

err_unmap:
    pci_iounmap(pdev, dev-&gt;regs);
err_release_regions:
    pci_release_regions(pdev);
err_disable_device:
    pci_disable_device(pdev);
err_free_dev:
    kfree(dev);
    <span class="hljs-keyword">return</span> ret;
}

<span class="hljs-comment">/* روتین مدیریت وقفه */</span>
<span class="hljs-keyword">static</span> irqreturn_t example_interrupt(<span class="hljs-keyword">int</span> irq, void *dev_id)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_device</span></span> *dev = dev_id;
    <span class="hljs-keyword">u32</span> status;

    <span class="hljs-comment">/* خواندن وضعیت وقفه */</span>
    status = readl(dev-&gt;regs + REG_INTR_STATUS);

    <span class="hljs-comment">/* اگر وقفه مربوط به این دستگاه نیست */</span>
    <span class="hljs-keyword">if</span> (!status)
        <span class="hljs-keyword">return</span> IRQ_NONE;

    <span class="hljs-comment">/* مدیریت وقفه‌های مختلف */</span>
    <span class="hljs-keyword">if</span> (status &amp; INTR_DATA_READY)
        example_process_data(dev);

    <span class="hljs-keyword">if</span> (status &amp; INTR_ERROR)
        example_handle_error(dev);

    <span class="hljs-comment">/* پاک کردن وقفه */</span>
    writel(status, dev-&gt;regs + REG_INTR_CLEAR);

    <span class="hljs-keyword">return</span> IRQ_HANDLED;
}

## مدیریت حافظه در کرنل لینوکس

مدیریت حافظه یکی از مهم‌ترین و پیچیده‌ترین وظایف هر سیستم‌عامل است. کرنل لینوکس سیستم مدیریت حافظه قدرتمندی دارد که به آن امکان می‌دهد منابع سخت‌افزاری را به طور کارآمد مدیریت کند و میان برنامه‌های مختلف تقسیم نماید. در این بخش، جنبه‌های مختلف مدیریت حافظه در کرنل لینوکس را بررسی می‌کنیم.

### حافظه فیزیکی و حافظه مجازی

سیستم مدیریت حافظه لینوکس بر پایه دو مفهوم اساسی حافظه فیزیکی و حافظه مجازی بنا شده است:

**حافظه فیزیکی (Physical Memory):**
حافظه فیزیکی به RAM واقعی موجود در سیستم اشاره دارد. این حافظه محدود است و باید به دقت میان فرآیندهای مختلف تقسیم شود. لینوکس حافظه فیزیکی را به صفحات (pages) تقسیم می‌کند که معمولاً اندازه هر صفحه <span class="hljs-number">4</span> کیلوبایت است (هرچند در برخی معماری‌ها می‌تواند متفاوت باشد، مثلاً <span class="hljs-number">8</span> کیلوبایت، <span class="hljs-number">16</span> کیلوبایت یا حتی <span class="hljs-number">2</span> مگابایت در برخی سیستم‌ها).

**حافظه مجازی (Virtual Memory):**
حافظه مجازی یک انتزاع است که به هر فرآیند اجازه می‌دهد فضای آدرس خود را داشته باشد، به گونه‌ای که گویی کل حافظه سیستم را در اختیار دارد. این سیستم چندین مزیت دارد:

<span class="hljs-number">1</span>. **جداسازی**: هر فرآیند نمی‌تواند به حافظه فرآیندهای دیگر دسترسی پیدا کند
<span class="hljs-number">2</span>. **حفاظت**: کرنل می‌تواند دسترسی به مناطق مختلف حافظه را کنترل کند
<span class="hljs-number">3</span>. **فضای آدرس بزرگتر**: فرآیندها می‌توانند فضای آدرسی بزرگتر از حافظه فیزیکی موجود داشته باشند
<span class="hljs-number">4</span>. **حافظه اشتراکی**: امکان اشتراک‌گذاری مناطق حافظه میان فرآیندها فراهم می‌شود

کرنل لینوکس از واحد مدیریت حافظه (MMU) سخت‌افزاری برای ترجمه آدرس‌های مجازی به فیزیکی استفاده می‌کند. هر فرآیند جدول صفحات (page table) خود را دارد که نگاشت بین آدرس‌های مجازی و فیزیکی را نگهداری می‌کند.

```c
<span class="hljs-comment">/**
 * Example of page allocation in Linux kernel
 * mm/page_alloc.c
 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span></span> *alloc_pages(gfp_t gfp_mask, unsigned <span class="hljs-keyword">int</span> order)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span></span> *page;

    <span class="hljs-comment">/* Try to allocate pages from the current node */</span>
    page = alloc_pages_current(gfp_mask, order);

    <span class="hljs-comment">/* Check if allocation was successful */</span>
    <span class="hljs-keyword">if</span> (unlikely(!page))
        <span class="hljs-keyword">return</span> NULL;

    <span class="hljs-comment">/* If zero flag is set, clear the pages */</span>
    <span class="hljs-keyword">if</span> (unlikely(gfp_mask &amp; __GFP_ZERO))
        clear_highpage(page);

    <span class="hljs-keyword">return</span> page;
}
</code></pre>
<h3 id="-">صفحه‌بندی و جدول صفحات</h3>
<p>صفحه‌بندی (Paging) مکانیزم اصلی مدیریت حافظه مجازی در لینوکس است. در این سیستم، فضای آدرس مجازی و فیزیکی به صفحات با اندازه ثابت تقسیم می‌شوند. جدول صفحات، نگاشت بین صفحات مجازی و فیزیکی را نگهداری می‌کند.</p>
<p>در معماری‌های مدرن، جدول صفحات چند سطحی است تا بتواند فضای آدرس بزرگ را به طور کارآمد مدیریت کند. برای مثال، در معماری x86-64، لینوکس از ساختار 4 سطحی استفاده می‌کند:</p>
<ol>
<li><strong>PGD (Page Global Directory)</strong></li>
<li><strong>PUD (Page Upper Directory)</strong></li>
<li><strong>PMD (Page Middle Directory)</strong></li>
<li><strong>PTE (Page Table Entry)</strong></li>
</ol>
<p>هر سطح از جدول، بخشی از آدرس مجازی را برای مسیریابی به سطح بعدی استفاده می‌کند. در نهایت، PTE به صفحه فیزیکی واقعی اشاره می‌کند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Function to translate a virtual address to physical
 * (simplified version)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">translate_address</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> vaddr, <span class="hljs-keyword">pgd_t</span> *pgd)</span>
</span>{
    <span class="hljs-keyword">pgd_t</span> *pgd_entry;
    <span class="hljs-keyword">pud_t</span> *pud_entry;
    <span class="hljs-keyword">pmd_t</span> *pmd_entry;
    <span class="hljs-keyword">pte_t</span> *pte_entry;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> paddr;

    <span class="hljs-comment">/* Get the PGD entry */</span>
    pgd_entry = pgd + pgd_index(vaddr);
    <span class="hljs-keyword">if</span> (pgd_none(*pgd_entry))
        <span class="hljs-keyword">return</span> -EFAULT;

    <span class="hljs-comment">/* Get the PUD entry */</span>
    pud_entry = pud_offset(pgd_entry, vaddr);
    <span class="hljs-keyword">if</span> (pud_none(*pud_entry))
        <span class="hljs-keyword">return</span> -EFAULT;

    <span class="hljs-comment">/* Get the PMD entry */</span>
    pmd_entry = pmd_offset(pud_entry, vaddr);
    <span class="hljs-keyword">if</span> (pmd_none(*pmd_entry))
        <span class="hljs-keyword">return</span> -EFAULT;

    <span class="hljs-comment">/* Get the PTE entry */</span>
    pte_entry = pte_offset_kernel(pmd_entry, vaddr);
    <span class="hljs-keyword">if</span> (!pte_present(*pte_entry))
        <span class="hljs-keyword">return</span> -EFAULT;

    <span class="hljs-comment">/* Compute the physical address */</span>
    paddr = (pte_val(*pte_entry) &amp; PAGE_MASK) | (vaddr &amp; ~PAGE_MASK);

    <span class="hljs-keyword">return</span> paddr;
}
</code></pre>
<h3 id="-">فضای آدرس پروسه</h3>
<p>هر فرآیند در لینوکس فضای آدرس مجازی خود را دارد که از طریق ساختار <code>mm_struct</code> مدیریت می‌شود. این ساختار شامل اطلاعاتی درباره تمام مناطق حافظه متعلق به فرآیند است، از جمله:</p>
<ul>
<li>کد اجرایی (text segment)</li>
<li>داده‌های تغییرناپذیر (read-only data)</li>
<li>داده‌های تغییرپذیر (data segment)</li>
<li>پشته (stack)</li>
<li>فضای آزاد (heap)</li>
<li>کتابخانه‌های به اشتراک گذاشته شده</li>
<li>مناطق نگاشت شده با <code>mmap()</code></li>
</ul>
<p>هر منطقه حافظه توسط یک ساختار <code>vm_area_struct</code> توصیف می‌شود که اطلاعاتی مانند آدرس شروع و پایان، مجوزهای دسترسی و پرچم‌های دیگر را نگهداری می‌کند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Creating a new memory mapping for a process
 * mm/mmap.c
 */</span>
<span class="hljs-function"><span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">do_mmap</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> file *file, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> addr,
                     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> len, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> prot,
                     <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> pgoff)</span>
</span>{
    <span class="hljs-keyword">struct</span> mm_struct *mm = current-&gt;mm;
    <span class="hljs-keyword">struct</span> vm_area_struct *vma;
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> ret;

    <span class="hljs-comment">/* Various checks and validations */</span>
    <span class="hljs-keyword">if</span> (len &gt; TASK_SIZE)
        <span class="hljs-keyword">return</span> -ENOMEM;

    <span class="hljs-comment">/* Round the address and length to page boundaries */</span>
    addr = PAGE_ALIGN(addr);
    len = PAGE_ALIGN(len);

    <span class="hljs-comment">/* Find a suitable region in the address space */</span>
    addr = get_unmapped_area(file, addr, len, pgoff, flags);
    <span class="hljs-keyword">if</span> (IS_ERR_VALUE(addr))
        <span class="hljs-keyword">return</span> addr;

    <span class="hljs-comment">/* Create a new VMA */</span>
    vma = vm_area_alloc(mm);
    <span class="hljs-keyword">if</span> (!vma)
        <span class="hljs-keyword">return</span> -ENOMEM;

    <span class="hljs-comment">/* Set up the VMA */</span>
    vma-&gt;vm_start = addr;
    vma-&gt;vm_end = addr + len;
    vma-&gt;vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags);
    vma-&gt;vm_page_prot = vm_get_page_prot(vma-&gt;vm_flags);
    vma-&gt;vm_pgoff = pgoff;

    <span class="hljs-comment">/* Link the VMA to the file if needed */</span>
    <span class="hljs-keyword">if</span> (file) {
        vma-&gt;vm_file = get_file(file);
        <span class="hljs-keyword">if</span> (flags &amp; MAP_SHARED)
            vma-&gt;vm_flags |= VM_SHARED;
    }

    <span class="hljs-comment">/* Insert the VMA into the process's memory regions */</span>
    ret = insert_vm_struct(mm, vma);
    <span class="hljs-keyword">if</span> (ret)
        <span class="hljs-keyword">return</span> ret;

    <span class="hljs-comment">/* Update the process's memory usage statistics */</span>
    mm-&gt;total_vm += len &gt;&gt; PAGE_SHIFT;

    <span class="hljs-keyword">return</span> addr;
}
</code></pre>
<h3 id="-">مدیریت حافظه نهان</h3>
<p>حافظه نهان (Cache) در سیستم‌های کامپیوتری برای افزایش کارایی استفاده می‌شود. کرنل لینوکس چندین مکانیزم کش برای بهینه‌سازی دسترسی به حافظه دارد:</p>
<ol>
<li><p><strong>Slab Allocator</strong>: یک لایه روی تخصیص صفحه که امکان تخصیص و آزادسازی کارآمد اشیاء کرنل با اندازه‌های متعارف را فراهم می‌کند.</p>
</li>
<li><p><strong>Buffer Cache</strong>: بافرهایی که داده‌های دستگاه‌های بلوکی را نگهداری می‌کنند تا دسترسی به آنها سریع‌تر شود.</p>
</li>
<li><p><strong>Page Cache</strong>: صفحاتی از فایل‌ها که در حافظه نگهداری می‌شوند تا دسترسی سریع‌تر به داده‌های فایل امکان‌پذیر شود.</p>
</li>
<li><p><strong>dentry Cache</strong>: کش مربوط به مدخل‌های دایرکتوری که باعث بهبود کارایی عملیات سیستم فایل می‌شود.</p>
</li>
<li><p><strong>TLB (Translation Lookaside Buffer)</strong>: یک کش سخت‌افزاری که نگاشت‌های آدرس مجازی به فیزیکی را ذخیره می‌کند تا سرعت ترجمه آدرس افزایش یابد.</p>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of slab allocator usage
 * mm/slab.c (simplified)
 */</span>
<span class="hljs-function"><span class="hljs-keyword">void</span> *<span class="hljs-title">kmem_cache_alloc</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *cachep, <span class="hljs-keyword">gfp_t</span> flags)</span>
</span>{
    <span class="hljs-keyword">void</span> *objp;

    <span class="hljs-comment">/* Get an object from the cache */</span>
    objp = slab_alloc(cachep, flags, _RET_IP_);

    <span class="hljs-comment">/* If needed, run the constructor on the object */</span>
    <span class="hljs-keyword">if</span> (likely(objp) &amp;&amp; unlikely(cachep-&gt;ctor))
        cachep-&gt;ctor(objp);

    <span class="hljs-keyword">return</span> objp;
}

<span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">kmem_cache_free</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> kmem_cache *cachep, <span class="hljs-keyword">void</span> *objp)</span>
</span>{
    <span class="hljs-comment">/* Free an object back to the cache */</span>
    slab_free(cachep, objp, _RET_IP_);
}
</code></pre>
<h3 id="-">تخصیص و آزادسازی حافظه</h3>
<p>تخصیص حافظه در کرنل لینوکس به چند دسته تقسیم می‌شود:</p>
<ol>
<li><p><strong>تخصیص صفحه</strong>: برای تخصیص یک یا چند صفحه متوالی استفاده می‌شود (توابع <code>alloc_pages</code> و <code>__get_free_pages</code>).</p>
</li>
<li><p><strong>تخصیص عمومی</strong>: برای تخصیص حافظه به اندازه دلخواه (توابع <code>kmalloc</code> و <code>kfree</code>).</p>
</li>
<li><p><strong>تخصیص اشیاء</strong>: برای تخصیص اشیاء با اندازه ثابت (توابع <code>kmem_cache_alloc</code> و <code>kmem_cache_free</code>).</p>
</li>
<li><p><strong>تخصیص حافظه پیوسته</strong>: برای تخصیص حافظه فیزیکی پیوسته که برای برخی دستگاه‌ها لازم است (تابع <code>dma_alloc_coherent</code>).</p>
</li>
</ol>
<p>کرنل لینوکس از پرچم‌های <code>GFP</code> (Get Free Page) برای کنترل رفتار تخصیص حافظه استفاده می‌کند. مثال‌هایی از این پرچم‌ها عبارتند از:</p>
<ul>
<li><code>GFP_KERNEL</code>: تخصیص حافظه معمولی (ممکن است بخوابد)</li>
<li><code>GFP_ATOMIC</code>: تخصیص حافظه در بافت‌های اتمیک مانند وقفه‌ها (نمی‌تواند بخوابد)</li>
<li><code>GFP_USER</code>: تخصیص حافظه برای فضای کاربر</li>
<li><code>GFP_DMA</code>: تخصیص حافظه مناسب برای DMA</li>
<li><code>__GFP_ZERO</code>: پر کردن حافظه تخصیص یافته با صفر</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of different memory allocation techniques
 */</span>
void memory_allocation_examples(void)
{
    struct page *pages<span class="hljs-comment">;</span>
    void *ptr1, *ptr2, *ptr3<span class="hljs-comment">;</span>
    struct kmem_cache *<span class="hljs-keyword">cache;
</span>    struct my_struct *obj<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* Page allocation - get 2^3 = 8 consecutive pages */</span>
    pages = alloc_pages(GFP_KERNEL, <span class="hljs-number">3</span>)<span class="hljs-comment">;</span>
    if (pages)
        __free_pages(pages, <span class="hljs-number">3</span>)<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* General purpose allocation */</span>
    ptr1 = kmalloc(<span class="hljs-number">1024</span>, GFP_KERNEL)<span class="hljs-comment">;</span>
    if (ptr1)
        kfree(ptr1)<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* Zero-initialized memory */</span>
    ptr2 = kzalloc(<span class="hljs-number">1024</span>, GFP_KERNEL)<span class="hljs-comment">;</span>
    if (ptr2)
        kfree(ptr2)<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* Virtually contiguous but maybe physically non-contiguous */</span>
    ptr3 = vmalloc(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>)<span class="hljs-comment">;</span>
    if (ptr3)
        vfree(ptr3)<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* Object allocation with slab allocator */</span>
    <span class="hljs-keyword">cache </span>= kmem_cache_create(<span class="hljs-string">"my_cache"</span>, sizeof(struct my_struct),
                             <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, NULL)<span class="hljs-comment">;</span>
    if (<span class="hljs-keyword">cache) </span>{
        obj = kmem_cache_alloc(<span class="hljs-keyword">cache, </span>GFP_KERNEL)<span class="hljs-comment">;</span>
        if (obj)
            kmem_cache_free(<span class="hljs-keyword">cache, </span>obj)<span class="hljs-comment">;</span>
        kmem_cache_destroy(<span class="hljs-keyword">cache);
</span>    }
}
</code></pre>
<h3 id="-">صفحه گردانی</h3>
<p>صفحه گردانی (Paging) یکی از مکانیزم‌های مهم مدیریت حافظه مجازی است. هنگامی که حافظه فیزیکی پر می‌شود، کرنل برخی صفحات کمتر استفاده شده را به دیسک منتقل می‌کند تا فضا برای صفحات جدید آزاد شود. این فرآیند &quot;صفحه گردانی&quot; (swapping یا paging) نامیده می‌شود.</p>
<p>لینوکس از الگوریتم‌های پیچیده‌ای برای انتخاب صفحات برای تعویض استفاده می‌کند. این الگوریتم‌ها سعی می‌کنند صفحاتی را انتخاب کنند که در آینده نزدیک احتمال استفاده از آنها کمتر است. صفحات دستکاری شده (dirty pages) باید قبل از تعویض به دیسک نوشته شوند، در حالی که صفحات بدون تغییر می‌توانند مستقیماً آزاد شوند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of page reclaim code (simplified)
 * mm/vmscan.c
 */</span>
static unsigned long shrink_page_list(struct list_head *page_list,
                                     struct pglist_data *pgdat,
                                     struct scan_control *sc)
{
    LIST_HEAD(ret_pages);
    LIST_HEAD(free_pages);
    unsigned nr_reclaimed = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">while</span> (!list_empty(page_list)) {
        struct <span class="hljs-built_in">page</span> *<span class="hljs-built_in">page</span>;

        <span class="hljs-comment">/* Get a page from the list */</span>
        <span class="hljs-built_in">page</span> = lru_to_page(page_list);
        <span class="hljs-function"><span class="hljs-title">list_del</span>(&amp;<span class="hljs-built_in">page</span>-&gt;</span>lru);

        <span class="hljs-comment">/* Try to lock the page */</span>
        <span class="hljs-keyword">if</span> (!trylock_page(<span class="hljs-built_in">page</span>))
            continue;

        <span class="hljs-comment">/* Skip if page is already being reclaimed */</span>
        <span class="hljs-keyword">if</span> (PageWriteback(<span class="hljs-built_in">page</span>))
            continue;

        <span class="hljs-comment">/* Check if page can be reclaimed */</span>
        <span class="hljs-function"><span class="hljs-title">if</span> (page_referenced(<span class="hljs-built_in">page</span>, 0, sc-&gt;</span><span class="hljs-function"><span class="hljs-title">target_mem_cgroup</span>, &amp;sc-&gt;</span>vm_flags))
            continue;

        <span class="hljs-comment">/* If page is dirty, start writeback */</span>
        <span class="hljs-keyword">if</span> (PageDirty(<span class="hljs-built_in">page</span>)) {
            start_writeback(<span class="hljs-built_in">page</span>);
            continue;
        }

        <span class="hljs-comment">/* Page is clean, can be reclaimed */</span>
        del_page_from_lru_list(<span class="hljs-built_in">page</span>, lruvec, page_lru(<span class="hljs-built_in">page</span>));
        <span class="hljs-function"><span class="hljs-title">list_add</span>(&amp;<span class="hljs-built_in">page</span>-&gt;</span>lru, &amp;free_pages);
        nr_reclaimed++;
    }

    <span class="hljs-comment">/* Free the reclaimed pages */</span>
    nr_reclaimed += free_hot_cold_page_list(&amp;free_pages, <span class="hljs-literal">true</span>);

    return nr_reclaimed;
}
</code></pre>
<h3 id="-">زباله‌روبی و جمع‌آوری حافظه</h3>
<p>برخلاف زبان‌های برنامه‌نویسی سطح بالا، کرنل لینوکس به صورت مستقیم از جمع‌آوری زباله (garbage collection) خودکار پشتیبانی نمی‌کند. مدیریت حافظه به صورت دستی انجام می‌شود و توسعه‌دهندگان کرنل باید حافظه را به درستی تخصیص و آزاد کنند.</p>
<p>با این حال، لینوکس از چندین مکانیزم برای کمک به مدیریت حافظه استفاده می‌کند:</p>
<ol>
<li><p><strong>شمارش ارجاع</strong>: بسیاری از ساختارهای داده کرنل از شمارنده ارجاع استفاده می‌کنند. هر زمان که یک اشاره جدید به شیء ایجاد می‌شود، شمارنده افزایش می‌یابد و هر زمان که یک اشاره حذف می‌شود، شمارنده کاهش می‌یابد. وقتی شمارنده به صفر برسد، شیء آزاد می‌شود.</p>
</li>
<li><p><strong>RCU (Read-Copy-Update)</strong>: یک مکانیزم هم‌روندی که به خوانندگان اجازه می‌دهد بدون قفل‌گذاری به داده‌ها دسترسی داشته باشند، در حالی که نویسندگان می‌توانند همزمان داده‌ها را به‌روزرسانی کنند. پاکسازی حافظه تنها پس از یک &quot;دوره تنفس&quot; (grace period) زمانی که تمام خوانندگان قدیمی کار خود را تمام کرده‌اند، انجام می‌شود.</p>
</li>
<li><p><strong>SLAB Allocator</strong>: این تخصیص‌دهنده حافظه، کارایی را با استفاده مجدد از بلوک‌های حافظه برای اشیاء با اندازه مشابه بهبود می‌بخشد و می‌تواند مشکلات قطعه‌قطعه شدن حافظه را کاهش دهد.</p>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of reference counting
 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_obj</span></span> {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span></span> refcount;
    <span class="hljs-comment">/* other members */</span>
};

<span class="hljs-keyword">static</span> void example_obj_release(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kref</span></span> *<span class="hljs-keyword">ref</span>)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_obj</span></span> *obj = container_of(<span class="hljs-keyword">ref</span>, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_obj</span></span>, refcount);
    <span class="hljs-comment">/* Cleanup resources */</span>
    kfree(obj);
}

<span class="hljs-comment">/* Create a new object */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_obj</span></span> *example_obj_create(void)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_obj</span></span> *obj;

    obj = kzalloc(<span class="hljs-keyword">sizeof</span>(*obj), GFP_KERNEL);
    <span class="hljs-keyword">if</span> (!obj)
        <span class="hljs-keyword">return</span> NULL;

    <span class="hljs-comment">/* Initialize reference count to 1 */</span>
    kref_init(&amp;obj-&gt;refcount);

    <span class="hljs-keyword">return</span> obj;
}

<span class="hljs-comment">/* Get a reference to the object */</span>
void example_obj_get(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_obj</span></span> *obj)
{
    kref_get(&amp;obj-&gt;refcount);
}

<span class="hljs-comment">/* Release a reference to the object */</span>
void example_obj_put(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_obj</span></span> *obj)
{
    <span class="hljs-comment">/* If this was the last reference, the release function will be called */</span>
    kref_put(&amp;obj-&gt;refcount, example_obj_release);
}
</code></pre>
<h2 id="-">زمانبندی فرآیندها</h2>
<p>زمانبندی فرآیندها یکی از وظایف اصلی هر سیستم‌عامل است. زمانبند کرنل لینوکس مسئول تصمیم‌گیری درباره اینکه کدام فرآیند یا نخ باید در چه زمانی روی CPU اجرا شود، است. این بخش پیچیده و حیاتی از کرنل لینوکس، تأثیر مستقیمی بر کارایی، پاسخگویی و عدالت سیستم دارد.</p>
<h3 id="-">فرآیندها و نخ‌ها در لینوکس</h3>
<p>در کرنل لینوکس، هم فرآیندها و هم نخ‌ها با ساختار داده <code>task_struct</code> نمایش داده می‌شوند که گاهی به آن &quot;توصیف‌کننده فرآیند&quot; (process descriptor) نیز می‌گویند. این ساختار حاوی تمام اطلاعات مورد نیاز برای مدیریت یک فرآیند یا نخ است، از جمله:</p>
<ul>
<li>شناسه فرآیند (PID)</li>
<li>وضعیت فرآیند (در حال اجرا، آماده، خوابیده و غیره)</li>
<li>اولویت و اطلاعات زمانبندی</li>
<li>اشاره‌گرهایی به ساختارهای داده مربوط به حافظه، فایل‌های باز و غیره</li>
<li>آمار و اطلاعات حسابداری</li>
</ul>
<p>در لینوکس، نخ‌ها تنها فرآیندهایی هستند که فضای آدرس و برخی منابع دیگر را به اشتراک می‌گذارند. از دیدگاه زمانبند، تفاوت چندانی بین فرآیندها و نخ‌ها وجود ندارد و هر دو به عنوان &quot;task&quot; مدیریت می‌شوند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Simplified version of the task_struct structure
 * include/linux/sched.h
 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> {
    <span class="hljs-comment">/* Task state (TASK_RUNNING, TASK_INTERRUPTIBLE, etc.) */</span>
    long state;

    <span class="hljs-comment">/* Process identification */</span>
    pid_t pid;
    pid_t tgid;

    <span class="hljs-comment">/* Scheduling information */</span>
    <span class="hljs-keyword">int</span> prio, static_prio, normal_prio;
    unsigned <span class="hljs-keyword">int</span> rt_priority;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span></span> se;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_rt_entity</span></span> rt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_dl_entity</span></span> dl;
    unsigned <span class="hljs-keyword">int</span> policy;

    <span class="hljs-comment">/* Process hierarchy */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *parent;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span> children;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">list_head</span></span> sibling;

    <span class="hljs-comment">/* Memory management */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">mm_struct</span></span> *mm, *active_mm;

    <span class="hljs-comment">/* File system info */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">fs_struct</span></span> *fs;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">files_struct</span></span> *files;

    <span class="hljs-comment">/* Signal handlers */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">signal_struct</span></span> *signal;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sighand_struct</span></span> *sighand;
    sigset_t blocked, real_blocked;

    <span class="hljs-comment">/* ... many more fields ... */</span>
};
</code></pre>
<h3 id="-">الگوریتم‌های زمانبندی</h3>
<p>کرنل لینوکس از چندین الگوریتم زمانبندی مختلف پشتیبانی می‌کند که هر کدام برای سناریوهای خاصی بهینه شده‌اند. سه الگوریتم اصلی عبارتند از:</p>
<ol>
<li><p><strong>زمانبند کاملاً عادلانه (CFS - Completely Fair Scheduler)</strong>: 
زمانبند پیش‌فرض برای فرآیندهای معمولی. این زمانبند سعی می‌کند زمان پردازنده را به طور عادلانه بین تمام فرآیندها تقسیم کند، با در نظر گرفتن اولویت آنها.</p>
</li>
<li><p><strong>زمانبند بلادرنگ (RT - Real-Time Scheduler)</strong>:
برای فرآیندهای بلادرنگ نرم که نیاز به پاسخگویی قابل پیش‌بینی دارند. این فرآیندها همیشه اولویت بالاتری نسبت به فرآیندهای معمولی دارند.</p>
</li>
<li><p><strong>زمانبند ضرب‌الاجل (DL - Deadline Scheduler)</strong>:
برای فرآیندهایی که باید کار مشخصی را در زمان مشخصی به پایان برسانند. این زمانبند از الگوریتم زمانبندی ضرب‌الاجل استفاده می‌کند که برای سیستم‌های بلادرنگ سخت مناسب است.</p>
</li>
</ol>
<p>هر فرآیند با یکی از سیاست‌های زمانبندی زیر اجرا می‌شود که مشخص می‌کند کدام الگوریتم برای آن استفاده شود:</p>
<ul>
<li><code>SCHED_NORMAL</code> (یا <code>SCHED_OTHER</code>): زمانبندی معمولی با CFS</li>
<li><code>SCHED_BATCH</code>: مشابه NORMAL، اما برای فرآیندهای دسته‌ای که نیاز به پاسخگویی ندارند</li>
<li><code>SCHED_IDLE</code>: برای فرآیندهایی با کمترین اولویت</li>
<li><code>SCHED_FIFO</code>: زمانبندی بلادرنگ first-in, first-out</li>
<li><code>SCHED_RR</code>: زمانبندی بلادرنگ round-robin</li>
<li><code>SCHED_DEADLINE</code>: زمانبندی ضرب‌الاجل</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Example of setting a process's scheduling policy
 */</span>
<span class="hljs-meta">#<span class="hljs-meta-keyword">include</span> <span class="hljs-meta-string">&lt;sched.h&gt;</span></span>

<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">set_process_scheduling_policy</span><span class="hljs-params">(<span class="hljs-keyword">pid_t</span> pid, <span class="hljs-keyword">int</span> policy, <span class="hljs-keyword">int</span> priority)</span>
</span>{
    <span class="hljs-keyword">struct</span> sched_param param;

    <span class="hljs-comment">/* Set the priority (for SCHED_FIFO and SCHED_RR) */</span>
    param.sched_priority = priority;

    <span class="hljs-comment">/* Change the scheduling policy and priority */</span>
    <span class="hljs-keyword">return</span> sched_setscheduler(pid, policy, &amp;param);
}
</code></pre>
<h3 id="-">کلاس‌های زمانبندی</h3>
<p>زمانبند لینوکس به صورت ماژولار طراحی شده است، به طوری که پیاده‌سازی‌های مختلف زمانبندی می‌توانند به عنوان &quot;کلاس‌های زمانبندی&quot; پیاده‌سازی شوند. هر کلاس زمانبندی باید یک مجموعه عملیات خاص را پیاده‌سازی کند که توسط زمانبند اصلی فراخوانی می‌شوند.</p>
<p>کلاس‌های زمانبندی به صورت سلسله مراتبی مرتب شده‌اند، به طوری که کلاس‌های با اولویت بالاتر همیشه ابتدا برای انتخاب فرآیند بعدی برای اجرا بررسی می‌شوند:</p>
<ol>
<li><strong>کلاس زمانبندی ضرب‌الاجل (dl_sched_class)</strong></li>
<li><strong>کلاس زمانبندی بلادرنگ (rt_sched_class)</strong></li>
<li><strong>کلاس زمانبندی کاملاً عادلانه (fair_sched_class)</strong></li>
<li><strong>کلاس زمانبندی کاربران پیش‌زمینه (idle_sched_class)</strong></li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Structure defining a scheduling class
 * kernel/sched/sched.h
 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span></span> {
    <span class="hljs-comment">/* These methods are called from the main scheduler */</span>
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_class</span></span> *next;

    <span class="hljs-comment">/* Functions required by the scheduler */</span>
    void (*enqueue_task) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *p, <span class="hljs-keyword">int</span> flags);
    void (*dequeue_task) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *p, <span class="hljs-keyword">int</span> flags);
    void (*yield_task) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq);

    void (*check_preempt_curr) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *p, <span class="hljs-keyword">int</span> flags);

    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *(*pick_next_task) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq,
                                          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *prev);

    void (*put_prev_task) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *p);
    void (*set_curr_task) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq);
    void (*task_tick) (<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *p, <span class="hljs-keyword">int</span> queued);

    <span class="hljs-comment">/* ... more methods ... */</span>
};
</code></pre>
<h3 id="-">زمانبند کاملاً قابل پیش‌بینی</h3>
<p>زمانبند کاملاً عادلانه (CFS) که در نسخه 2.6.23 کرنل لینوکس معرفی شد، پیاده‌سازی زمانبند پیش‌فرض برای فرآیندهای معمولی است. این زمانبند بر اساس یک مفهوم ساده استوار است: هر فرآیند باید مقدار عادلانه‌ای از زمان CPU را دریافت کند.</p>
<p>CFS از یک درخت سرخ-سیاه (red-black tree) برای مرتب‌سازی فرآیندها بر اساس &quot;زمان اجرای مجازی&quot; (virtual runtime یا vruntime) آنها استفاده می‌کند. فرآیندی که کمترین vruntime را داشته باشد (یعنی کمترین زمان CPU را تا به حال دریافت کرده است)، بالاترین اولویت را برای اجرا دارد.</p>
<p>ویژگی‌های کلیدی CFS:</p>
<ol>
<li><strong>عدالت</strong>: هدف اصلی تقسیم عادلانه زمان CPU بین فرآیندها است.</li>
<li><strong>بهره‌وری</strong>: CFS با استفاده از ساختارهای داده کارآمد، وظیفه زمانبندی را با پیچیدگی زمانی O(log n) انجام می‌دهد.</li>
<li><strong>مقیاس‌پذیری</strong>: برای هر CPU یک صف جداگانه وجود دارد که به مقیاس‌پذیری در سیستم‌های چندپردازنده‌ای کمک می‌کند.</li>
<li><strong>پاسخگویی</strong>: علی‌رغم تمرکز بر عدالت، CFS پاسخگویی مناسبی را برای فرآیندهای تعاملی فراهم می‌کند.</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Simplified version of CFS's pick_next_task function
 * kernel/sched/fair.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *pick_next_task_fair(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *prev)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">cfs_rq</span></span> *cfs_rq = &amp;rq-&gt;cfs;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_entity</span></span> *se;

    <span class="hljs-keyword">if</span> (!cfs_rq-&gt;nr_running)
        <span class="hljs-keyword">return</span> NULL;

    <span class="hljs-comment">/* Get the leftmost (lowest vruntime) entity from the red-black tree */</span>
    se = pick_next_entity(cfs_rq, NULL);
    <span class="hljs-keyword">if</span> (!se)
        <span class="hljs-keyword">return</span> NULL;

    <span class="hljs-comment">/* Convert the scheduling entity to its task */</span>
    <span class="hljs-keyword">return</span> task_of(se);
}
</code></pre>
<h3 id="-">زمانبندی بلادرنگ</h3>
<p>زمانبند بلادرنگ (RT) لینوکس برای فرآیندهایی طراحی شده است که نیاز به پاسخگویی قابل پیش‌بینی دارند. این زمانبند دو سیاست را پیاده‌سازی می‌کند:</p>
<ol>
<li><p><strong>SCHED_FIFO</strong>: فرآیندها به ترتیب ورود اجرا می‌شوند و هر فرآیند تا زمانی که خودش تصمیم به واگذاری CPU نگیرد یا به حالت خواب برود، به اجرا ادامه می‌دهد.</p>
</li>
<li><p><strong>SCHED_RR</strong>: مشابه FIFO است، با این تفاوت که هر فرآیند تنها برای یک کوانتوم زمانی مشخص اجرا می‌شود و سپس به انتهای صف فرآیندهای هم‌اولویت خود منتقل می‌شود.</p>
</li>
</ol>
<p>هر فرآیند بلادرنگ یک عدد اولویت استاتیک بین 1 (کمترین) تا 99 (بیشترین) دارد. فرآیندهای بلادرنگ همیشه اولویت بالاتری نسبت به فرآیندهای معمولی دارند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Simplified version of RT's pick_next_task function
 * kernel/sched/rt.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *pick_next_task_rt(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_prio_array</span></span> *array = &amp;rq-&gt;rt.active;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rt_rq</span></span> *rt_rq = &amp;rq-&gt;rt;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *p;

    <span class="hljs-comment">/* If no RT tasks, return NULL */</span>
    <span class="hljs-keyword">if</span> (!rt_rq-&gt;rt_nr_running)
        <span class="hljs-keyword">return</span> NULL;

    <span class="hljs-comment">/* Find the highest priority non-empty queue */</span>
    idx = sched_find_first_bit(array-&gt;bitmap);

    <span class="hljs-comment">/* Get the first task from that queue */</span>
    list_for_each_entry(p, &amp;array-&gt;queue[idx], rt.run_list) {
        <span class="hljs-keyword">if</span> (p-&gt;on_rq &amp;&amp; p-&gt;prio == idx) {
            <span class="hljs-keyword">return</span> p;
        }
    }

    <span class="hljs-keyword">return</span> NULL;
}
</code></pre>
<h3 id="-">سیاست‌های زمانبندی</h3>
<p>لینوکس از چندین سیاست زمانبندی پشتیبانی می‌کند که نحوه مدیریت فرآیندها توسط زمانبند را مشخص می‌کنند:</p>
<ol>
<li><p><strong>SCHED_NORMAL (یا SCHED_OTHER)</strong>: سیاست پیش‌فرض برای فرآیندهای معمولی. از الگوریتم CFS استفاده می‌کند.</p>
</li>
<li><p><strong>SCHED_BATCH</strong>: برای فرآیندهای دسته‌ای (batch) که نیاز به پاسخگویی فوری ندارند. این فرآیندها برای بهینه‌سازی توان عملیاتی (throughput) زمانبندی می‌شوند.</p>
</li>
<li><p><strong>SCHED_IDLE</strong>: برای فرآیندهای با اولویت بسیار پایین که تنها زمانی باید اجرا شوند که CPU بیکار است.</p>
</li>
<li><p><strong>SCHED_FIFO</strong>: یک سیاست بلادرنگ که در آن فرآیندها به ترتیب ورود اجرا می‌شوند و تا زمان تکمیل یا بلوکه شدن، CPU را رها نمی‌کنند.</p>
</li>
<li><p><strong>SCHED_RR</strong>: سیاست بلادرنگ Round-Robin که مشابه FIFO است، اما با محدودیت زمانی برای هر فرآیند.</p>
</li>
<li><p><strong>SCHED_DEADLINE</strong>: برای فرآیندهایی که باید تا یک ضرب‌الاجل مشخص کار خود را تمام کنند. این فرآیندها با سه پارامتر مشخص می‌شوند: زمان اجرا، ضرب‌الاجل نسبی و دوره تناوب.</p>
</li>
</ol>
<p>کاربران معمولی می‌توانند با استفاده از تابع سیستمی <code>sched_setscheduler()</code> یا از طریق ابزارهایی مانند <code>chrt</code> سیاست زمانبندی یک فرآیند را تغییر دهند، اما معمولاً تنها کاربر ریشه (root) می‌تواند سیاست‌های بلادرنگ را تنظیم کند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * System call implementation for setting scheduler policy
 * kernel/sched/core.c
 */</span>
SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, <span class="hljs-keyword">int</span>, policy,
               <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_param</span></span> __user *, param)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_param</span></span> lparam;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *p;

    <span class="hljs-keyword">if</span> (!param || pid &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">return</span> -EINVAL;

    <span class="hljs-keyword">if</span> (copy_from_user(&amp;lparam, param, <span class="hljs-keyword">sizeof</span>(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_param</span></span>)))
        <span class="hljs-keyword">return</span> -EFAULT;

    <span class="hljs-comment">/* Find the task */</span>
    p = find_process_by_pid(pid);
    <span class="hljs-keyword">if</span> (!p)
        <span class="hljs-keyword">return</span> -ESRCH;

    <span class="hljs-comment">/* Check permissions */</span>
    <span class="hljs-keyword">if</span> (!capable(CAP_SYS_NICE))
        <span class="hljs-keyword">return</span> -EPERM;

    <span class="hljs-comment">/* Set the scheduling policy */</span>
    <span class="hljs-keyword">return</span> sched_setscheduler(p, policy, &amp;lparam);
}
</code></pre>
<h3 id="-">توزیع بار بین پردازنده‌ها</h3>
<p>در سیستم‌های چندپردازنده‌ای، توزیع بار (load balancing) بین CPU ها یک جنبه مهم از زمانبندی است. هدف این است که بار کاری به طور متعادل بین همه CPU ها توزیع شود تا از منابع سیستم به طور بهینه استفاده شود.</p>
<p>زمانبند لینوکس از چندین راهبرد برای توزیع بار استفاده می‌کند:</p>
<ol>
<li><p><strong>توزیع بار دوره‌ای</strong>: در فواصل زمانی منظم، زمانبند بار کاری هر CPU را بررسی می‌کند و در صورت نیاز، فرآیندها را بین آنها جابجا می‌کند.</p>
</li>
<li><p><strong>توزیع بار در زمان ساخت فرآیند</strong>: هنگام ایجاد یک فرآیند جدید، زمانبند سعی می‌کند آن را روی CPU با کمترین بار قرار دهد.</p>
</li>
<li><p><strong>توزیع بار هنگام بیدار شدن فرآیند</strong>: وقتی یک فرآیند از حالت خواب خارج می‌شود، ممکن است روی CPU دیگری با بار کمتر قرار گیرد.</p>
</li>
<li><p><strong>گروه‌های عادلانه</strong>: سیستم گروه‌بندی فرآیندها که اجازه می‌دهد منابع CPU به طور عادلانه بین گروه‌های مختلف فرآیندها تقسیم شود.</p>
</li>
<li><p><strong>دامنه‌های توزیع بار</strong>: برای مقیاس‌پذیری بهتر در سیستم‌های بزرگ، توزیع بار در سطوح مختلف (CPU ها، هسته‌ها، گره‌های NUMA) انجام می‌شود.</p>
</li>
</ol>
<p>لینوکس همچنین از ویژگی‌های سخت‌افزاری مانند SMT (Simultaneous Multi-Threading) و NUMA (Non-Uniform Memory Access) آگاه است و سعی می‌کند تصمیمات زمانبندی خود را بر اساس توپولوژی سیستم بهینه کند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * Simplified load balancing function
 * kernel/sched/fair.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> load_balance(<span class="hljs-keyword">int</span> this_cpu, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *this_rq,
                       <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sched_domain</span></span> *sd, <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">cpu_idle_type</span></span> idle)
{
    <span class="hljs-keyword">int</span> nr_moved = <span class="hljs-number">0</span>;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *busiest;

    <span class="hljs-comment">/* Find the busiest CPU in this scheduling domain */</span>
    busiest = find_busiest_queue(sd, this_cpu, idle);
    <span class="hljs-keyword">if</span> (!busiest)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* Don't bother balancing if the difference is too small */</span>
    <span class="hljs-keyword">if</span> (!busiest-&gt;nr_running ||
        busiest-&gt;nr_running &lt;= this_rq-&gt;nr_running + <span class="hljs-number">1</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* Try to move tasks from the busiest CPU to this CPU */</span>
    nr_moved = move_tasks(this_rq, this_cpu, busiest, sd);

    <span class="hljs-keyword">return</span> nr_moved;
}
</code></pre>
<p>با این مکانیزم توزیع بار و سایر اجزای توصیف شده، زمانبند فرآیندهای لینوکس استفاده کارآمد از منابع CPU، توزیع عادلانه زمان پردازنده بین فرآیندها و پشتیبانی از سناریوهای مختلف کاربری - از برنامه‌های تعاملی تا سیستم‌های بلادرنگ و سرورهای با بار بالا - را تضمین می‌کند.</p>
<h2 id="-">سیستم فایل در لینوکس</h2>
<p>یکی از ویژگی‌های قدرتمند و انعطاف‌پذیر کرنل لینوکس، سیستم فایل آن است. لینوکس از طیف گسترده‌ای از سیستم‌های فایل پشتیبانی می‌کند و یک ساختار انتزاعی قدرتمند به نام VFS (Virtual File System) را برای یکپارچه‌سازی آنها ارائه می‌دهد. در این بخش، اجزای مختلف سیستم فایل لینوکس را بررسی می‌کنیم.</p>
<h3 id="-vfs">معماری VFS</h3>
<p>سیستم فایل مجازی (VFS) یک لایه انتزاعی در کرنل لینوکس است که واسط یکپارچه‌ای برای تعامل با انواع مختلف سیستم‌های فایل فراهم می‌کند. این معماری به برنامه‌های کاربردی اجازه می‌دهد تا با استفاده از یک سری فراخوانی‌های سیستمی استاندارد، به سیستم‌های فایل متنوع دسترسی داشته باشند، بدون آنکه نیاز به آگاهی از جزئیات پیاده‌سازی آنها داشته باشند.</p>
<p><strong>اجزای اصلی VFS:</strong></p>
<ol>
<li><strong>Superblock</strong>: نماینده یک سیستم فایل نصب شده است و اطلاعات کلی آن را نگهداری می‌کند.</li>
<li><strong>Inode</strong>: نماینده یک فایل منحصر به فرد است و ویژگی‌های آن را ذخیره می‌کند.</li>
<li><strong>Dentry</strong>: نماینده یک مدخل دایرکتوری است که ارتباط بین نام فایل و inode را برقرار می‌کند.</li>
<li><strong>File</strong>: نماینده یک فایل باز شده توسط یک فرآیند است.</li>
</ol>
<p>VFS از یک مدل شیء‌گرا استفاده می‌کند که در آن هر سیستم فایل خاص، توابع عملیاتی خود را برای رسیدگی به اشیاء VFS پیاده‌سازی می‌کند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * ساختارهای داده اصلی VFS در کرنل لینوکس
 * include/linux/fs.h
 */</span>

<span class="hljs-comment">/* ساختار Superblock که اطلاعات سیستم فایل را نگهداری می‌کند */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span></span> {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_system_type</span></span> *s_type;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span></span> *s_root;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_operations</span></span> *s_op;
    unsigned long s_magic;
    dev_t s_dev;
    <span class="hljs-comment">// دیگر فیلدها...</span>
};

<span class="hljs-comment">/* ساختار Inode که اطلاعات یک فایل را نگهداری می‌کند */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> {
    umode_t i_mode;
    uid_t i_uid;
    gid_t i_gid;
    dev_t i_rdev;
    loff_t i_size;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">timespec</span></span> i_atime, i_mtime, i_ctime;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_operations</span></span> *i_op;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span> *i_fop;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">super_block</span></span> *i_sb;
    <span class="hljs-comment">// دیگر فیلدها...</span>
};

<span class="hljs-comment">/* ساختار Dentry که ارتباط بین نام فایل و inode را برقرار می‌کند */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span></span> {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *d_inode;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry</span></span> *d_parent;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">qstr</span></span> d_name;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dentry_operations</span></span> *d_op;
    <span class="hljs-comment">// دیگر فیلدها...</span>
};

<span class="hljs-comment">/* ساختار File که نماینده یک فایل باز شده است */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> {
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">path</span></span> f_path;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *f_inode;
    <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_operations</span></span> *f_op;
    loff_t f_pos;
    unsigned <span class="hljs-keyword">int</span> f_flags;
    <span class="hljs-comment">// دیگر فیلدها...</span>
};
</code></pre>
<p><strong>عملیات VFS:</strong></p>
<p>VFS عملیات خود را از طریق ساختارهایی مانند <code>super_operations</code>، <code>inode_operations</code> و <code>file_operations</code> انجام می‌دهد. این ساختارها شامل اشاره‌گرهایی به توابعی هستند که برای هر سیستم فایل خاص پیاده‌سازی می‌شوند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * عملیات فایل در VFS
 * include/linux/fs.h
 */</span>
<span class="hljs-keyword">struct</span> file_operations {
    <span class="hljs-keyword">ssize_t</span> (*read) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">char</span> __user *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);
    <span class="hljs-keyword">ssize_t</span> (*write) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, <span class="hljs-keyword">size_t</span>, <span class="hljs-keyword">loff_t</span> *);
    <span class="hljs-keyword">long</span> (*unlocked_ioctl) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span>, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span>);
    <span class="hljs-keyword">int</span> (*mmap) (<span class="hljs-keyword">struct</span> file *, <span class="hljs-keyword">struct</span> vm_area_struct *);
    <span class="hljs-keyword">int</span> (*open) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);
    <span class="hljs-keyword">int</span> (*release) (<span class="hljs-keyword">struct</span> inode *, <span class="hljs-keyword">struct</span> file *);
    <span class="hljs-comment">// دیگر توابع...</span>
};
</code></pre>
<h3 id="-">انواع سیستم فایل در لینوکس</h3>
<p>لینوکس از تعداد زیادی سیستم فایل پشتیبانی می‌کند که می‌توان آنها را به چندین دسته تقسیم کرد:</p>
<ol>
<li><p><strong>سیستم‌های فایل محلی</strong>: برای ذخیره‌سازی داده روی دیسک‌های محلی استفاده می‌شوند.</p>
<ul>
<li>ext2, ext3, ext4</li>
<li>XFS</li>
<li>Btrfs</li>
<li>F2FS</li>
<li>JFS</li>
<li>ReiserFS</li>
</ul>
</li>
<li><p><strong>سیستم‌های فایل شبکه</strong>: برای دسترسی به فایل‌های ذخیره شده روی سرورهای راه دور استفاده می‌شوند.</p>
<ul>
<li>NFS (Network File System)</li>
<li>CIFS (Common Internet File System)</li>
<li>AFS (Andrew File System)</li>
</ul>
</li>
<li><p><strong>سیستم‌های فایل ویژه</strong>: برای اهداف خاص استفاده می‌شوند.</p>
<ul>
<li>procfs: دسترسی به اطلاعات فرآیندها و کرنل</li>
<li>sysfs: دسترسی به اطلاعات سیستم و پیکربندی</li>
<li>tmpfs: سیستم فایل موقت در حافظه</li>
<li>devfs/udev: مدیریت فایل‌های دستگاه</li>
</ul>
</li>
<li><p><strong>سیستم‌های فایل فشرده</strong>: برای دسترسی به فایل‌های فشرده بدون نیاز به استخراج آنها.</p>
<ul>
<li>squashfs</li>
<li>cramfs</li>
</ul>
</li>
<li><p><strong>سیستم‌های فایل رمزگذاری شده</strong>: برای ذخیره‌سازی امن داده‌ها.</p>
<ul>
<li>eCryptfs</li>
<li>LUKS/dm-crypt</li>
</ul>
</li>
</ol>
<h3 id="ext2-ext3-ext4">ext2، ext3 و ext4</h3>
<p>خانواده Extended File System (ext) طی سال‌ها سیستم‌های فایل استاندارد در بسیاری از توزیع‌های لینوکس بوده‌اند. این سیستم‌های فایل نسل به نسل تکامل یافته‌اند تا قابلیت‌های بیشتر، کارایی بهتر و اطمینان‌پذیری بالاتری را فراهم کنند.</p>
<p><strong>ext2:</strong></p>
<ul>
<li>سیستم فایل ابتدایی لینوکس بدون قابلیت ژورنالینگ</li>
<li>ساختار ساده و کارآمد</li>
<li>مناسب برای رسانه‌های با تعداد نوشتن محدود مانند کارت‌های SD و حافظه‌های فلش</li>
</ul>
<p><strong>ext3:</strong></p>
<ul>
<li>نسخه بهبود یافته ext2 با قابلیت ژورنالینگ</li>
<li>ژورنالینگ باعث افزایش اطمینان‌پذیری می‌شود و از آسیب دیدن فایل‌سیستم در صورت قطع ناگهانی برق جلوگیری می‌کند</li>
<li>سازگاری کامل با ext2</li>
</ul>
<p><strong>ext4:</strong></p>
<ul>
<li>توسعه داده شده در سال 2008 به عنوان جانشین ext3</li>
<li>پشتیبانی از فایل‌ها و پارتیشن‌های بسیار بزرگ (تا 16 تربایت)</li>
<li>تخصیص حافظه اختصاصی برای کاهش قطعه‌قطعه شدن</li>
<li>تأخیر در تخصیص بلوک برای بهبود کارایی</li>
<li>چک‌سام‌های داده و ژورنال برای افزایش اطمینان‌پذیری</li>
<li>نگاشت مستقیم برای فایل‌های بزرگ</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * ساختار بلوک super در ext4
 * fs/ext4/ext4.h
 */</span>
<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">ext4_super_block</span> </span>{
    __le32  s_inodes_count;         <span class="hljs-comment">/* تعداد inodeها */</span>
    __le32  s_blocks_count_lo;      <span class="hljs-comment">/* تعداد بلوک‌ها */</span>
    __le32  s_r_blocks_count_lo;    <span class="hljs-comment">/* تعداد بلوک‌های رزرو شده */</span>
    __le32  s_free_blocks_count_lo; <span class="hljs-comment">/* تعداد بلوک‌های آزاد */</span>
    __le32  s_free_inodes_count;    <span class="hljs-comment">/* تعداد inodeهای آزاد */</span>
    __le32  s_first_data_block;     <span class="hljs-comment">/* اولین بلوک داده */</span>
    __le32  s_log_block_size;       <span class="hljs-comment">/* لگاریتم 2 از اندازه بلوک */</span>
    __le32  s_log_cluster_size;     <span class="hljs-comment">/* لگاریتم 2 از اندازه خوشه */</span>
    __le32  s_blocks_per_group;     <span class="hljs-comment">/* تعداد بلوک‌ها در هر گروه */</span>
    __le32  s_clusters_per_group;   <span class="hljs-comment">/* تعداد خوشه‌ها در هر گروه */</span>
    __le32  s_inodes_per_group;     <span class="hljs-comment">/* تعداد inodeها در هر گروه */</span>
    <span class="hljs-comment">// دیگر فیلدها...</span>
};
</code></pre>
<h3 id="btrfs-zfs">Btrfs و ZFS</h3>
<p>Btrfs (B-tree File System) و ZFS دو سیستم فایل پیشرفته هستند که ویژگی‌های نسل جدید را ارائه می‌دهند، مانند نسخه‌برداری از داده‌ها، اسنپ‌شات، RAID نرم‌افزاری و چک‌سام‌های داده.</p>
<p><strong>Btrfs:</strong></p>
<ul>
<li>توسط Oracle توسعه داده شده و به عنوان &quot;باتر‌اف‌اس&quot; تلفظ می‌شود</li>
<li>طراحی شده برای رفع محدودیت‌های سیستم‌های فایل قدیمی‌تر</li>
<li>قابلیت‌های کلیدی شامل:<ul>
<li>اسنپ‌شات‌های قابل نوشتن</li>
<li>زیرحجم‌ها (Subvolumes)</li>
<li>RAID نرم‌افزاری داخلی</li>
<li>فشرده‌سازی</li>
<li>تدبیر (deduplication)</li>
<li>چک‌سام‌های داده برای تشخیص خرابی‌ها</li>
</ul>
</li>
</ul>
<p><strong>ZFS:</strong></p>
<ul>
<li>در اصل توسط Sun Microsystems برای Solaris توسعه یافته</li>
<li>معماری مبتنی بر استخر ذخیره‌سازی (storage pool)</li>
<li>قابلیت‌های کلیدی شامل:<ul>
<li>اعتبارسنجی و خودترمیمی داده‌ها</li>
<li>اسنپ‌شات‌ها و کلون‌ها</li>
<li>فشرده‌سازی</li>
<li>تدبیر</li>
<li>رمزگذاری</li>
<li>ظرفیت ذخیره‌سازی بسیار بالا</li>
</ul>
</li>
</ul>
<p>به دلیل مسائل مربوط به مجوز، ZFS به طور پیش‌فرض در هسته لینوکس قرار ندارد و معمولاً باید به صورت ماژول جداگانه نصب شود.</p>
<h3 id="-">سیستم‌های فایل شبکه</h3>
<p>سیستم‌های فایل شبکه امکان دسترسی به فایل‌های ذخیره شده روی سرورهای راه دور را فراهم می‌کنند. لینوکس از چندین سیستم فایل شبکه محبوب پشتیبانی می‌کند:</p>
<p><strong>NFS (Network File System):</strong></p>
<ul>
<li>توسط Sun Microsystems توسعه داده شده</li>
<li>رایج‌ترین سیستم فایل شبکه در محیط‌های UNIX/Linux</li>
<li>از پروتکل RPC (Remote Procedure Call) استفاده می‌کند</li>
<li>نسخه‌های مختلف: NFSv2, NFSv3, NFSv4</li>
<li>ویژگی‌های NFSv4 شامل:<ul>
<li>احراز هویت و رمزگذاری بهبود یافته</li>
<li>بهبود عملکرد در شبکه‌های WAN</li>
<li>پشتیبانی از استیت‌فول (stateful) بودن</li>
<li>تجمیع چندین فراخوانی روال در یک عملیات</li>
</ul>
</li>
</ul>
<p><strong>CIFS/SMB:</strong></p>
<ul>
<li>Common Internet File System/Server Message Block</li>
<li>استفاده شده توسط Windows برای اشتراک‌گذاری فایل</li>
<li>در لینوکس توسط پروژه Samba پیاده‌سازی شده</li>
<li>قابلیت‌ها:<ul>
<li>احراز هویت و کنترل دسترسی Windows</li>
<li>یکپارچه‌سازی با دامنه‌های Windows</li>
<li>اشتراک‌گذاری چاپگر</li>
</ul>
</li>
</ul>
<p><strong>SSHFS:</strong></p>
<ul>
<li>سیستم فایل بر پایه SFTP</li>
<li>امکان نصب سیستم فایل راه دور از طریق SSH</li>
<li>مزایا:<ul>
<li>امنیت بالا (رمزگذاری)</li>
<li>سادگی راه‌اندازی (نیاز به نصب هیچ سرویس اضافی ندارد)</li>
<li>عبور از فایروال‌ها (معمولاً پورت SSH باز است)</li>
</ul>
</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثالی از کد کرنل لینوکس برای NFS
 * fs/nfs/nfs4proc.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> nfs4_do_open(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *inode, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *filp, <span class="hljs-keyword">int</span> flags)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nfs_open_context</span></span> *ctx;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nfs4_state</span></span> *state = NULL;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">nfs4_opendata</span></span> *opendata;
    <span class="hljs-keyword">int</span> ret;

    ctx = nfs_open_context_alloc();
    <span class="hljs-keyword">if</span> (!ctx)
        <span class="hljs-keyword">return</span> -ENOMEM;

    opendata = nfs4_opendata_alloc(filp-&gt;f_path.dentry, ctx);
    <span class="hljs-keyword">if</span> (!opendata) {
        ret = -ENOMEM;
        goto out;
    }

    <span class="hljs-comment">/* انجام عملیات باز کردن NFSv4 */</span>
    ret = _nfs4_do_open(opendata);
    <span class="hljs-keyword">if</span> (ret)
        goto out_opendata;

    state = opendata-&gt;state;
    ret = nfs4_opendata_check_status(opendata);
    <span class="hljs-keyword">if</span> (ret)
        goto out_opendata;

    <span class="hljs-comment">/* تنظیم حالت فایل و دیگر داده‌های مرتبط */</span>
    ctx-&gt;state = state;
    filp-&gt;private_data = ctx;

out_opendata:
    nfs4_opendata_put(opendata);
out:
    <span class="hljs-keyword">if</span> (ret)
        nfs_free_open_context(ctx);
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<h3 id="-">عملکرد ورودی/خروجی</h3>
<p>سیستم ورودی/خروجی (I/O) لینوکس مسئول مدیریت درخواست‌های خواندن و نوشتن به دستگاه‌های ذخیره‌سازی است. این سیستم شامل چندین لایه است که هر کدام وظایف خاصی را انجام می‌دهند:</p>
<p><strong>لایه VFS:</strong></p>
<ul>
<li>واسط یکپارچه برای دسترسی به سیستم‌های فایل</li>
<li>ارائه فراخوانی‌های سیستمی استاندارد: open(), read(), write(), close() و غیره</li>
<li>مدیریت حافظه کش برای فایل‌ها (Page Cache)</li>
</ul>
<p><strong>لایه سیستم فایل:</strong></p>
<ul>
<li>تبدیل درخواست‌های سطح بالا به عملیات سطح بلوک</li>
<li>مدیریت ساختار منطقی سیستم فایل (دایرکتوری‌ها، inodeها و غیره)</li>
</ul>
<p><strong>لایه Generic Block Layer:</strong></p>
<ul>
<li>برنامه‌ریزی درخواست‌های I/O</li>
<li>ادغام و مرتب‌سازی درخواست‌ها برای بهینه‌سازی عملکرد</li>
<li>سیستم I/O صف‌بندی شده (I/O Schedulers)</li>
</ul>
<p><strong>لایه درایور بلوکی:</strong></p>
<ul>
<li>تعامل مستقیم با سخت‌افزار ذخیره‌سازی</li>
<li>پیاده‌سازی پروتکل‌های خاص سخت‌افزار (SATA, SCSI, NVMe و غیره)</li>
</ul>
<p><strong>برنامه‌ریزهای I/O (I/O Schedulers):</strong></p>
<p>لینوکس از چندین برنامه‌ریز I/O پشتیبانی می‌کند که هر کدام برای سناریوهای خاصی بهینه شده‌اند:</p>
<ol>
<li><strong>CFQ (Completely Fair Queuing)</strong>: تلاش می‌کند زمان I/O را به طور عادلانه بین فرآیندها تقسیم کند. مناسب برای workstation.</li>
<li><strong>Deadline</strong>: برای کاهش زمان پاسخ طراحی شده و ضرب‌الاجل‌هایی برای خواندن و نوشتن تنظیم می‌کند. مناسب برای سرورهای پایگاه داده.</li>
<li><strong>NOOP</strong>: ساده‌ترین برنامه‌ریز که ادغام درخواست‌های مجاور را انجام می‌دهد اما مرتب‌سازی پیچیده انجام نمی‌دهد. مناسب برای دستگاه‌های فلش و درایوهای SSD.</li>
<li><strong>BFQ (Budget Fair Queuing)</strong>: به هر فرآیند بودجه I/O اختصاص می‌دهد. برای سیستم‌هایی با انواع مختلف بار کاری مناسب است.</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه ساده‌ای از کد برنامه‌ریز I/O
 * block/deadline-iosched.c (ساده شده)
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> deadline_dispatch(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request_queue</span></span> *q, <span class="hljs-keyword">int</span> force)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">deadline_data</span></span> *dd = q-&gt;elevator-&gt;elevator_data;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">request</span></span> *rq;

    <span class="hljs-comment">/* ابتدا سعی کن از صف‌های خواندن با ضرب‌الاجل برداری */</span>
    rq = deadline_check_fifo(dd, DEADLINE_READ);
    <span class="hljs-keyword">if</span> (rq)
        goto dispatch;

    <span class="hljs-comment">/* سپس صف‌های نوشتن با ضرب‌الاجل را بررسی کن */</span>
    rq = deadline_check_fifo(dd, DEADLINE_WRITE);
    <span class="hljs-keyword">if</span> (rq)
        goto dispatch;

    <span class="hljs-comment">/* اگر صف‌های با ضرب‌الاجل خالی بودند، از صف‌های عادی استفاده کن */</span>
    <span class="hljs-keyword">if</span> (dd-&gt;next_batch == DEADLINE_BATCH_READ)
        rq = deadline_next_request(dd, DEADLINE_READ);
    <span class="hljs-keyword">else</span>
        rq = deadline_next_request(dd, DEADLINE_WRITE);

    <span class="hljs-keyword">if</span> (!rq) {
        <span class="hljs-comment">/* تغییر بین خواندن و نوشتن */</span>
        dd-&gt;next_batch = !dd-&gt;next_batch;
        rq = deadline_next_request(dd, dd-&gt;next_batch);
    }

dispatch:
    <span class="hljs-keyword">if</span> (rq) {
        <span class="hljs-comment">/* درخواست را به لایه پایین‌تر ارسال کن */</span>
        dd-&gt;dispatched++;
        elv_dispatch_add_tail(q, rq);
        <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;
    }

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<h3 id="-">کش و بافر سیستم فایل</h3>
<p>کرنل لینوکس از چندین مکانیزم کش برای بهبود عملکرد سیستم فایل استفاده می‌کند:</p>
<p><strong>Page Cache:</strong></p>
<ul>
<li>حافظه کش اصلی برای داده‌های فایل</li>
<li>صفحات خوانده شده از دیسک را در حافظه نگه می‌دارد</li>
<li>خواندن‌ها و نوشتن‌های بعدی به همان داده می‌توانند بدون دسترسی به دیسک انجام شوند</li>
<li>کاهش قابل توجه زمان دسترسی به داده‌ها</li>
<li>از الگوریتم LRU (Least Recently Used) برای مدیریت حافظه استفاده می‌کند</li>
</ul>
<p><strong>Buffer Cache:</strong></p>
<ul>
<li>کش برای بلوک‌های دیسک (بیشتر برای متاداده‌های سیستم فایل)</li>
<li>در نسخه‌های جدید کرنل، Buffer Cache در Page Cache ادغام شده است</li>
</ul>
<p><strong>Dentry Cache:</strong></p>
<ul>
<li>کش برای مدخل‌های دایرکتوری (dentry)</li>
<li>نگاشت بین نام‌های فایل و inodeها را ذخیره می‌کند</li>
<li>تسریع جستجوی مسیر فایل</li>
</ul>
<p><strong>Inode Cache:</strong></p>
<ul>
<li>کش برای inodeهای پر استفاده</li>
<li>اطلاعات متاداده فایل‌ها را در حافظه نگه می‌دارد</li>
</ul>
<p><strong>مکانیزم‌های نوشتن:</strong></p>
<p>برای نوشتن داده‌های تغییر یافته از Page Cache به دیسک، کرنل لینوکس از چندین استراتژی استفاده می‌کند:</p>
<ol>
<li><strong>نوشتن همزمان (Synchronous Write)</strong>: داده‌ها بلافاصله به دیسک نوشته می‌شوند.</li>
<li><strong>نوشتن با تأخیر (Delayed Write)</strong>: داده‌های تغییر یافته در حافظه نگهداری می‌شوند و در زمان مناسب‌تری به دیسک نوشته می‌شوند.</li>
<li><strong>نوشتن دوره‌ای (Periodic Write)</strong>: دیمون <code>pdflush</code> یا <code>kworker</code> (در کرنل‌های جدیدتر) به طور دوره‌ای داده‌های تغییر یافته را به دیسک می‌نویسد.</li>
<li><strong>نوشتن پیش‌گیرانه (Writeback)</strong>: سیستم به طور خودکار و بر اساس فشار حافظه، داده‌های تغییر یافته را به دیسک می‌نویسد.</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از کد مرتبط با Page Cache
 * mm/filemap.c
 */</span>
void do_generic_file_read(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *filp, loff_t *ppos, 
                          <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">kiocb</span></span> *iocb, <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">iov_iter</span></span> *iter)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">address_space</span></span> *mapping = filp-&gt;f_mapping;
    pgoff_t index = *ppos &gt;&gt; PAGE_SHIFT;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">page</span></span> *page;
    <span class="hljs-keyword">int</span> ret;

    <span class="hljs-comment">/* سعی کن صفحه را از Page Cache بیابی */</span>
    page = find_get_page(mapping, index);
    <span class="hljs-keyword">if</span> (!page) {
        <span class="hljs-comment">/* صفحه در کش نیست، آن را از دیسک بخوان */</span>
        page = page_cache_alloc_cold(mapping);
        <span class="hljs-keyword">if</span> (!page)
            <span class="hljs-keyword">return</span> -ENOMEM;

        <span class="hljs-comment">/* صفحه را از دیسک بخوان */</span>
        ret = mapping-&gt;a_ops-&gt;readpage(filp, page);
        <span class="hljs-keyword">if</span> (ret) {
            put_page(page);
            <span class="hljs-keyword">return</span> ret;
        }

        <span class="hljs-comment">/* صفحه را به Page Cache اضافه کن */</span>
        add_to_page_cache_lru(page, mapping, index, GFP_KERNEL);
    }

    <span class="hljs-comment">/* داده را از صفحه به فضای کاربر کپی کن */</span>
    copy_page_to_iter(page, <span class="hljs-number">0</span>, PAGE_SIZE, iter);

    put_page(page);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>سیستم فایل در لینوکس یک طراحی پیچیده، انعطاف‌پذیر و کارآمد است که به کرنل اجازه می‌دهد از انواع مختلف رسانه‌های ذخیره‌سازی، سیستم‌های فایل و پروتکل‌های شبکه پشتیبانی کند. لایه VFS نقش کلیدی در ارائه یک واسط یکپارچه بازی می‌کند، در حالی که مکانیزم‌های کش و برنامه‌ریزی I/O، عملکرد را بهبود می‌بخشند.</p>
<h2 id="-">مدیریت دستگاه‌ها</h2>
<p>مدیریت دستگاه‌ها در کرنل لینوکس یکی از وظایف اصلی و پیچیده‌ای است که این سیستم‌عامل را قادر می‌سازد با انواع مختلف سخت‌افزارها تعامل داشته باشد. لینوکس از یک مدل مبتنی بر درایور استفاده می‌کند که انتزاع سطح بالایی از سخت‌افزار فراهم می‌کند و به برنامه‌های کاربردی اجازه می‌دهد بدون نیاز به دانستن جزئیات سخت‌افزار، با دستگاه‌ها ارتباط برقرار کنند.</p>
<h3 id="-">درایورهای دستگاه</h3>
<p>درایورهای دستگاه، ماژول‌های کرنلی هستند که عملکرد یک دستگاه سخت‌افزاری خاص را کنترل می‌کنند. آنها واسط بین سخت‌افزار و بقیه کرنل هستند و وظیفه ترجمه درخواست‌های سطح بالا به دستورات خاص سخت‌افزار را بر عهده دارند.</p>
<p><strong>انواع درایورهای دستگاه در لینوکس:</strong></p>
<ol>
<li><p><strong>درایورهای کاراکتری (Character Drivers)</strong>:</p>
<ul>
<li>برای دستگاه‌هایی که داده را به صورت جریانی از بایت‌ها منتقل می‌کنند</li>
<li>دسترسی به داده به صورت متوالی (sequential)</li>
<li>مثال‌ها: پورت‌های سریال، کیبورد، موس، چاپگر</li>
</ul>
</li>
<li><p><strong>درایورهای بلوکی (Block Drivers)</strong>:</p>
<ul>
<li>برای دستگاه‌های ذخیره‌سازی که داده را در بلوک‌های با اندازه ثابت ذخیره می‌کنند</li>
<li>دسترسی به داده به صورت تصادفی (random)</li>
<li>مثال‌ها: هارد دیسک، SSD، دیسک‌های فلش</li>
</ul>
</li>
<li><p><strong>درایورهای شبکه (Network Drivers)</strong>:</p>
<ul>
<li>برای کارت‌های شبکه</li>
<li>از واسط خاصی به نام netdevice استفاده می‌کنند</li>
<li>مدیریت بسته‌های شبکه برای ارسال و دریافت</li>
</ul>
</li>
<li><p><strong>درایورهای USB</strong>:</p>
<ul>
<li>برای مدیریت دستگاه‌های متصل به پورت USB</li>
<li>با استفاده از چارچوب USB کرنل</li>
</ul>
</li>
<li><p><strong>درایورهای گرافیکی</strong>:</p>
<ul>
<li>برای کارت‌های گرافیک و نمایشگرها</li>
<li>از چارچوب‌های DRM (Direct Rendering Manager)، KMS (Kernel Mode Setting) و Framebuffer استفاده می‌کنند</li>
</ul>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثالی از یک درایور کاراکتری ساده
 * درایورهای کاراکتری از ساختار file_operations استفاده می‌کنند
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> file_operations simple_driver_fops = {
    .owner = THIS_MODULE,
    .<span class="hljs-built_in">open</span> = simple_open,
    .<span class="hljs-built_in">read</span> = simple_read,
    .<span class="hljs-built_in">write</span> = simple_write,
    .<span class="hljs-built_in">release</span> = simple_release,
};

<span class="hljs-comment">/* ثبت درایور در سیستم */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init simple_init(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">int</span> ret;

    <span class="hljs-comment">/* ثبت شماره major برای درایور */</span>
    ret = register_chrdev(SIMPLE_MAJOR, <span class="hljs-string">"simple"</span>, &amp;simple_driver_fops);
    <span class="hljs-built_in">if</span> (ret &lt; <span class="hljs-number">0</span>) {
        printk(KERN_ERR <span class="hljs-string">"Failed to register simple driver\n"</span>);
        <span class="hljs-built_in">return</span> ret;
    }

    printk(KERN_INFO <span class="hljs-string">"Simple driver loaded\n"</span>);
    <span class="hljs-built_in">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* خروج درایور از سیستم */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit simple_exit(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-comment">/* لغو ثبت درایور */</span>
    unregister_chrdev(SIMPLE_MAJOR, <span class="hljs-string">"simple"</span>);
    printk(KERN_INFO <span class="hljs-string">"Simple driver unloaded\n"</span>);
}

module_init(simple_init);
module_exit(simple_exit);
</code></pre>
<h3 id="-">سیستم‌های فایل دستگاه</h3>
<p>یکی از مفاهیم اساسی در لینوکس این است که &quot;همه چیز یک فایل است&quot;. این فلسفه شامل دستگاه‌های سخت‌افزاری نیز می‌شود. لینوکس از دو سیستم فایل ویژه برای ارائه اطلاعات و کنترل دستگاه‌ها استفاده می‌کند: <code>/dev</code> و <code>/proc</code>.</p>
<p><strong>/dev (Device Filesystem):</strong></p>
<ul>
<li>حاوی فایل‌های ویژه‌ای است که دستگاه‌های سخت‌افزاری را نمایش می‌دهند</li>
<li>انواع اصلی فایل‌های دستگاه:<ul>
<li><strong>دستگاه‌های کاراکتری</strong>: با حرف &quot;c&quot; در خروجی دستور <code>ls -l</code> مشخص می‌شوند</li>
<li><strong>دستگاه‌های بلوکی</strong>: با حرف &quot;b&quot; در خروجی دستور <code>ls -l</code> مشخص می‌شوند</li>
</ul>
</li>
<li>هر فایل دستگاه با یک جفت عدد (major, minor) مشخص می‌شود:<ul>
<li><strong>Major number</strong>: مشخص کننده درایور مورد استفاده</li>
<li><strong>Minor number</strong>: مشخص کننده یک دستگاه خاص کنترل شده توسط آن درایور</li>
</ul>
</li>
<li>مدیریت <code>/dev</code> معمولاً توسط <code>udev</code> انجام می‌شود (جایگزین مدرن برای devfs)</li>
</ul>
<p><strong>/proc (Process Filesystem):</strong></p>
<ul>
<li>سیستم فایل مجازی که اطلاعاتی درباره فرآیندها و کرنل ارائه می‌دهد</li>
<li>دایرکتوری‌های شماره‌دار نماینده فرآیندهای در حال اجرا هستند</li>
<li>فایل‌های متعددی اطلاعات سیستم را ارائه می‌دهند، مانند:<ul>
<li><code>/proc/cpuinfo</code>: اطلاعات CPU</li>
<li><code>/proc/meminfo</code>: اطلاعات حافظه</li>
<li><code>/proc/interrupts</code>: آمار وقفه‌ها</li>
<li><code>/proc/devices</code>: لیست دستگاه‌های ثبت شده</li>
</ul>
</li>
</ul>
<p><strong>/sys (Sysfs):</strong></p>
<ul>
<li>سیستم فایل مجازی جدیدتر که اطلاعات بیشتری درباره دستگاه‌ها و درایورها ارائه می‌دهد</li>
<li>ساختار سلسله مراتبی با دایرکتوری‌های مختلف:<ul>
<li><code>/sys/devices</code>: نمایش سلسله مراتب دستگاه‌های فیزیکی</li>
<li><code>/sys/bus</code>: اطلاعات مربوط به باس‌های سیستم</li>
<li><code>/sys/class</code>: دستگاه‌ها بر اساس کلاس (مثلاً، دیسک، شبکه و غیره)</li>
<li><code>/sys/block</code>: دستگاه‌های بلوکی</li>
<li><code>/sys/module</code>: ماژول‌های کرنل بارگذاری شده</li>
</ul>
</li>
</ul>
<pre><code class="lang-bash"><span class="hljs-comment"># نمونه‌ای از خروجی ls -l در دایرکتوری /dev</span>
$ ls -l /dev/sda /dev/tty1
brw-rw----<span class="hljs-number"> 1 </span>root disk    8,<span class="hljs-number"> 0 </span>Jun<span class="hljs-number"> 30 </span>12:34 /dev/sda
crw--w----<span class="hljs-number"> 1 </span>root tty     4,<span class="hljs-number"> 1 </span>Jun<span class="hljs-number"> 30 </span>12:35 /dev/tty1
<span class="hljs-comment"># b نشان دهنده دستگاه بلوکی و c نشان دهنده دستگاه کاراکتری است</span>
<span class="hljs-comment"># 8,0 و 4,1 اعداد major و minor هستند</span>
</code></pre>
<h3 id="-">مدل درایور لینوکس</h3>
<p>کرنل لینوکس دارای یک مدل منسجم و چارچوب قدرتمند برای نوشتن درایورهای دستگاه است. مدل درایور لینوکس دارای چندین ویژگی کلیدی است:</p>
<p><strong>1. مدل ماژولار:</strong></p>
<ul>
<li>درایورها می‌توانند به صورت ماژول‌های قابل بارگذاری پویا پیاده‌سازی شوند</li>
<li>این امکان اضافه کردن یا حذف درایورها بدون نیاز به راه‌اندازی مجدد سیستم را فراهم می‌کند</li>
<li>ماژول‌ها با دستورات <code>insmod</code>, <code>modprobe</code> و <code>rmmod</code> مدیریت می‌شوند</li>
</ul>
<p><strong>2. چارچوب‌های زیرساختی:</strong></p>
<ul>
<li>کرنل چارچوب‌های متعددی برای انواع خاصی از دستگاه‌ها ارائه می‌دهد</li>
<li>نویسندگان درایور می‌توانند از این چارچوب‌ها به جای نوشتن همه کد از ابتدا استفاده کنند</li>
<li>مثال‌ها: USB، PCI، I2C، SPI، گرافیک، شبکه و غیره</li>
</ul>
<p><strong>3. مدل رانشی (Driver Model):</strong></p>
<ul>
<li>چارچوب یکپارچه برای نمایش دستگاه‌ها، درایورها و باس‌ها</li>
<li>تعریف واسط‌های استاندارد برای تعامل درایور-دستگاه</li>
<li>پشتیبانی از hotplug و مدیریت انرژی</li>
</ul>
<p><strong>4. مدل تطبیق درایور-دستگاه:</strong></p>
<ul>
<li>شناسایی خودکار دستگاه‌ها توسط کرنل</li>
<li>تطبیق دستگاه‌های شناسایی شده با درایورهای مناسب</li>
<li>از شناسه‌های دستگاه (مانند شناسه‌های PCI/USB) برای این تطبیق استفاده می‌شود</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثالی از ثبت یک درایور PCI در کرنل لینوکس
 * drivers/example/example_driver.c
 */</span>

<span class="hljs-comment">/* جدول شناسه‌های PCI پشتیبانی شده توسط این درایور */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> pci_device_id example_pci_ids[] = {
    { PCI_DEVICE(<span class="hljs-number">0x1234</span>, <span class="hljs-number">0x5678</span>) }, <span class="hljs-comment">/* Vendor ID 0x1234, Device ID 0x5678 */</span>
    { PCI_DEVICE(<span class="hljs-number">0x1234</span>, <span class="hljs-number">0x9ABC</span>) }, <span class="hljs-comment">/* دستگاه دیگر از همان سازنده */</span>
    { <span class="hljs-number">0</span>, }
};
MODULE_DEVICE_TABLE(pci, example_pci_ids);

<span class="hljs-comment">/* تابع probe که زمانی فراخوانی می‌شود که یک دستگاه سازگار یافت شود */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">example_probe</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *pdev, <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> pci_device_id *id)</span>
</span>{
    <span class="hljs-comment">/* مقداردهی اولیه دستگاه و تخصیص منابع */</span>
    <span class="hljs-comment">/* ... */</span>
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-comment">/* تابع remove که زمانی فراخوانی می‌شود که دستگاه حذف شود */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example_remove</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> pci_dev *pdev)</span>
</span>{
    <span class="hljs-comment">/* آزادسازی منابع و پاکسازی */</span>
    <span class="hljs-comment">/* ... */</span>
}

<span class="hljs-comment">/* عملیات درایور PCI */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> pci_driver example_driver = {
    .name = <span class="hljs-string">"example"</span>,
    .id_table = example_pci_ids,
    .probe = example_probe,
    .remove = example_remove,
    .suspend = example_suspend,    <span class="hljs-comment">/* برای مدیریت انرژی */</span>
    .resume = example_resume,      <span class="hljs-comment">/* برای مدیریت انرژی */</span>
};

<span class="hljs-comment">/* تابع مقداردهی اولیه ماژول */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __<span class="hljs-function">init <span class="hljs-title">example_init</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-comment">/* ثبت درایور PCI */</span>
    <span class="hljs-keyword">return</span> pci_register_driver(&amp;example_driver);
}

<span class="hljs-comment">/* تابع خروج ماژول */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __<span class="hljs-function"><span class="hljs-built_in">exit</span> <span class="hljs-title">example_exit</span><span class="hljs-params">(<span class="hljs-keyword">void</span>)</span>
</span>{
    <span class="hljs-comment">/* لغو ثبت درایور PCI */</span>
    pci_unregister_driver(&amp;example_driver);
}

module_init(example_init);
module_exit(example_exit);

MODULE_AUTHOR(<span class="hljs-string">"Example Author"</span>);
MODULE_DESCRIPTION(<span class="hljs-string">"Example PCI Driver"</span>);
MODULE_LICENSE(<span class="hljs-string">"GPL"</span>);
</code></pre>
<h3 id="hotplug-">hotplug و پشتیبانی از اتصال داغ</h3>
<p>یکی از ویژگی‌های مهم کرنل لینوکس پشتیبانی از hotplug (اتصال داغ) است، که به سیستم‌عامل اجازه می‌دهد دستگاه‌ها را در حین اجرا اضافه یا حذف کند، بدون نیاز به راه‌اندازی مجدد. این قابلیت برای فناوری‌هایی مانند USB، PCIe و SATA که اتصال و جدا کردن سخت‌افزار در حین کار را پشتیبانی می‌کنند، ضروری است.</p>
<p><strong>سیستم hotplug لینوکس:</strong></p>
<ol>
<li><p><strong>شناسایی دستگاه</strong>:</p>
<ul>
<li>وقتی یک دستگاه متصل می‌شود، کرنل به طور خودکار آن را شناسایی می‌کند</li>
<li>اطلاعات دستگاه از طریق baس های سیستم (مانند USB، PCI) جمع‌آوری می‌شود</li>
</ul>
</li>
<li><p><strong>تولید رویداد</strong>:</p>
<ul>
<li>کرنل یک رویداد uevent تولید می‌کند</li>
<li>این رویداد حاوی اطلاعاتی درباره دستگاه جدید است</li>
</ul>
</li>
<li><p><strong>مدیریت رویداد</strong>:</p>
<ul>
<li>در سیستم‌های مدرن، دیمون udev رویدادها را دریافت و پردازش می‌کند</li>
<li>udev قوانینی را اجرا می‌کند که نحوه پیکربندی دستگاه را مشخص می‌کنند</li>
</ul>
</li>
<li><p><strong>بارگذاری درایور</strong>:</p>
<ul>
<li>بر اساس اطلاعات دستگاه، درایور مناسب بارگذاری می‌شود</li>
<li>از <code>modprobe</code> برای بارگذاری ماژول‌های کرنل استفاده می‌شود</li>
</ul>
</li>
<li><p><strong>ایجاد گره‌های دستگاه</strong>:</p>
<ul>
<li>فایل‌های دستگاه مناسب در <code>/dev</code> ایجاد می‌شوند</li>
<li>مجوزها و مالکیت این فایل‌ها تنظیم می‌شود</li>
</ul>
</li>
<li><p><strong>اعلام به برنامه‌های کاربردی</strong>:</p>
<ul>
<li>سیستم‌هایی مانند D-Bus می‌توانند به برنامه‌های کاربردی اطلاع دهند که دستگاه جدیدی متصل شده است</li>
</ul>
</li>
</ol>
<p><strong>پیاده‌سازی hotplug در درایورها:</strong></p>
<p>درایورها باید برای پشتیبانی از hotplug، توابع خاصی را پیاده‌سازی کنند:</p>
<ul>
<li><strong>probe()</strong>: زمانی فراخوانی می‌شود که یک دستگاه جدید متصل شود</li>
<li><strong>remove()</strong>: زمانی فراخوانی می‌شود که یک دستگاه جدا شود</li>
<li><strong>suspend()/resume()</strong>: برای مدیریت انرژی (به ویژه برای دستگاه‌های قابل حمل)</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثالی از پیاده‌سازی hotplug در یک درایور USB
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> usb_device_id example_usb_ids[] = {
    { USB_DEVICE(<span class="hljs-number">0</span>x1234, <span class="hljs-number">0</span>x5678) }, <span class="hljs-comment">/* Vendor ID 0x1234, Product ID 0x5678 */</span>
    { }
};
MODULE_DEVICE_TABLE(usb, example_usb_ids);

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> example_probe(<span class="hljs-keyword">struct</span> usb_interface *<span class="hljs-keyword">interface</span>, 
                         <span class="hljs-keyword">const</span> <span class="hljs-keyword">struct</span> usb_device_id *id)
{
    <span class="hljs-keyword">struct</span> example_device *dev;

    <span class="hljs-comment">/* تخصیص ساختار داده دستگاه */</span>
    dev = kzalloc(sizeof(*dev), GFP_KERNEL);
    <span class="hljs-keyword">if</span> (!dev)
        <span class="hljs-keyword">return</span> -ENOMEM;

    <span class="hljs-comment">/* مقداردهی اولیه دستگاه */</span>
    dev-&gt;udev = usb_get_dev(interface_to_usbdev(<span class="hljs-keyword">interface</span>));
    dev-&gt;<span class="hljs-keyword">interface</span> = <span class="hljs-keyword">interface</span>;

    <span class="hljs-comment">/* ذخیره اشاره‌گر به داده‌های خصوصی */</span>
    usb_set_intfdata(<span class="hljs-keyword">interface</span>, dev);

    <span class="hljs-comment">/* ثبت دستگاه کاراکتری */</span>
    <span class="hljs-keyword">if</span> (register_example_device(dev) &lt; <span class="hljs-number">0</span>) {
        kfree(dev);
        <span class="hljs-keyword">return</span> -ENODEV;
    }

    dev_info(&amp;<span class="hljs-keyword">interface</span>-&gt;dev, <span class="hljs-string">"USB Example device connected\n"</span>);
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> example_disconnect(<span class="hljs-keyword">struct</span> usb_interface *<span class="hljs-keyword">interface</span>)
{
    <span class="hljs-keyword">struct</span> example_device *dev;

    <span class="hljs-comment">/* بازیابی داده‌های خصوصی */</span>
    dev = usb_get_intfdata(<span class="hljs-keyword">interface</span>);

    <span class="hljs-comment">/* حذف دستگاه از سیستم */</span>
    unregister_example_device(dev);

    <span class="hljs-comment">/* پاکسازی */</span>
    usb_set_intfdata(<span class="hljs-keyword">interface</span>, NULL);
    usb_put_dev(dev-&gt;udev);
    kfree(dev);

    dev_info(&amp;<span class="hljs-keyword">interface</span>-&gt;dev, <span class="hljs-string">"USB Example device disconnected\n"</span>);
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">struct</span> usb_driver example_driver = {
    .name = <span class="hljs-string">"example"</span>,
    .id_table = example_usb_ids,
    .probe = example_probe,
    .disconnect = example_disconnect,
};

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> __init example_init(<span class="hljs-keyword">void</span>)
{
    <span class="hljs-keyword">return</span> usb_register(&amp;example_driver);
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> __exit example_exit(<span class="hljs-keyword">void</span>)
{
    usb_deregister(&amp;example_driver);
}

module_init(example_init);
module_exit(example_exit);
</code></pre>
<h3 id="-">مدیریت انرژی</h3>
<p>مدیریت انرژی یک جنبه مهم از کرنل لینوکس، به ویژه برای دستگاه‌های قابل حمل است. کرنل لینوکس از چندین مکانیزم برای کاهش مصرف انرژی استفاده می‌کند:</p>
<p><strong>1. ACPI (Advanced Configuration and Power Interface):</strong></p>
<ul>
<li>استاندارد صنعتی برای مدیریت انرژی و پیکربندی</li>
<li>لینوکس یک پیاده‌سازی کامل از ACPI دارد</li>
<li>پشتیبانی از حالت‌های مختلف خواب سیستم (S0 تا S5)</li>
<li>مدیریت حرارتی و کنترل فن</li>
</ul>
<p><strong>2. CPUFreq:</strong></p>
<ul>
<li>چارچوب مدیریت فرکانس و ولتاژ پردازنده</li>
<li>اجازه می‌دهد فرکانس پردازنده بر اساس بار سیستم تغییر کند</li>
<li>فرمانرواهای مختلف (governors) برای استراتژی‌های مختلف:<ul>
<li><strong>performance</strong>: حداکثر فرکانس</li>
<li><strong>powersave</strong>: حداقل فرکانس</li>
<li><strong>ondemand</strong>: تنظیم فرکانس بر اساس استفاده از CPU</li>
<li><strong>conservative</strong>: مشابه ondemand اما با تغییرات تدریجی‌تر</li>
<li><strong>schedutil</strong>: استفاده از اطلاعات زمانبند برای تصمیم‌گیری</li>
</ul>
</li>
</ul>
<p><strong>3. CPUIdle:</strong></p>
<ul>
<li>مدیریت حالت‌های بیکاری (idle) پردازنده</li>
<li>انتخاب حالت بیکاری مناسب بر اساس الگوی کاری و زمان پیش‌بینی شده تا رویداد بعدی</li>
<li>پشتیبانی از حالت‌های عمیق بیکاری با مصرف کمتر انرژی</li>
</ul>
<p><strong>4. Runtime Power Management:</strong></p>
<ul>
<li>مدیریت انرژی دستگاه‌ها در زمان اجرا</li>
<li>امکان خاموش کردن دستگاه‌هایی که استفاده نمی‌شوند</li>
<li>درایورها باید توابع suspend و resume را پیاده‌سازی کنند</li>
</ul>
<p><strong>5. Suspend to RAM / Disk:</strong></p>
<ul>
<li>ذخیره وضعیت سیستم در RAM (suspend to RAM یا S3)</li>
<li>ذخیره وضعیت سیستم در دیسک (suspend to disk یا S4، همچنین hibernate نامیده می‌شود)</li>
<li>فرآیند منظم خاموش کردن و روشن کردن مجدد دستگاه‌ها</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثالی از پیاده‌سازی مدیریت انرژی در یک درایور
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> example_suspend(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span></span> *dev)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_device</span></span> *example_dev = dev_get_drvdata(dev);

    <span class="hljs-comment">/* ذخیره وضعیت دستگاه */</span>
    example_dev-&gt;saved_state = example_read_device_state(example_dev);

    <span class="hljs-comment">/* خاموش کردن دستگاه */</span>
    example_disable_device(example_dev);

    <span class="hljs-comment">/* قطع وقفه‌ها */</span>
    <span class="hljs-keyword">if</span> (example_dev-&gt;irq)
        disable_irq(example_dev-&gt;irq);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> example_resume(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">device</span></span> *dev)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">example_device</span></span> *example_dev = dev_get_drvdata(dev);

    <span class="hljs-comment">/* فعال کردن وقفه‌ها */</span>
    <span class="hljs-keyword">if</span> (example_dev-&gt;irq)
        enable_irq(example_dev-&gt;irq);

    <span class="hljs-comment">/* روشن کردن دستگاه */</span>
    example_enable_device(example_dev);

    <span class="hljs-comment">/* بازیابی وضعیت دستگاه */</span>
    example_write_device_state(example_dev, example_dev-&gt;saved_state);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}

<span class="hljs-keyword">static</span> <span class="hljs-keyword">const</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">dev_pm_ops</span></span> example_pm_ops = {
    .suspend = example_suspend,
    .resume = example_resume,
    .runtime_suspend = example_runtime_suspend,
    .runtime_resume = example_runtime_resume,
    .runtime_idle = example_runtime_idle,
};

<span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">pci_driver</span></span> example_driver = {
    .name = <span class="hljs-string">"example"</span>,
    .id_table = example_pci_ids,
    .probe = example_probe,
    .remove = example_remove,
    .driver = {
        .pm = &amp;example_pm_ops,
    },
};
</code></pre>
<h3 id="-">درایورهای گرافیکی</h3>
<p>درایورهای گرافیکی در لینوکس یکی از پیچیده‌ترین انواع درایورها هستند. برای مدیریت کارت‌های گرافیکی مدرن، لینوکس از چندین زیرسیستم استفاده می‌کند:</p>
<p><strong>1. DRM (Direct Rendering Manager):</strong></p>
<ul>
<li>زیرسیستم اصلی کرنل برای مدیریت کارت‌های گرافیکی</li>
<li>فراهم کردن دسترسی کنترل شده به قابلیت‌های شتاب‌دهنده گرافیکی</li>
<li>مدیریت منابع مانند حافظه ویدئویی و موتورهای رندر</li>
</ul>
<p><strong>2. KMS (Kernel Mode Setting):</strong></p>
<ul>
<li>بخشی از DRM برای تنظیم مد نمایش (رزولوشن، عمق رنگ و غیره)</li>
<li>کنترل مستقیم نمایشگر توسط کرنل به جای فضای کاربر</li>
<li>پشتیبانی از hotplug نمایشگر و پیکربندی چندین نمایشگر</li>
</ul>
<p><strong>3. GEM (Graphics Execution Manager):</strong></p>
<ul>
<li>مدیریت حافظه برای اشیاء گرافیکی</li>
<li>اشتراک‌گذاری بافرهای گرافیکی بین برنامه‌های مختلف</li>
</ul>
<p><strong>4. TTM (Translation Table Maps):</strong></p>
<ul>
<li>مدیریت حافظه گرافیکی پیشرفته</li>
<li>استفاده شده توسط درایورهای AMD و Nouveau</li>
</ul>
<p><strong>5. Framebuffer:</strong></p>
<ul>
<li>واسط ساده‌تر و قدیمی‌تر برای دسترسی به بافر فریم</li>
<li>همچنان برای سیستم‌های نهفته و بوت استفاده می‌شود</li>
</ul>
<p><strong>واسط‌های فضای کاربر:</strong></p>
<ul>
<li><strong>X.Org</strong>: سیستم پنجره سنتی لینوکس</li>
<li><strong>Wayland</strong>: سیستم ترکیب کننده جدیدتر</li>
<li><strong>Mesa</strong>: پیاده‌سازی متن‌باز OpenGL، Vulkan و دیگر APIهای گرافیکی</li>
</ul>
<p><strong>درایورهای گرافیکی اصلی در لینوکس:</strong></p>
<ul>
<li><strong>Intel i915</strong>: برای GPUهای داخلی Intel</li>
<li><strong>AMD (amdgpu)</strong>: برای GPUهای جدیدتر AMD</li>
<li><strong>NVIDIA (nouveau)</strong>: درایور متن‌باز برای کارت‌های NVIDIA</li>
<li><strong>NVIDIA (proprietary)</strong>: درایور اختصاصی NVIDIA (از طریق DKMS)</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثالی از بخش‌های یک درایور DRM
 * (بسیار ساده‌سازی شده)
 */</span>

<span class="hljs-comment">/* مقداردهی اولیه درایور DRM */</span>
static int example_drm_init(struct drm_device *dev)
{
    int <span class="hljs-keyword">ret</span>;

    <span class="hljs-comment">/* تنظیم قابلیت‌های DRM */</span>
    <span class="hljs-keyword">ret</span> = drmm_mode_config_init(dev);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;

    <span class="hljs-comment">/* مقداردهی اولیه موتورهای نمایش */</span>
    <span class="hljs-keyword">ret</span> = example_display_init(dev);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;

    <span class="hljs-comment">/* مقداردهی اولیه موتورهای رندر */</span>
    <span class="hljs-keyword">ret</span> = example_render_init(dev);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;

    <span class="hljs-comment">/* ثبت اشیاء KMS (نمایشگرها، کانکتورها، انکودرها و غیره) */</span>
    <span class="hljs-keyword">ret</span> = example_modeset_init(dev);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;

    <span class="hljs-comment">/* ثبت درایور DRM */</span>
    <span class="hljs-keyword">ret</span> = drm_dev_register(dev, 0);
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">ret</span>)
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">ret</span>;

    <span class="hljs-keyword">return</span> 0;
}

<span class="hljs-comment">/* عملیات درایور DRM */</span>
static <span class="hljs-keyword">const</span> struct drm_driver example_drm_driver = {
    .driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_RENDER,
    .dumb_create = example_dumb_create,      <span class="hljs-comment">/* برای framebuffer ساده */</span>
    .dumb_map_offset = example_dumb_map_offset,
    .dumb_destroy = example_dumb_destroy,
    .gem_free_object_unlocked = example_gem_free_object,
    .gem_vm_ops = &amp;example_gem_vm_ops,
    .fops = &amp;example_drm_fops,
    .name = <span class="hljs-string">"example"</span>,
    .<span class="hljs-keyword">desc</span> = <span class="hljs-string">"Example Graphics Driver"</span>,
    .date = <span class="hljs-string">"20230601"</span>,
    .major = 1,
    .minor = 0,
};
</code></pre>
<h3 id="-">تعامل با سخت‌افزار</h3>
<p>درایورهای دستگاه در لینوکس باید با سخت‌افزار واقعی تعامل داشته باشند. کرنل لینوکس چندین راه برای این تعامل فراهم می‌کند:</p>
<p><strong>1. دسترسی به پورت I/O:</strong></p>
<ul>
<li>برای دستگاه‌های قدیمی‌تر که از فضای پورت I/O استفاده می‌کنند</li>
<li>توابع <code>inb()</code>, <code>outb()</code>, <code>inw()</code>, <code>outw()</code>, <code>inl()</code>, <code>outl()</code> برای خواندن و نوشتن در پورت‌ها</li>
<li>نیاز به درخواست مجوز برای دسترسی به پورت‌ها با <code>request_region()</code></li>
</ul>
<p><strong>2. نگاشت حافظه I/O (MMIO):</strong></p>
<ul>
<li>دستگاه‌های مدرن‌تر معمولاً از MMIO استفاده می‌کنند</li>
<li>نگاشت رجیسترهای سخت‌افزاری به فضای آدرس حافظه</li>
<li>استفاده از <code>ioremap()</code> برای نگاشت آدرس‌های فیزیکی به فضای آدرس کرنل</li>
<li>استفاده از <code>readb()</code>, <code>writeb()</code>, <code>readw()</code>, <code>writew()</code>, <code>readl()</code>, <code>writel()</code> برای دسترسی به رجیسترها</li>
</ul>
<p><strong>3. DMA (Direct Memory Access):</strong></p>
<ul>
<li>برای انتقال داده‌های بزرگ بین دستگاه و حافظه اصلی</li>
<li>انتقال داده بدون درگیر کردن CPU</li>
<li>استفاده از API های DMA کرنل مانند <code>dma_alloc_coherent()</code>, <code>dma_map_single()</code></li>
<li>مدیریت همدوسی کش (cache coherency)</li>
</ul>
<p><strong>4. وقفه‌ها (Interrupts):</strong></p>
<ul>
<li>مکانیزمی برای دستگاه‌ها تا به کرنل اطلاع دهند که رویدادی رخ داده است</li>
<li>استفاده از <code>request_irq()</code> برای ثبت یک روتین وقفه</li>
<li>پیاده‌سازی یک تابع مدیریت وقفه (IRQ handler)</li>
</ul>
<p><strong>5. نخ‌های کرنل (Kernel Threads):</strong></p>
<ul>
<li>برای انجام وظایف پس‌زمینه در درایور</li>
<li>ایجاد با <code>kthread_create()</code> و شروع با <code>wake_up_process()</code></li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثال‌هایی از روش‌های مختلف تعامل با سخت‌افزار
 */</span>

<span class="hljs-comment">/* دسترسی به پورت I/O */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example_io_port_access</span>(<span class="hljs-params"><span class="hljs-keyword">void</span></span>)
</span>{
    unsigned <span class="hljs-keyword">long</span> <span class="hljs-keyword">base</span> = <span class="hljs-number">0x378</span>;  <span class="hljs-comment">/* آدرس پورت پارالل استاندارد */</span>

    <span class="hljs-comment">/* درخواست مجوز برای استفاده از پورت‌ها */</span>
    <span class="hljs-keyword">if</span> (!request_region(<span class="hljs-keyword">base</span>, <span class="hljs-number">3</span>, <span class="hljs-string">"example_driver"</span>)) {
        pr_err(<span class="hljs-string">"Cannot request I/O ports\n"</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">/* نوشتن داده به پورت داده */</span>
    outb(<span class="hljs-number">0x55</span>, <span class="hljs-keyword">base</span>);

    <span class="hljs-comment">/* خواندن از پورت وضعیت */</span>
    unsigned <span class="hljs-keyword">char</span> status = inb(<span class="hljs-keyword">base</span> + <span class="hljs-number">1</span>);

    <span class="hljs-comment">/* آزاد کردن پورت‌ها */</span>
    release_region(<span class="hljs-keyword">base</span>, <span class="hljs-number">3</span>);
}

<span class="hljs-comment">/* نگاشت حافظه I/O */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example_mmio_access</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> pci_dev *pdev</span>)
</span>{
    <span class="hljs-keyword">void</span> __iomem *mmio_base;
    resource_size_t mmio_start, mmio_len;
    u32 <span class="hljs-keyword">value</span>;

    <span class="hljs-comment">/* یافتن منابع MMIO در دستگاه PCI */</span>
    mmio_start = pci_resource_start(pdev, <span class="hljs-number">0</span>);
    mmio_len = pci_resource_len(pdev, <span class="hljs-number">0</span>);

    <span class="hljs-comment">/* درخواست مجوز برای دسترسی به منابع */</span>
    <span class="hljs-keyword">if</span> (!request_mem_region(mmio_start, mmio_len, <span class="hljs-string">"example_driver"</span>)) {
        pr_err(<span class="hljs-string">"Cannot request MMIO region\n"</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">/* نگاشت منابع فیزیکی به فضای آدرس کرنل */</span>
    mmio_base = ioremap(mmio_start, mmio_len);
    <span class="hljs-keyword">if</span> (!mmio_base) {
        pr_err(<span class="hljs-string">"Cannot map MMIO region\n"</span>);
        release_mem_region(mmio_start, mmio_len);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">/* خواندن از رجیستر */</span>
    <span class="hljs-keyword">value</span> = readl(mmio_base + <span class="hljs-number">0x10</span>);

    <span class="hljs-comment">/* نوشتن به رجیستر */</span>
    writel(<span class="hljs-number">0x1234</span>, mmio_base + <span class="hljs-number">0x14</span>);

    <span class="hljs-comment">/* پاکسازی */</span>
    iounmap(mmio_base);
    release_mem_region(mmio_start, mmio_len);
}

<span class="hljs-comment">/* استفاده از DMA */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">example_dma_setup</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> pci_dev *pdev</span>)
</span>{
    dma_addr_t dma_handle;
    size_t size = <span class="hljs-number">4096</span>;  <span class="hljs-comment">/* اندازه بافر 4KB */</span>
    <span class="hljs-keyword">void</span> *cpu_addr;

    <span class="hljs-comment">/* تخصیص بافر DMA */</span>
    cpu_addr = dma_alloc_coherent(&amp;pdev-&gt;dev, size, &amp;dma_handle, GFP_KERNEL);
    <span class="hljs-keyword">if</span> (!cpu_addr) {
        pr_err(<span class="hljs-string">"Failed to allocate DMA buffer\n"</span>);
        <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-comment">/* پر کردن بافر با داده */</span>
    memset(cpu_addr, <span class="hljs-number">0</span>, size);

    <span class="hljs-comment">/* تنظیم دستگاه برای استفاده از آدرس DMA */</span>
    writel((u32)dma_handle, mmio_base + DMA_ADDR_REG);
    writel(size, mmio_base + DMA_SIZE_REG);

    <span class="hljs-comment">/* شروع انتقال DMA */</span>
    writel(DMA_START_BIT, mmio_base + DMA_CONTROL_REG);

    <span class="hljs-comment">/* آزادسازی بافر در زمان مناسب */</span>
    dma_free_coherent(&amp;pdev-&gt;dev, size, cpu_addr, dma_handle);
}

<span class="hljs-comment">/* مدیریت وقفه‌ها */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> irqreturn_t <span class="hljs-title">example_irq_handler</span>(<span class="hljs-params"><span class="hljs-keyword">int</span> irq, <span class="hljs-keyword">void</span> *dev_id</span>)
</span>{
    <span class="hljs-keyword">struct</span> example_device *dev = dev_id;
    u32 status;

    <span class="hljs-comment">/* خواندن رجیستر وضعیت وقفه */</span>
    status = readl(dev-&gt;mmio_base + IRQ_STATUS_REG);

    <span class="hljs-comment">/* اگر این وقفه برای این دستگاه نیست */</span>
    <span class="hljs-keyword">if</span> (!(status &amp; IRQ_ACTIVE_BIT))
        <span class="hljs-keyword">return</span> IRQ_NONE;

    <span class="hljs-comment">/* پردازش وقفه */</span>
    <span class="hljs-keyword">if</span> (status &amp; DATA_READY_BIT)
        example_process_data(dev);

    <span class="hljs-comment">/* پاک کردن وقفه */</span>
    writel(status, dev-&gt;mmio_base + IRQ_CLEAR_REG);

    <span class="hljs-keyword">return</span> IRQ_HANDLED;
}

<span class="hljs-comment">/* ثبت روتین وقفه */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">example_setup_irq</span>(<span class="hljs-params"><span class="hljs-keyword">struct</span> example_device *dev</span>)
</span>{
    <span class="hljs-keyword">int</span> ret;

    ret = request_irq(dev-&gt;irq, example_irq_handler,
                     IRQF_SHARED, <span class="hljs-string">"example_driver"</span>, dev);
    <span class="hljs-keyword">if</span> (ret) {
        pr_err(<span class="hljs-string">"Failed to request IRQ %d\n"</span>, dev-&gt;irq);
        <span class="hljs-keyword">return</span> ret;
    }

    <span class="hljs-comment">/* فعال کردن وقفه‌ها در دستگاه */</span>
    writel(IRQ_ENABLE_BIT, dev-&gt;mmio_base + IRQ_CONTROL_REG);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;
}
</code></pre>
<p>کرنل لینوکس همچنین از سیستم‌های باس متنوعی پشتیبانی می‌کند:</p>
<ul>
<li><strong>PCI و PCIe</strong>: برای کارت‌های توسعه و اجزای داخلی</li>
<li><strong>USB</strong>: برای دستگاه‌های خارجی</li>
<li><strong>I2C</strong>: برای ارتباط با حسگرها و دیگر دستگاه‌های کم‌سرعت</li>
<li><strong>SPI</strong>: برای ارتباط سریال مزیت</li>
<li><strong>GPIO</strong>: برای خطوط ورودی/خروجی دیجیتال ساده</li>
</ul>
<p>هر سیستم باس API خاص خود را برای تعامل با دستگاه‌های روی آن باس ارائه می‌دهد.</p>
<p>مدیریت دستگاه‌ها در لینوکس یک زیرسیستم پیچیده و انعطاف‌پذیر است که امکان پشتیبانی از طیف گسترده‌ای از سخت‌افزارها را فراهم می‌کند. مدل درایور ماژولار، سیستم‌های فایل دستگاه، پشتیبانی از hotplug، مدیریت انرژی و رابط‌های متعدد برای تعامل با سخت‌افزار، همگی به توسعه آسان و کارآمد درایورها کمک می‌کنند. این معماری به لینوکس اجازه می‌دهد تا به طور مداوم با فناوری‌های سخت‌افزاری جدید سازگار شود و در انواع مختلف دستگاه‌ها از سیستم‌های نهفته گرفته تا ابررایانه‌ها استفاده شود.</p>
<h2 id="-">امنیت در کرنل لینوکس</h2>
<p>امنیت یکی از جنبه‌های حیاتی هر سیستم‌عامل است و کرنل لینوکس به عنوان هسته اصلی یک سیستم‌عامل، نقش مهمی در تأمین امنیت کل سیستم دارد. این بخش به بررسی مکانیزم‌های امنیتی پیاده‌سازی شده در کرنل لینوکس می‌پردازد.</p>
<h3 id="-">مدل امنیتی لینوکس</h3>
<p>مدل امنیتی پایه لینوکس بر مبنای سیستم مجوزها و کنترل دسترسی یونیکس است که با گذشت زمان، ویژگی‌های پیشرفته‌تری به آن اضافه شده است. این مدل از چندین لایه حفاظتی تشکیل شده است:</p>
<ol>
<li><p><strong>مجوزهای فایل</strong>: سیستم کلاسیک مجوزهای فایل یونیکس (read, write, execute) برای سه سطح (مالک، گروه و دیگران).</p>
</li>
<li><p><strong>جداسازی فضای کاربر و کرنل</strong>: تفکیک فضای کاربر از فضای کرنل که اجازه نمی‌دهد برنامه‌های کاربردی مستقیماً به منابع سیستم دسترسی پیدا کنند.</p>
</li>
<li><p><strong>مجوزهای فایل توسعه‌یافته (ACL)</strong>: امکان تعریف مجوزهای دقیق‌تر برای فایل‌ها بیش از مدل ساده read-write-execute.</p>
</li>
<li><p><strong>قابلیت‌ها (Capabilities)</strong>: تقسیم امتیازات سوپریوزر (root) به قابلیت‌های مجزا که می‌توانند به صورت جداگانه اعطا شوند.</p>
</li>
<li><p><strong>چارچوب‌های امنیتی ماژولار</strong>: مانند SELinux و AppArmor که کنترل دسترسی بیشتری نسبت به سیستم مجوزهای سنتی ارائه می‌دهند.</p>
</li>
<li><p><strong>مکانیزم‌های جداسازی</strong>: از جمله فضاهای نام (namespaces) و گروه‌های کنترل (cgroups) که امکان ایزوله کردن منابع سیستم را فراهم می‌کنند.</p>
</li>
<li><p><strong>هاردنینگ کرنل</strong>: مجموعه‌ای از تکنیک‌ها برای افزایش مقاومت کرنل در برابر سوءاستفاده‌ها.</p>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از بررسی مجوز فایل در کرنل لینوکس
 * fs/namei.c
 */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">inline</span> <span class="hljs-keyword">int</span> <span class="hljs-title">do_inode_permission</span><span class="hljs-params">(<span class="hljs-keyword">struct</span> inode *inode, <span class="hljs-keyword">int</span> mask)</span>
</span>{
    <span class="hljs-comment">/* بررسی مجوزهای پایه */</span>
    <span class="hljs-keyword">if</span> (inode_permission(inode, mask))
        <span class="hljs-keyword">return</span> -EACCES;

    <span class="hljs-comment">/* بررسی ACL در صورت فعال بودن */</span>
    <span class="hljs-keyword">if</span> (IS_POSIXACL(inode) &amp;&amp; (mask &amp; MAY_WRITE)) {
        <span class="hljs-keyword">struct</span> posix_acl *acl;

        acl = get_acl(inode, ACL_TYPE_ACCESS);
        <span class="hljs-keyword">if</span> (IS_ERR(acl))
            <span class="hljs-keyword">return</span> PTR_ERR(acl);
        <span class="hljs-keyword">if</span> (acl) {
            <span class="hljs-keyword">int</span> ret = posix_acl_permission(inode, acl, mask);
            posix_acl_release(acl);
            <span class="hljs-keyword">if</span> (ret != <span class="hljs-number">0</span>)
                <span class="hljs-keyword">return</span> ret;
        }
    }

    <span class="hljs-keyword">return</span> security_inode_permission(inode, mask);
}
</code></pre>
<h3 id="selinux-apparmor">SELinux و AppArmor</h3>
<p>کرنل لینوکس از چندین چارچوب کنترل دسترسی الزامی (Mandatory Access Control - MAC) پشتیبانی می‌کند که شناخته‌شده‌ترین آنها SELinux و AppArmor هستند. این سیستم‌ها لایه امنیتی اضافی فراتر از کنترل دسترسی استاندارد یونیکس فراهم می‌کنند.</p>
<p><strong>SELinux (Security-Enhanced Linux):</strong></p>
<ul>
<li>توسط آژانس امنیت ملی آمریکا (NSA) طراحی شده و در کرنل لینوکس ادغام شده است.</li>
<li>مبتنی بر کنترل دسترسی بر اساس نوع (Type Enforcement) است.</li>
<li>هر فرآیند و شیء سیستمی دارای یک برچسب امنیتی (security context) است.</li>
<li>قوانین امنیتی مشخص می‌کنند کدام فرآیند با چه برچسبی می‌تواند به کدام شیء با چه برچسبی دسترسی داشته باشد.</li>
<li>پیکربندی پیچیده‌تر اما انعطاف‌پذیرتر نسبت به AppArmor دارد.</li>
</ul>
<p><strong>AppArmor (Application Armor):</strong></p>
<ul>
<li>رویکرد ساده‌تری نسبت به SELinux دارد که بر اساس مسیر فایل‌ها عمل می‌کند.</li>
<li>به جای برچسب‌گذاری، از مشخصات (profiles) استفاده می‌کند که تعیین می‌کنند یک برنامه به چه فایل‌هایی می‌تواند دسترسی داشته باشد.</li>
<li>نصب و پیکربندی آسان‌تر و یادگیری ساده‌تر از SELinux دارد.</li>
<li>در توزیع‌هایی مانند اوبونتو به طور پیش‌فرض استفاده می‌شود.</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از هوک امنیتی SELinux در کرنل
 * security/selinux/hooks.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> selinux_file_permission(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file</span></span> *file, <span class="hljs-keyword">int</span> mask)
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode</span></span> *inode = file_inode(file);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">common_audit_data</span></span> ad;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">selinux_audit_data</span></span> sad = {<span class="hljs-number">0</span>};
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">file_security_struct</span></span> *fsec = file-&gt;f_security;
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">inode_security_struct</span></span> *isec = inode-&gt;i_security;
    <span class="hljs-keyword">u32</span> sid = fsec-&gt;sid;
    <span class="hljs-keyword">u32</span> osid = isec-&gt;sid;

    ad.<span class="hljs-keyword">type</span> = LSM_AUDIT_DATA_PATH;
    ad.u.path = file-&gt;f_path;
    ad.selinux_audit_data = &amp;sad;

    <span class="hljs-comment">/* بررسی سیاست‌های SELinux */</span>
    <span class="hljs-keyword">return</span> avc_has_perm(sid, osid, isec-&gt;sclass, file_mask_to_av(mask),
                        &amp;ad);
}
</code></pre>
<h3 id="-">مجوزها و کنترل دسترسی</h3>
<p>مجوزها و کنترل دسترسی در لینوکس شامل چندین مکانیزم برای محدود کردن دسترسی فرآیندها به منابع سیستم است:</p>
<p><strong>1. مجوزهای فایل سنتی:</strong></p>
<ul>
<li>سه نوع مجوز: خواندن (r)، نوشتن (w) و اجرا (x).</li>
<li>سه سطح دسترسی: مالک (owner)، گروه (group) و دیگران (others).</li>
<li>پیاده‌سازی ساده با استفاده از 9 بیت برای هر فایل.</li>
</ul>
<p><strong>2. لیست کنترل دسترسی (ACL):</strong></p>
<ul>
<li>گسترش سیستم مجوزهای سنتی.</li>
<li>امکان تعیین مجوزهای خاص برای کاربران و گروه‌های مشخص.</li>
<li>پیاده‌سازی شده از طریق ویژگی‌های توسعه‌یافته فایل (extended attributes).</li>
</ul>
<p><strong>3. قابلیت‌ها (Capabilities):</strong></p>
<ul>
<li>تقسیم امتیازات مدیر سیستم (root) به واحدهای کوچکتر.</li>
<li>اجازه می‌دهد برنامه‌ها با حداقل امتیازات لازم اجرا شوند.</li>
<li>مثال‌هایی از قابلیت‌ها: CAP_NET_ADMIN (مدیریت شبکه)، CAP_SYS_ADMIN (عملیات مدیریت سیستم)، CAP_CHOWN (تغییر مالکیت فایل‌ها).</li>
</ul>
<p><strong>4. Seccomp (Secure Computing Mode):</strong></p>
<ul>
<li>محدود کردن فراخوانی‌های سیستمی قابل استفاده توسط یک فرآیند.</li>
<li>می‌تواند در حالت فیلتر باشد، که اجازه می‌دهد مجموعه خاصی از فراخوانی‌های سیستمی مجاز باشند.</li>
<li>بسیار مفید برای برنامه‌هایی که در معرض خطر هستند، مانند مرورگرها.</li>
</ul>
<p><strong>5. کنترل دسترسی مبتنی بر نقش (RBAC):</strong></p>
<ul>
<li>تعریف دسترسی‌ها بر اساس نقش‌های کاربران.</li>
<li>پیاده‌سازی از طریق چارچوب‌هایی مانند SELinux.</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از استفاده از seccomp در کرنل لینوکس
 * kernel/seccomp.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> seccomp_check_filter(<span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seccomp_filter</span></span> *filter,
                               <span class="hljs-keyword">int</span> syscall, unsigned long args[<span class="hljs-number">6</span>])
{
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">sock_filter</span></span> *bpf_instructions = filter-&gt;prog-&gt;insns;
    unsigned <span class="hljs-keyword">int</span> bpf_program_length = filter-&gt;prog-&gt;len;

    <span class="hljs-comment">/* اجرای برنامه BPF برای بررسی مجاز بودن فراخوانی سیستمی */</span>
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">seccomp_data</span></span> data = {
        .nr = syscall,
        .arch = AUDIT_ARCH,
        .instruction_pointer = KSTK_EIP(current),
        .args = {args[<span class="hljs-number">0</span>], args[<span class="hljs-number">1</span>], args[<span class="hljs-number">2</span>], args[<span class="hljs-number">3</span>], args[<span class="hljs-number">4</span>], args[<span class="hljs-number">5</span>]}
    };

    <span class="hljs-keyword">return</span> bpf_run_prog(filter-&gt;prog, &amp;data);
}
</code></pre>
<h3 id="-">فضای‌های نام و کانتینرها</h3>
<p>فضاهای نام (namespaces) و کانتینرها یکی از ابزارهای قدرتمند امنیتی در لینوکس مدرن هستند که امکان ایزوله کردن فرآیندها و محدود کردن دسترسی آنها به منابع سیستم را فراهم می‌کنند.</p>
<p><strong>فضاهای نام (Namespaces):</strong>
فضاهای نام به لینوکس اجازه می‌دهند دید فرآیندها از سیستم را ایزوله کند. انواع مختلف فضاهای نام عبارتند از:</p>
<ol>
<li><strong>Mount (mnt)</strong>: ایزوله کردن نقاط نصب و ساختار سیستم فایل.</li>
<li><strong>UTS</strong>: ایزوله کردن hostname و domainname.</li>
<li><strong>IPC</strong>: ایزوله کردن منابع ارتباطات بین فرآیندی.</li>
<li><strong>PID</strong>: ایزوله کردن فضای شناسه فرآیندها.</li>
<li><strong>Network (net)</strong>: ایزوله کردن منابع شبکه.</li>
<li><strong>User</strong>: ایزوله کردن شناسه‌های کاربران و گروه‌ها.</li>
<li><strong>Cgroup</strong>: ایزوله کردن دید فرآیند از cgroup root directory.</li>
<li><strong>Time</strong>: ایزوله کردن ساعت سیستم برای فرآیندها.</li>
</ol>
<p><strong>کانتینرها (Containers):</strong>
کانتینرها از فضاهای نام و cgroups استفاده می‌کنند تا محیط‌های اجرایی ایزوله ایجاد کنند. مزایای امنیتی کانتینرها:</p>
<ul>
<li><strong>جداسازی</strong>: برنامه‌ها در کانتینرها نمی‌توانند مستقیماً با سیستم میزبان یا سایر کانتینرها تعامل داشته باشند.</li>
<li><strong>محدودیت منابع</strong>: کانتینرها می‌توانند به مقدار مشخصی از CPU، حافظه و سایر منابع محدود شوند.</li>
<li><strong>Immutability</strong>: کانتینرها معمولاً تغییرناپذیر هستند، که ریسک دستکاری را کاهش می‌دهد.</li>
<li><strong>اصل حداقل دسترسی</strong>: کانتینرها معمولاً تنها با حداقل قابلیت‌ها و دسترسی‌های لازم اجرا می‌شوند.</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * ایجاد فضای نام جدید در کرنل لینوکس
 * kernel/nsproxy.c
 */</span>
<span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> clone_namespaces(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> flags, <span class="hljs-keyword">struct</span> task_struct *tsk)
{
    <span class="hljs-keyword">struct</span> nsproxy *old_ns = tsk-&gt;nsproxy;
    <span class="hljs-keyword">struct</span> nsproxy *new_ns;
    <span class="hljs-keyword">int</span> err = <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* اگر هیچ فضای نامی درخواست نشده، تغییری ایجاد نکن */</span>
    <span class="hljs-keyword">if</span> (!(flags &amp; (<span class="hljs-built_in">CLONE_NEWNS</span> | <span class="hljs-built_in">CLONE_NEWUTS</span> | <span class="hljs-built_in">CLONE_NEWIPC</span> | <span class="hljs-built_in">CLONE_NEWPID</span> |
                  <span class="hljs-built_in">CLONE_NEWNET</span> | <span class="hljs-built_in">CLONE_NEWCGROUP</span> | <span class="hljs-built_in">CLONE_NEWTIME</span>)))
        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

    <span class="hljs-comment">/* ایجاد یک نمونه جدید از ساختار nsproxy */</span>
    new_ns = create_new_namespaces(flags, tsk, user_ns);
    <span class="hljs-keyword">if</span> (IS_ERR(new_ns))
        <span class="hljs-keyword">return</span> PTR_ERR(new_ns);

    <span class="hljs-comment">/* ایجاد فضاهای نام جدید بر اساس پرچم‌های درخواست شده */</span>
    <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-built_in">CLONE_NEWNS</span>) {
        err = create_mnt_ns(new_ns);
        <span class="hljs-keyword">if</span> (err)
            <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
    }

    <span class="hljs-keyword">if</span> (flags &amp; <span class="hljs-built_in">CLONE_NEWUTS</span>) {
        err = create_uts_ns(new_ns);
        <span class="hljs-keyword">if</span> (err)
            <span class="hljs-keyword">goto</span> <span class="hljs-keyword">out</span>;
    }

    <span class="hljs-comment">/* سایر فضاهای نام به طور مشابه ایجاد می‌شوند */</span>

    <span class="hljs-comment">/* تخصیص فضای نام جدید به فرآیند */</span>
    tsk-&gt;nsproxy = new_ns;
    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

<span class="hljs-keyword">out</span>:
    <span class="hljs-comment">/* پاکسازی در صورت خطا */</span>
    free_nsproxy(new_ns);
    <span class="hljs-keyword">return</span> err;
}
</code></pre>
<h3 id="-">مشکلات امنیتی و وصله‌ها</h3>
<p>در طول تاریخ توسعه کرنل لینوکس، مانند هر نرم‌افزار پیچیده دیگری، مشکلات امنیتی متعددی شناسایی و برطرف شده‌اند. مدیریت مشکلات امنیتی و فرآیند وصله‌گذاری در لینوکس بسیار سازمان‌یافته است.</p>
<p><strong>انواع رایج مشکلات امنیتی در کرنل لینوکس:</strong></p>
<ol>
<li><strong>سرریز بافر (Buffer Overflow)</strong>: دسترسی به خارج از محدوده یک بافر، می‌تواند منجر به اجرای کد دلخواه شود.</li>
<li><strong>شرایط مسابقه (Race Conditions)</strong>: زمانی که نتیجه وابسته به ترتیب رویدادها است و ممکن است به دسترسی غیرمجاز منجر شود.</li>
<li><strong>Use-After-Free</strong>: استفاده از حافظه پس از آزادسازی آن.</li>
<li><strong>کنترل نامناسب دسترسی</strong>: بررسی ناکافی مجوزها قبل از انجام عملیات حساس.</li>
<li><strong>نشت اطلاعات</strong>: افشای داده‌های حساس از کرنل به فضای کاربر.</li>
<li><strong>حملات Denial-of-Service</strong>: مصرف بیش از حد منابع سیستم.</li>
</ol>
<p><strong>فرآیند مدیریت آسیب‌پذیری در کرنل لینوکس:</strong></p>
<ol>
<li><strong>کشف</strong>: آسیب‌پذیری‌ها توسط محققان امنیتی، توسعه‌دهندگان، یا از طریق ابزارهای تحلیل خودکار شناسایی می‌شوند.</li>
<li><strong>گزارش</strong>: آسیب‌پذیری‌ها به تیم امنیتی کرنل لینوکس گزارش می‌شوند.</li>
<li><strong>ارزیابی</strong>: شدت و تأثیر آسیب‌پذیری ارزیابی می‌شود.</li>
<li><strong>توسعه وصله</strong>: یک وصله برای برطرف کردن مشکل توسعه داده می‌شود.</li>
<li><strong>بررسی</strong>: وصله توسط توسعه‌دهندگان دیگر بررسی می‌شود.</li>
<li><strong>تست</strong>: تست‌های جامع برای اطمینان از برطرف شدن مشکل و عدم ایجاد مشکلات جدید.</li>
<li><strong>ادغام</strong>: وصله در کرنل اصلی و همچنین در کرنل‌های با پشتیبانی بلندمدت (LTS) ادغام می‌شود.</li>
<li><strong>اعلان عمومی</strong>: جزئیات آسیب‌پذیری و وصله به صورت عمومی اعلام می‌شود.</li>
</ol>
<p><strong>سیستم CVE (Common Vulnerabilities and Exposures):</strong>
آسیب‌پذیری‌های کرنل لینوکس با شناسه‌های CVE مشخص می‌شوند که به پیگیری و مدیریت آنها کمک می‌کند. برای مثال، CVE-2021-33909 یک آسیب‌پذیری Privilege Escalation در سیستم فایل لینوکس بود.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از یک وصله امنیتی در کرنل لینوکس
 * (اصلاح یک آسیب‌پذیری Use-After-Free فرضی)
 */</span>
<span class="hljs-comment">/* کد آسیب‌پذیر قبلی */</span>
static <span class="hljs-literal">void</span> vulnerable_function(struct example_data *<span class="hljs-built_in">data</span>)
{
    <span class="hljs-comment">/* استفاده از داده */</span>
    process_data(<span class="hljs-built_in">data</span>);

    <span class="hljs-comment">/* آزادسازی داده */</span>
    kfree(<span class="hljs-built_in">data</span>);

    <span class="hljs-comment">/* مشکل: استفاده از data پس از آزادسازی */</span>
    <span class="hljs-keyword">if</span> (need_more_processing())
        more_processing(<span class="hljs-built_in">data</span>);  <span class="hljs-comment">/* Use-After-Free */</span>
}

<span class="hljs-comment">/* کد اصلاح شده */</span>
static <span class="hljs-literal">void</span> fixed_function(struct example_data *<span class="hljs-built_in">data</span>)
{
    <span class="hljs-comment">/* استفاده از داده */</span>
    process_data(<span class="hljs-built_in">data</span>);

    <span class="hljs-comment">/* بررسی نیاز به پردازش بیشتر قبل از آزادسازی */</span>
    <span class="hljs-keyword">if</span> (need_more_processing())
        more_processing(<span class="hljs-built_in">data</span>);

    <span class="hljs-comment">/* آزادسازی داده پس از اتمام تمام استفاده‌ها */</span>
    kfree(<span class="hljs-built_in">data</span>);
}
</code></pre>
<h3 id="-">استراتژی‌های امنیتی</h3>
<p>کرنل لینوکس از استراتژی‌های متعددی برای بهبود امنیت استفاده می‌کند. این استراتژی‌ها شامل اصول طراحی، روش‌های توسعه و ویژگی‌های حفاظتی است.</p>
<p><strong>اصول امنیتی در طراحی کرنل لینوکس:</strong></p>
<ol>
<li><p><strong>اصل حداقل دسترسی (Principle of Least Privilege)</strong>:</p>
<ul>
<li>ارائه حداقل دسترسی لازم برای انجام یک عملیات</li>
<li>استفاده از قابلیت‌ها (capabilities) به جای دسترسی root کامل</li>
<li>محدود کردن دسترسی فرآیندها به منابع سیستم</li>
</ul>
</li>
<li><p><strong>عمق دفاعی (Defense in Depth)</strong>:</p>
<ul>
<li>استفاده از چندین لایه حفاظتی به جای تکیه بر یک مکانیزم واحد</li>
<li>ترکیب مجوزهای فایل، SELinux/AppArmor، قابلیت‌ها، seccomp و غیره</li>
</ul>
</li>
<li><p><strong>شفافیت و بررسی عمومی</strong>:</p>
<ul>
<li>متن‌باز بودن کد امکان بررسی عمومی را فراهم می‌کند</li>
<li>بررسی مداوم کد توسط جامعه توسعه‌دهندگان و محققان امنیتی</li>
</ul>
</li>
<li><p><strong>اصل سادگی</strong>:</p>
<ul>
<li>تلاش برای حفظ سادگی در طراحی و پیاده‌سازی</li>
<li>پیچیدگی بیشتر معمولاً به آسیب‌پذیری‌های بیشتر منجر می‌شود</li>
</ul>
</li>
</ol>
<p><strong>استراتژی‌های فنی:</strong></p>
<ol>
<li><p><strong>مدیریت حافظه امن</strong>:</p>
<ul>
<li>استفاده از تکنیک‌هایی مانند KASLR (Kernel Address Space Layout Randomization)</li>
<li>جداسازی صفحات کرنل و کاربر</li>
<li>محافظت از پشته با canary ها</li>
</ul>
</li>
<li><p><strong>حفاظت از داده‌های حساس</strong>:</p>
<ul>
<li>محدود کردن دسترسی به داده‌های حساس کرنل</li>
<li>پاک کردن حافظه حساس قبل از آزادسازی</li>
<li>استفاده از رمزگذاری برای داده‌های حساس</li>
</ul>
</li>
<li><p><strong>کاهش سطح حمله</strong>:</p>
<ul>
<li>غیرفعال کردن ویژگی‌های غیرضروری در زمان کامپایل</li>
<li>محدود کردن رابط‌های در معرض حمله</li>
<li>استفاده از seccomp برای محدود کردن فراخوانی‌های سیستمی</li>
</ul>
</li>
<li><p><strong>نظارت و گزارش‌دهی</strong>:</p>
<ul>
<li>ثبت رویدادهای امنیتی مهم</li>
<li>ارائه مکانیزم‌هایی برای تشخیص نفوذ</li>
<li>هشدار در مورد فعالیت‌های مشکوک</li>
</ul>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از پیاده‌سازی KASLR در کرنل
 * arch/x86/mm/kaslr.c
 */</span>
<span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> <span class="hljs-title">choose_random_location</span><span class="hljs-params">(<span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> input,
                                         <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> input_size,
                                         <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> output,
                                         <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> output_size)</span>
</span>{
    <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">long</span> random_offset;

    <span class="hljs-comment">/* تولید یک آفست تصادفی در محدوده خروجی */</span>
    random_offset = get_random_u64() % (output_size - input_size);

    <span class="hljs-comment">/* افزودن آفست تصادفی به آدرس پایه */</span>
    <span class="hljs-keyword">return</span> output + random_offset;
}
</code></pre>
<h3 id="-">کرنل هاردنینگ</h3>
<p>هاردنینگ کرنل (Kernel Hardening) به مجموعه‌ای از تکنیک‌ها اشاره دارد که برای تقویت امنیت کرنل لینوکس استفاده می‌شوند. این تکنیک‌ها در سطح کد منبع، کامپایل و پیکربندی اعمال می‌شوند.</p>
<p><strong>هاردنینگ در زمان کامپایل:</strong></p>
<ol>
<li><p><strong>آپشن‌های امنیتی کامپایلر</strong>:</p>
<ul>
<li><strong>-fstack-protector-strong</strong>: افزودن canary ها برای تشخیص سرریز پشته.</li>
<li><strong>-fno-common</strong>: تشخیص متغیرهای تعریف شده چندباره.</li>
<li><strong>-Wall -Werror</strong>: فعال کردن هشدارها و تبدیل آنها به خطا.</li>
<li><strong>-Wextra</strong>: هشدارهای اضافی برای مشکلات بالقوه.</li>
<li><strong>-fpie / -fPIE</strong>: ایجاد کد مستقل از موقعیت برای ASLR.</li>
</ul>
</li>
<li><p><strong>Sanitizers</strong>:</p>
<ul>
<li><strong>KASAN (Kernel Address Sanitizer)</strong>: تشخیص دسترسی‌های خارج از محدوده و use-after-free.</li>
<li><strong>UBSAN (Undefined Behavior Sanitizer)</strong>: تشخیص رفتارهای تعریف نشده.</li>
<li><strong>KMSAN (Kernel Memory Sanitizer)</strong>: تشخیص استفاده از متغیرهای مقداردهی نشده.</li>
</ul>
</li>
</ol>
<p><strong>ویژگی‌های هاردنینگ کرنل:</strong></p>
<ol>
<li><p><strong>KASLR (Kernel Address Space Layout Randomization)</strong>:</p>
<ul>
<li>تصادفی‌سازی آدرس‌های حافظه کرنل.</li>
<li>مقابله با حملات مبتنی بر آدرس‌های ثابت.</li>
</ul>
</li>
<li><p><strong>SMEP/SMAP (Supervisor Mode Execution/Access Prevention)</strong>:</p>
<ul>
<li>SMEP: جلوگیری از اجرای کد فضای کاربر در حالت کرنل.</li>
<li>SMAP: جلوگیری از دسترسی غیرمجاز به داده‌های فضای کاربر در حالت کرنل.</li>
</ul>
</li>
<li><p><strong>CFI (Control Flow Integrity)</strong>:</p>
<ul>
<li>محدود کردن جریان اجرای برنامه به مسیرهای مجاز.</li>
<li>مقابله با حملات ROP (Return-Oriented Programming).</li>
</ul>
</li>
<li><p><strong>PAGE_TABLE_ISOLATION (PTI)</strong>:</p>
<ul>
<li>جداسازی جدول‌های صفحه فضای کاربر و کرنل.</li>
<li>معرفی شده به عنوان پاسخی به آسیب‌پذیری Meltdown.</li>
</ul>
</li>
<li><p><strong>SECCOMP (Secure Computing Mode)</strong>:</p>
<ul>
<li>محدود کردن فراخوانی‌های سیستمی قابل استفاده توسط یک فرآیند.</li>
<li>کاهش سطح حمله با محدود کردن تعاملات با کرنل.</li>
</ul>
</li>
</ol>
<p><strong>پروژه‌های هاردنینگ کرنل:</strong></p>
<ol>
<li><p><strong>grsecurity/PaX</strong>:</p>
<ul>
<li>مجموعه‌ای از وصله‌های امنیتی برای کرنل لینوکس.</li>
<li>شامل ویژگی‌هایی مانند حفاظت پشته، ASLR، محدودیت‌های اضافی و بسیاری دیگر.</li>
<li>در گذشته به صورت رایگان در دسترس بود، اما اکنون فقط برای مشتریان تجاری ارائه می‌شود.</li>
</ul>
</li>
<li><p><strong>KSPP (Kernel Self Protection Project)</strong>:</p>
<ul>
<li>پروژه رسمی کرنل لینوکس برای بهبود ویژگی‌های حفاظتی درونی.</li>
<li>هدف آن ادغام بسیاری از ویژگی‌های پروژه‌هایی مانند grsecurity/PaX در کرنل اصلی است.</li>
<li>تمرکز بر محافظت از کرنل در برابر سوءاستفاده، حتی در صورت وجود آسیب‌پذیری.</li>
</ul>
</li>
</ol>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از KASAN (Kernel Address Sanitizer)
 * mm/kasan/kasan.c
 */</span>
<span class="hljs-symbol">void</span> __kasan_report(unsigned long <span class="hljs-keyword">addr, </span>size_t size, <span class="hljs-keyword">bool </span>is_write, unsigned long <span class="hljs-built_in">ip</span>)
{
    <span class="hljs-keyword">struct </span>kasan_access_info <span class="hljs-meta">info</span><span class="hljs-comment">;</span>

    <span class="hljs-comment">/* جمع‌آوری اطلاعات دسترسی */</span>
    <span class="hljs-meta">info</span>.access_addr = (void *)<span class="hljs-keyword">addr;
</span>    <span class="hljs-meta">info</span>.access_size = size<span class="hljs-comment">;</span>
    <span class="hljs-meta">info</span>.is_write = is_write<span class="hljs-comment">;</span>
    <span class="hljs-meta">info</span>.ip = <span class="hljs-built_in">ip</span><span class="hljs-comment">;</span>

    <span class="hljs-comment">/* بررسی آدرس */</span>
    <span class="hljs-meta">if</span> (likely(!kasan_report_enabled()))
        return<span class="hljs-comment">;</span>

    <span class="hljs-comment">/* گزارش تخلف دسترسی */</span>
    kasan_report_error(&amp;<span class="hljs-meta">info</span>)<span class="hljs-comment">;</span>
}
</code></pre>
<p>هاردنینگ کرنل یک فرآیند مداوم است که به تدریج ویژگی‌های امنیتی بیشتری به کرنل لینوکس اضافه می‌کند. با افزایش پیچیدگی تهدیدات، تکنیک‌های هاردنینگ نیز تکامل می‌یابند تا با آنها مقابله کنند.</p>
<h2 id="-">فرآیند توسعه کرنل لینوکس</h2>
<p>فرآیند توسعه کرنل لینوکس یکی از بزرگترین و موفق‌ترین نمونه‌های توسعه نرم‌افزار متن‌باز در جهان است. این فرآیند به طور مداوم تکامل یافته تا بتواند مقیاس و پیچیدگی روزافزون کرنل لینوکس را مدیریت کند. در این بخش، جنبه‌های مختلف فرآیند توسعه کرنل لینوکس را بررسی می‌کنیم.</p>
<h3 id="-">مدل توسعه متن‌باز</h3>
<p>کرنل لینوکس بر اساس اصول نرم‌افزار متن‌باز توسعه می‌یابد، اما رویکرد آن نسبت به بسیاری از پروژه‌های متن‌باز دیگر متفاوت است. این مدل را می‌توان به صورت زیر خلاصه کرد:</p>
<p><strong>ویژگی‌های کلیدی مدل توسعه لینوکس:</strong></p>
<ol>
<li><p><strong>مدل سلسله مراتبی</strong>:</p>
<ul>
<li>لینوس توروالدز همچنان نقش اصلی را در تصمیم‌گیری‌های نهایی دارد (به عنوان &quot;dictator&quot; خیرخواه).</li>
<li>زیر توروالدز، &quot;نگهدارندگان زیرسیستم&quot; (subsystem maintainers) هستند که مسئول بخش‌های خاصی از کرنل هستند.</li>
<li>زیر آنها، توسعه‌دهندگان با تخصص‌های مختلف قرار دارند.</li>
</ul>
</li>
<li><p><strong>فرآیند ارسال ادغام (merge) زیرسیستم‌ها</strong>:</p>
<ul>
<li>هر زیرسیستم درخت کد خود را دارد.</li>
<li>تغییرات ابتدا در درخت زیرسیستم ادغام می‌شوند.</li>
<li>در یک &quot;پنجره ادغام&quot; مشخص، تغییرات از درخت‌های زیرسیستم به درخت اصلی توروالدز ارسال می‌شوند.</li>
</ul>
</li>
<li><p><strong>دوره‌های توسعه و تثبیت</strong>:</p>
<ul>
<li>بعد از انتشار یک نسخه، یک &quot;دوره ادغام&quot; دو هفته‌ای شروع می‌شود.</li>
<li>پس از آن، یک &quot;دوره تثبیت&quot; شروع می‌شود که در آن فقط اصلاحات باگ پذیرفته می‌شوند.</li>
<li>چرخه انتشار معمولاً حدود 8-10 هفته طول می‌کشد.</li>
</ul>
</li>
<li><p><strong>بررسی کد (Code Review)</strong>:</p>
<ul>
<li>همه تغییرات باید قبل از پذیرش بررسی شوند.</li>
<li>بررسی از طریق لیست‌های پستی انجام می‌شود.</li>
<li>فرهنگ بررسی کد در لینوکس بسیار دقیق و گاهی بی‌رحمانه است.</li>
</ul>
</li>
<li><p><strong>استانداردهای کدنویسی سختگیرانه</strong>:</p>
<ul>
<li>استانداردهای کدنویسی مشخص که در <code>Documentation/process/coding-style.rst</code> مستند شده‌اند.</li>
<li>ابزارهای خودکار برای بررسی رعایت این استانداردها.</li>
</ul>
</li>
<li><p><strong>اصل &quot;Don&#39;t break userspace&quot;</strong>:</p>
<ul>
<li>تغییرات نباید سازگاری رو به عقب را بشکنند.</li>
<li>برنامه‌های موجود باید همچنان با نسخه‌های جدید کرنل کار کنند.</li>
</ul>
</li>
</ol>
<pre><code>                   توسعه و انتشار کرنل لینوکس
+------------------------------------------------------------------+
|<span class="hljs-string">                                                                  </span>|
|<span class="hljs-string">  پنجره ادغام            پنجره تثبیت                            پنجره ادغام   </span>|
|<span class="hljs-string">  </span>|<span class="hljs-string">----------</span>|<span class="hljs-string">   </span>|<span class="hljs-string">----------------------------------------</span>|<span class="hljs-string">   </span>|<span class="hljs-string">--</span>|
|<span class="hljs-string">                                                                  </span>|
|<span class="hljs-string">  rc1        rc2        rc3        rc4        rc5        rc6   انتشار  </span>|
|<span class="hljs-string">  </span>|<span class="hljs-string">          </span>|<span class="hljs-string">          </span>|<span class="hljs-string">          </span>|<span class="hljs-string">          </span>|<span class="hljs-string">          </span>|<span class="hljs-string">      </span>|
+------------------------------------------------------------------+
   ↑           ↑                                             ↑
   |<span class="hljs-string">           </span>|<span class="hljs-string">                                             </span>|
 تغییرات      فقط                                          چرخه
 بزرگ         اصلاحات                                        جدید
</code></pre><h3 id="-">گردش کار توسعه کرنل</h3>
<p>گردش کار معمول برای توسعه و ارسال یک تغییر به کرنل لینوکس به شرح زیر است:</p>
<p><strong>1. آماده‌سازی محیط توسعه:</strong></p>
<ul>
<li>دریافت کد منبع کرنل از repository اصلی.</li>
<li>نصب ابزارهای توسعه لازم (کامپایلرها، build tools و غیره).</li>
<li>پیکربندی و کامپایل کرنل برای اطمینان از عملکرد صحیح محیط.</li>
</ul>
<p><strong>2. توسعه تغییرات:</strong></p>
<ul>
<li>شناسایی مشکل یا ویژگی‌ای که باید پیاده‌سازی شود.</li>
<li>نوشتن کد با رعایت استانداردهای کدنویسی کرنل.</li>
<li>تست کد برای اطمینان از عملکرد صحیح و عدم وجود رگرسیون.</li>
</ul>
<p><strong>3. ایجاد وصله (patch):</strong></p>
<ul>
<li>تقسیم تغییرات به وصله‌های منطقی و کوچک.</li>
<li>هر وصله باید یک تغییر خاص و مشخص را انجام دهد.</li>
<li>نوشتن توضیحات واضح برای هر وصله (شامل هدف، چگونگی عملکرد و چرایی آن).</li>
</ul>
<p><strong>4. ارسال تغییرات:</strong></p>
<ul>
<li>شناسایی لیست پستی مناسب برای زیرسیستم هدف.</li>
<li>ارسال وصله‌ها با استفاده از <code>git send-email</code> یا ابزارهای مشابه.</li>
<li>تگ کردن نگهدارندگان مربوطه در ارسال.</li>
</ul>
<p><strong>5. بررسی و بازخورد:</strong></p>
<ul>
<li>توسعه‌دهندگان دیگر وصله را بررسی و بازخورد می‌دهند.</li>
<li>پاسخ به بازخوردها و انجام اصلاحات لازم.</li>
<li>ارسال نسخه‌های اصلاح شده وصله بر اساس بازخوردها.</li>
</ul>
<p><strong>6. پذیرش:</strong></p>
<ul>
<li>در صورت تأیید، نگهدارنده زیرسیستم وصله را در درخت کد خود ادغام می‌کند.</li>
<li>در پنجره ادغام بعدی، تغییرات به درخت اصلی توروالدز ارسال می‌شوند.</li>
<li>اگر توروالدز وصله را تأیید کند، به کرنل اصلی اضافه می‌شود.</li>
</ul>
<pre><code class="lang-bash"><span class="hljs-comment"># چرخه عمومی توسعه کرنل</span>
<span class="hljs-variable">$ </span>git clone <span class="hljs-symbol">git:</span>/<span class="hljs-regexp">/git.kernel.org/pub</span><span class="hljs-regexp">/scm/linux</span><span class="hljs-regexp">/kernel/git</span><span class="hljs-regexp">/torvalds/linux</span>.git
<span class="hljs-variable">$ </span>cd linux
<span class="hljs-variable">$ </span>git checkout -b my-feature    <span class="hljs-comment"># ایجاد شاخه جدید برای ویژگی</span>

<span class="hljs-comment"># [توسعه و تست تغییرات]</span>

<span class="hljs-variable">$ </span>git add -p                    <span class="hljs-comment"># افزودن تغییرات به صورت منطقی</span>
<span class="hljs-variable">$ </span>git commit -s                 <span class="hljs-comment"># ارسال با Signed-off-by</span>

<span class="hljs-comment"># [تکرار چرخه توسعه، تست و commit]</span>

<span class="hljs-variable">$ </span>git format-patch -o patches/ origin/master  <span class="hljs-comment"># ایجاد وصله‌ها</span>
<span class="hljs-variable">$ </span>git send-email --to=linux-kernel<span class="hljs-variable">@vger</span>.kernel.org patches/  <span class="hljs-comment"># ارسال وصله‌ها</span>
</code></pre>
<h3 id="-git">سیستم کنترل نسخه Git</h3>
<p>Git سیستم کنترل نسخه اصلی برای توسعه کرنل لینوکس است و در واقع توسط خود لینوس توروالدز برای این منظور ایجاد شده است. Git نقش حیاتی در مقیاس‌پذیری فرآیند توسعه لینوکس دارد.</p>
<p><strong>نقش Git در توسعه کرنل لینوکس:</strong></p>
<ol>
<li><p><strong>مدیریت توزیع‌شده</strong>:</p>
<ul>
<li>هزاران توسعه‌دهنده در سراسر جهان می‌توانند به طور مستقل روی شاخه‌های خود کار کنند.</li>
<li>هر توسعه‌دهنده یک نسخه کامل از تاریخچه repository را دارد.</li>
<li>عدم نیاز به دسترسی مستقیم به سرور مرکزی برای انجام کارهای روزانه.</li>
</ul>
</li>
<li><p><strong>مدیریت شاخه‌ها (Branching)</strong>:</p>
<ul>
<li>ایجاد آسان و کم‌هزینه شاخه‌های متعدد.</li>
<li>هر زیرسیستم می‌تواند شاخه‌های مخصوص به خود را داشته باشد.</li>
<li>ادغام شاخه‌ها به صورت کارآمد و قابل اعتماد.</li>
</ul>
</li>
<li><p><strong>مدیریت تغییرات نامتمرکز</strong>:</p>
<ul>
<li>هر نگهدارنده زیرسیستم repository خود را مدیریت می‌کند.</li>
<li>توروالدز فقط تغییرات مورد تأیید را در repository اصلی خود ادغام می‌کند.</li>
<li>این مدل از فشار بیش از حد روی یک نقطه متمرکز جلوگیری می‌کند.</li>
</ul>
</li>
<li><p><strong>ایجاد و اعمال وصله‌ها</strong>:</p>
<ul>
<li>ابزارهایی مانند <code>git format-patch</code> و <code>git am</code> برای کار با وصله‌ها.</li>
<li><code>git send-email</code> برای ارسال وصله‌ها به لیست‌های پستی.</li>
<li>قابلیت تهیه تاریخچه تغییرات (changelog) برای هر وصله.</li>
</ul>
</li>
<li><p><strong>ردیابی و مستندسازی</strong>:</p>
<ul>
<li>هر commit شامل نام و ایمیل توسعه‌دهنده و توضیحات تغییرات است.</li>
<li>امضا‌های Signed-off-by برای ثبت مسیر اعمال تغییرات.</li>
<li>ردیابی کامل اینکه چه کسی، چه زمانی و چرا تغییرات را انجام داده است.</li>
</ul>
</li>
</ol>
<p><strong>repository‌های مهم کرنل لینوکس:</strong></p>
<ul>
<li><strong>linux.git (Linus Torvalds)</strong>: Repository اصلی که نسخه‌های رسمی در آن منتشر می‌شوند.</li>
<li><strong>linux-next.git</strong>: برای تست و ادغام تغییرات قبل از ارسال به توروالدز.</li>
<li><strong>-stable.git (Greg Kroah-Hartman)</strong>: برای نسخه‌های stable که ویژگی‌های جدید ندارند اما شامل اصلاحات مهم هستند.</li>
<li>Repository‌های زیرسیستم‌ها (مانند net.git، mm.git و غیره).</li>
</ul>
<pre><code class="lang-shell"><span class="hljs-comment"># دستورات Git رایج در توسعه کرنل لینوکس</span>

<span class="hljs-comment"># بررسی تغییرات یک زیرسیستم خاص</span>
<span class="hljs-variable">$ </span>git clone <span class="hljs-symbol">git:</span>/<span class="hljs-regexp">/git.kernel.org/pub</span><span class="hljs-regexp">/scm/linux</span><span class="hljs-regexp">/kernel/git</span><span class="hljs-regexp">/netdev/net</span>.git
<span class="hljs-variable">$ </span>cd net
<span class="hljs-variable">$ </span>git log --oneline -- drivers/net/ethernet/

<span class="hljs-comment"># ایجاد وصله برای ارسال</span>
<span class="hljs-variable">$ </span>git format-patch -<span class="hljs-number">1</span> HEAD

<span class="hljs-comment"># اعمال وصله‌های دریافتی</span>
<span class="hljs-variable">$ </span>git am <span class="hljs-number">0001</span>-net-fix-race-condition.patch

<span class="hljs-comment"># بررسی تاریخچه تغییرات یک فایل خاص</span>
<span class="hljs-variable">$ </span>git blame drivers/net/ethernet/intel/e1000e/netdev.c

<span class="hljs-comment"># افزودن تغییرات به آخرین commit (مفید برای اصلاح بر اساس بازخورد)</span>
<span class="hljs-variable">$ </span>git commit --amend
</code></pre>
<h3 id="-">روند بررسی و ادغام کد</h3>
<p>بررسی کد نقش حیاتی در حفظ کیفیت و امنیت کرنل لینوکس دارد. این فرآیند به طور جدی توسط جامعه توسعه‌دهندگان لینوکس پیگیری می‌شود.</p>
<p><strong>مراحل بررسی کد:</strong></p>
<ol>
<li><p><strong>ارسال به لیست پستی</strong>:</p>
<ul>
<li>وصله‌ها به لیست پستی مربوط به زیرسیستم هدف ارسال می‌شوند.</li>
<li>معمولاً نسخه‌ای نیز به لیست پستی عمومی <code>linux-kernel@vger.kernel.org</code> ارسال می‌شود.</li>
</ul>
</li>
<li><p><strong>بررسی فنی</strong>:</p>
<ul>
<li>توسعه‌دهندگان و نگهدارندگان کد را برای عملکرد، کیفیت و سبک بررسی می‌کنند.</li>
<li>بررسی شامل عملکرد، امنیت، کارایی و تعامل با سایر بخش‌های کرنل است.</li>
<li>بازخوردها به صورت پاسخ به ایمیل ارسال می‌شوند.</li>
</ul>
</li>
<li><p><strong>تست</strong>:</p>
<ul>
<li>وصله‌ها توسط سیستم‌های تست خودکار و همچنین به صورت دستی تست می‌شوند.</li>
<li>سیستم‌هایی مانند KernelCI و 0day تست اتوماتیک را انجام می‌دهند.</li>
<li>گزارش‌های تست به توسعه‌دهنده و لیست پستی ارسال می‌شوند.</li>
</ul>
</li>
<li><p><strong>پذیرش توسط نگهدارنده زیرسیستم</strong>:</p>
<ul>
<li>نگهدارنده زیرسیستم وصله را در درخت کد خود ادغام می‌کند.</li>
<li>معمولاً با افزودن تگ <code>Acked-by:</code> یا <code>Reviewed-by:</code> تأیید می‌شود.</li>
</ul>
</li>
<li><p><strong>ارسال به linux-next</strong>:</p>
<ul>
<li>تغییرات زیرسیستم به درخت linux-next ارسال می‌شوند.</li>
<li>در linux-next، تعامل تغییرات با سایر زیرسیستم‌ها تست می‌شود.</li>
</ul>
</li>
<li><p><strong>ارسال به توروالدز</strong>:</p>
<ul>
<li>در پنجره ادغام، نگهدارنده زیرسیستم تغییرات را برای توروالدز ارسال می‌کند.</li>
<li>این کار معمولاً با یک pull request از طریق ایمیل انجام می‌شود.</li>
</ul>
</li>
<li><p><strong>بررسی نهایی و ادغام</strong>:</p>
<ul>
<li>توروالدز تغییرات را بررسی و در صورت تأیید، آنها را در درخت اصلی ادغام می‌کند.</li>
<li>گاهی اوقات، توروالدز بازخورد می‌دهد و تغییرات بیشتری درخواست می‌کند.</li>
</ul>
</li>
</ol>
<p><strong>تگ‌های مهم در روند بررسی:</strong></p>
<ul>
<li><strong>Signed-off-by</strong>: نشان‌دهنده مشارکت در توسعه و پذیرش DCO (Developer Certificate of Origin).</li>
<li><strong>Reviewed-by</strong>: نشان‌دهنده بررسی دقیق کد.</li>
<li><strong>Tested-by</strong>: نشان‌دهنده تست کد در یک محیط خاص.</li>
<li><strong>Acked-by</strong>: نشان‌دهنده تأیید کلی (اغلب توسط نگهدارندگان زیرسیستم).</li>
<li><strong>Reported-by</strong>: اشاره به کسی که یک باگ را گزارش کرده است.</li>
<li><strong>Fixes</strong>: اشاره به commit قبلی که این وصله آن را اصلاح می‌کند.</li>
</ul>
<pre><code><span class="hljs-string">From:</span> توسعه دهنده &lt;developer<span class="hljs-meta">@example</span>.com&gt;
<span class="hljs-string">Subject:</span> [PATCH] <span class="hljs-string">net:</span> تصحیح شرایط مسابقه در درایور e1000e

تصحیح یک شرایط مسابقه در درایور e1000e که می‌تواند در حین
تغییر حالت لینک رخ دهد. این مشکل می‌تواند باعث قفل شدن
سیستم در شرایط خاص شود.

کد قبلی فرض می‌کرد که وضعیت لینک ثابت است، اما در بعضی
سناریوها این فرض نادرست است. این وصله با افزودن یک قفل
برای حفاظت از اطلاعات وضعیت، مشکل را برطرف می‌کند.
<span class="hljs-symbol">
Fixes:</span> <span class="hljs-number">1</span>a2b3c4d5e6f (<span class="hljs-string">"net: e1000e: افزودن پشتیبانی از PTP"</span>)
Reported-<span class="hljs-string">by:</span> گزارش دهنده &lt;reporter<span class="hljs-meta">@example</span>.com&gt;
Tested-<span class="hljs-string">by:</span> تست کننده &lt;tester<span class="hljs-meta">@example</span>.com&gt;
Signed-off-<span class="hljs-string">by:</span> توسعه دهنده &lt;developer<span class="hljs-meta">@example</span>.com&gt;
---
drivers<span class="hljs-regexp">/net/</span>ethernet<span class="hljs-regexp">/intel/</span>e1000e/netdev.c | <span class="hljs-number">15</span> +++++++++------
<span class="hljs-number">1</span> file changed, <span class="hljs-number">9</span> insertions(+), <span class="hljs-number">6</span> deletions(-)

diff --git a<span class="hljs-regexp">/drivers/</span>net<span class="hljs-regexp">/ethernet/</span>intel<span class="hljs-regexp">/e1000e/</span>netdev.c b<span class="hljs-regexp">/drivers/</span>net<span class="hljs-regexp">/ethernet/</span>intel<span class="hljs-regexp">/e1000e/</span>netdev.c
index aaaaaaa..bbbbbbb <span class="hljs-number">100644</span>
--- a<span class="hljs-regexp">/drivers/</span>net<span class="hljs-regexp">/ethernet/</span>intel<span class="hljs-regexp">/e1000e/</span>netdev.c
+++ b<span class="hljs-regexp">/drivers/</span>net<span class="hljs-regexp">/ethernet/</span>intel<span class="hljs-regexp">/e1000e/</span>netdev.c
...
</code></pre><h3 id="-">چرخه انتشار کرنل</h3>
<p>کرنل لینوکس چرخه انتشار منظمی دارد که به طور مداوم تکامل یافته تا بتواند سرعت توسعه را حفظ کرده و در عین حال پایداری را تضمین کند.</p>
<p><strong>فرآیند انتشار کرنل:</strong></p>
<ol>
<li><p><strong>پنجره ادغام (Merge Window)</strong>:</p>
<ul>
<li>یک دوره حدوداً دو هفته‌ای بعد از انتشار نسخه قبلی.</li>
<li>در این مدت، تغییرات بزرگ و ویژگی‌های جدید پذیرفته می‌شوند.</li>
<li>توروالدز pull requestهای نگهدارندگان زیرسیستم را می‌پذیرد.</li>
<li>در پایان این دوره، اولین نسخه release candidate (rc1) منتشر می‌شود.</li>
</ul>
</li>
<li><p><strong>دوره تثبیت (Stabilization Period)</strong>:</p>
<ul>
<li>پس از پنجره ادغام، یک دوره 6-8 هفته‌ای تثبیت آغاز می‌شود.</li>
<li>در این دوره فقط اصلاحات باگ پذیرفته می‌شوند، نه ویژگی‌های جدید.</li>
<li>هر یک یا دو هفته، یک نسخه rc جدید منتشر می‌شود (rc2, rc3, ... rcN).</li>
<li>هدف این دوره، پیدا کردن و برطرف کردن مشکلات ناشی از تغییرات بزرگ است.</li>
</ul>
</li>
<li><p><strong>انتشار نهایی</strong>:</p>
<ul>
<li>بعد از 7-8 نسخه rc (معمولاً rc7 یا rc8)، نسخه نهایی منتشر می‌شود.</li>
<li>نسخه نهایی با شماره X.Y نامگذاری می‌شود (مثلاً 6.5).</li>
<li>بلافاصله پس از انتشار نسخه نهایی، پنجره ادغام برای نسخه بعدی باز می‌شود.</li>
</ul>
</li>
</ol>
<p><strong>سیستم نامگذاری نسخه‌ها:</strong></p>
<ul>
<li><strong>نسخه‌های development</strong>: با سه شماره X.Y.Z نشان داده می‌شوند، مانند 6.5.0-rc1.</li>
<li><strong>نسخه‌های stable</strong>: با دو شماره X.Y نشان داده می‌شوند، مانند 6.5.</li>
<li><strong>نسخه‌های stable update</strong>: با سه شماره X.Y.Z نشان داده می‌شوند، مانند 6.5.1، که نشان‌دهنده اصلاحات باگ در نسخه stable است.</li>
</ul>
<p><strong>زمان‌بندی انتشار:</strong></p>
<ul>
<li><strong>چرخه انتشار کامل</strong>: حدود 8-10 هفته (2 هفته پنجره ادغام + 6-8 هفته تثبیت).</li>
<li><strong>تعداد انتشار در سال</strong>: حدود 5-7 نسخه اصلی در سال.</li>
<li><strong>مدت زمان پشتیبانی</strong>: <ul>
<li>نسخه‌های عادی حدود 2-3 ماه (تا انتشار نسخه بعدی + چند هفته).</li>
<li>نسخه‌های LTS (Long Term Support) بین 2 تا 6 سال.</li>
</ul>
</li>
</ul>
<pre><code><span class="hljs-number">6.5</span>-rc1 (پایان پنجره ادغام)
   |
   v
<span class="hljs-number">6.5</span>-rc2 --&gt; <span class="hljs-number">6.5</span>-rc3 --&gt; <span class="hljs-number">6.5</span>-rc4 --&gt; <span class="hljs-number">6.5</span>-rc5 --&gt; <span class="hljs-number">6.5</span>-rc6 --&gt; <span class="hljs-number">6.5</span>-rc7 --&gt; <span class="hljs-number">6.5</span> (انتشار نهایی)
                                                                       |
                                                                       v
                                                                    <span class="hljs-number">6.5</span><span class="hljs-number">.1</span> (اصلاحات باگ)
                                                                       |
                                                                       v
                                                                    <span class="hljs-number">6.5</span><span class="hljs-number">.2</span> (اصلاحات باگ بیشتر)
</code></pre><h3 id="-">پشتیبانی بلندمدت</h3>
<p>برای پاسخگویی به نیازهای سیستم‌های تولیدی که نیاز به پایداری طولانی‌مدت دارند، لینوکس برنامه پشتیبانی بلندمدت (LTS - Long Term Support) را معرفی کرده است.</p>
<p><strong>نسخه‌های LTS:</strong></p>
<ul>
<li>برخی از نسخه‌های کرنل به عنوان LTS انتخاب می‌شوند.</li>
<li>معمولاً هر سال یک یا دو نسخه LTS منتشر می‌شود.</li>
<li>نسخه‌های LTS به مدت طولانی‌تری (2 تا 6 سال، در مقایسه با 2-3 ماه برای نسخه‌های عادی) پشتیبانی می‌شوند.</li>
<li>تمرکز بر روی اصلاحات امنیتی و باگ‌های مهم، بدون اضافه کردن ویژگی‌های جدید.</li>
</ul>
<p><strong>فرآیند نگهداری LTS:</strong></p>
<ul>
<li>نسخه‌های LTS توسط Greg Kroah-Hartman و تیم stable نگهداری می‌شوند.</li>
<li>وصله‌های امنیتی و اصلاحات باگ‌های مهم از نسخه‌های جدیدتر به نسخه‌های LTS backport می‌شوند.</li>
<li>معمولاً هر چند هفته یک نسخه جدید از هر LTS منتشر می‌شود (مثلاً 5.10.154).</li>
<li>با گذشت زمان، فقط مشکلات مهم‌تر اصلاح می‌شوند و نرخ تغییرات کاهش می‌یابد.</li>
</ul>
<p><strong>انتخاب نسخه‌های LTS:</strong></p>
<ul>
<li>در گذشته، هر نسخه با شماره زوج (مانند 2.6.32) یک نسخه LTS بود.</li>
<li>در سیستم شماره‌گذاری جدید، این الگو دیگر پیروی نمی‌شود.</li>
<li>نسخه‌های LTS بر اساس نیازهای جامعه و توزیع‌های لینوکس انتخاب می‌شوند.</li>
<li>معمولاً نسخه‌هایی که قرار است در توزیع‌های عمده لینوکس استفاده شوند، کاندیدای LTS هستند.</li>
</ul>
<p><strong>مزایای LTS:</strong></p>
<ul>
<li>پایداری و قابلیت اطمینان برای سیستم‌های تولیدی.</li>
<li>امکان برنامه‌ریزی برای ارتقای سیستم در بازه‌های زمانی طولانی‌تر.</li>
<li>کاهش هزینه‌های نگهداری برای شرکت‌ها و توزیع‌های لینوکس.</li>
<li>تجمیع اصلاحات امنیتی در نسخه‌های شناخته شده و پایدار.</li>
</ul>
<pre><code class="lang-bash"># نمونه‌ای از نسخه‌های LTS فعال (به عنوان مثال)
<span class="hljs-number">5.4</span>.x  - منتشر شده در نوامبر <span class="hljs-number">2019</span>  - پشتیبانی تا دسامبر <span class="hljs-number">2025</span>
<span class="hljs-number">5.10</span>.x - منتشر شده در دسامبر <span class="hljs-number">2020</span>  - پشتیبانی تا دسامبر <span class="hljs-number">2026</span>
<span class="hljs-number">5.15</span>.x - منتشر شده در اکتبر <span class="hljs-number">2021</span>   - پشتیبانی تا اکتبر <span class="hljs-number">2026</span>
<span class="hljs-number">6.1</span>.x  - منتشر شده در دسامبر <span class="hljs-number">2022</span>  - پشتیبانی تا دسامبر <span class="hljs-number">2026</span>
<span class="hljs-number">6.6</span>.x  - منتشر شده در اکتبر <span class="hljs-number">2023</span>   - پشتیبانی تا دسامبر <span class="hljs-number">2026</span>
</code></pre>
<h3 id="-">مشارکت‌کنندگان اصلی و شرکت‌ها</h3>
<p>توسعه کرنل لینوکس یک تلاش جمعی است که توسط هزاران توسعه‌دهنده از سراسر جهان انجام می‌شود. با این حال، برخی افراد و شرکت‌ها نقش برجسته‌تری در این فرآیند دارند.</p>
<p><strong>افراد کلیدی:</strong></p>
<ol>
<li><strong>لینوس توروالدز</strong>: بنیانگذار و هماهنگ‌کننده اصلی پروژه لینوکس.</li>
<li><strong>گرگ کروا-هارتمن (Greg Kroah-Hartman)</strong>: نگهدارنده شاخه stable و LTS و مسئول زیرسیستم‌های مهمی مانند USB.</li>
<li><strong>اندرو مورتون (Andrew Morton)</strong>: نگهدارنده mm (مدیریت حافظه) و پیشگام linux-next.</li>
<li><strong>دیوید میلر (David S. Miller)</strong>: نگهدارنده اصلی زیرسیستم شبکه.</li>
<li><strong>سایر نگهدارندگان زیرسیستم</strong>: افرادی که زیرسیستم‌های خاصی مانند فایل‌سیستم، گرافیک، صدا و غیره را مدیریت می‌کنند.</li>
</ol>
<p><strong>شرکت‌های مشارکت‌کننده اصلی:</strong></p>
<p>توسعه کرنل لینوکس از یک پروژه هابی به یک اکوسیستم صنعتی متکامل شده است. در حال حاضر، بسیاری از شرکت‌های بزرگ فناوری به طور فعال در توسعه کرنل مشارکت می‌کنند:</p>
<ol>
<li><strong>Red Hat</strong>: از بزرگترین مشارکت‌کنندگان از نظر تعداد پچ و توسعه‌دهندگان.</li>
<li><strong>Intel</strong>: مشارکت عمده در بخش‌های مربوط به معماری x86، گرافیک، و مدیریت انرژی.</li>
<li><strong>Google</strong>: مشارکت در زمینه‌هایی مانند امنیت، Android و ابزارهای توسعه.</li>
<li><strong>IBM</strong>: با تمرکز بر پشتیبانی از سخت‌افزارهای IBM و معماری‌هایی مانند POWER و s390.</li>
<li><strong>SUSE/SUSE Labs</strong>: مشارکت در زمینه‌های مختلف به ویژه فایل‌سیستم.</li>
<li><strong>Meta (Facebook)</strong>: پروژه‌های مرتبط با مقیاس‌پذیری و کارایی برای مراکز داده.</li>
<li><strong>Oracle</strong>: با تمرکز بر سیستم‌های فایل، مقیاس‌پذیری و کارایی.</li>
<li><strong>ARM/Qualcomm/Samsung</strong>: پشتیبانی از معماری ARM و سخت‌افزارهای مرتبط.</li>
<li><strong>AMD/NVIDIA</strong>: درایورهای گرافیکی و پشتیبانی از GPU.</li>
<li><strong>Microsoft</strong>: اخیراً مشارکت فعال، به ویژه در زمینه Hyper-V و WSL (Windows Subsystem for Linux).</li>
</ol>
<p><strong>مشارکت از نظر آماری:</strong></p>
<p>بر اساس گزارش‌های سالانه Linux Foundation، روند مشارکت در توسعه کرنل لینوکس نشان می‌دهد که:</p>
<ul>
<li>حدود 5,000 تا 6,000 توسعه‌دهنده منحصربه‌فرد در هر سال مشارکت می‌کنند.</li>
<li>حدود 80% از توسعه توسط توسعه‌دهندگانی انجام می‌شود که برای شرکت‌ها کار می‌کنند.</li>
<li>تعداد کمی از مشارکت‌کنندگان بدون وابستگی شرکتی یا توسعه‌دهندگان داوطلب وجود دارند.</li>
<li>در هر نسخه جدید کرنل، هزاران تغییر اعمال می‌شود که میلیون‌ها خط کد را تحت تأثیر قرار می‌دهد.</li>
</ul>
<p><strong>بنیاد لینوکس (Linux Foundation):</strong></p>
<p>بنیاد لینوکس یک سازمان غیرانتفاعی است که به منظور حمایت از توسعه لینوکس و سایر پروژه‌های متن‌باز تأسیس شده است. این بنیاد:</p>
<ul>
<li>میزبانی برای کد منبع لینوکس و ابزارهای مرتبط فراهم می‌کند.</li>
<li>کنفرانس‌ها و رویدادهایی مانند Linux Kernel Summit را برگزار می‌کند.</li>
<li>به عنوان واسطه بین جامعه توسعه‌دهندگان و شرکت‌های تجاری عمل می‌کند.</li>
<li>حقوق برخی از توسعه‌دهندگان کلیدی از جمله لینوس توروالدز را پرداخت می‌کند.</li>
<li>از لینوکس در برابر چالش‌های حقوقی و پتنت‌ها محافظت می‌کند.</li>
</ul>
<p>توسعه کرنل لینوکس یک نمونه برجسته از همکاری بین جامعه متن‌باز و شرکت‌های تجاری است که در آن منافع مختلف در جهت یک هدف مشترک همسو شده‌اند. این همکاری باعث شده است که لینوکس به یکی از پروژه‌های نرم‌افزاری بزرگ و پایدار در تاریخ تبدیل شود.</p>
<h3 id="-">توزیع‌های لینوکس</h3>
<p>توزیع‌های لینوکس، مجموعه‌ای از سیستم‌عامل‌های کامل هستند که بر اساس کرنل لینوکس ساخته شده‌اند. این توزیع‌ها با اضافه کردن ابزارها، کتابخانه‌ها، مدیر بسته و نرم‌افزارهای کاربردی به کرنل لینوکس، یک سیستم‌عامل کامل ارائه می‌دهند.</p>
<p><strong>توزیع‌های اصلی و ویژگی‌های آنها</strong>:</p>
<ol>
<li><p><strong>Debian</strong>:</p>
<ul>
<li>یکی از قدیمی‌ترین توزیع‌ها (1993)</li>
<li>کاملاً متن‌باز و غیرتجاری</li>
<li>مدیر بسته APT</li>
<li>تمرکز بر پایداری و آزادی نرم‌افزار</li>
<li>پایه‌ای برای توزیع‌های دیگر مانند Ubuntu</li>
</ul>
</li>
<li><p><strong>Ubuntu</strong>:</p>
<ul>
<li>محبوب‌ترین توزیع برای کاربران دسکتاپ</li>
<li>بر اساس Debian ساخته شده</li>
<li>تمرکز بر سهولت استفاده</li>
<li>انتشار منظم هر 6 ماه با نسخه‌های LTS هر 2 سال</li>
</ul>
</li>
<li><p><strong>Red Hat Enterprise Linux (RHEL)</strong>:</p>
<ul>
<li>توزیع تجاری با پشتیبانی سازمانی</li>
<li>تمرکز بر پایداری و امنیت برای محیط‌های سازمانی</li>
<li>مدیر بسته RPM</li>
<li>سیستم امنیتی SELinux</li>
</ul>
</li>
<li><p><strong>Fedora</strong>:</p>
<ul>
<li>پروژه جامعه‌محور حمایت شده توسط Red Hat</li>
<li>آزمایشگاه نوآوری برای ویژگی‌های جدید</li>
<li>اغلب ویژگی‌های آن بعداً به RHEL راه می‌یابند</li>
</ul>
</li>
<li><p><strong>SUSE Linux Enterprise / openSUSE</strong>:</p>
<ul>
<li>توزیع محبوب در اروپا</li>
<li>ابزارهای مدیریتی پیشرفته مانند YaST</li>
<li>نسخه‌های تجاری و جامعه‌محور</li>
</ul>
</li>
<li><p><strong>Arch Linux</strong>:</p>
<ul>
<li>مدل انتشار rolling-release (همیشه به‌روز)</li>
<li>فلسفه KISS (Keep It Simple, Stupid)</li>
<li>مستندات عالی و کنترل کامل برای کاربر</li>
</ul>
</li>
<li><p><strong>Alpine Linux</strong>:</p>
<ul>
<li>بسیار سبک و امن</li>
<li>استفاده گسترده در کانتینرهای Docker</li>
<li>استفاده از musl libc به جای glibc استاندارد</li>
</ul>
</li>
</ol>
<p>توزیع‌های لینوکس نشان می‌دهند که چگونه یک کرنل واحد می‌تواند برای کاربردهای مختلف سفارشی‌سازی شود، از گوشی‌های هوشمند گرفته تا ابررایانه‌ها. این تنوع و انعطاف‌پذیری یکی از دلایل اصلی موفقیت لینوکس است.</p>
<h3 id="-">اندروید و سیستم‌عامل‌های مبتنی بر لینوکس</h3>
<p>اندروید، محبوب‌ترین سیستم‌عامل موبایل جهان، بر پایه کرنل لینوکس ساخته شده است. این موفقیت چشمگیر نشان‌دهنده انعطاف‌پذیری و مقیاس‌پذیری کرنل لینوکس است.</p>
<p><strong>اندروید و کرنل لینوکس</strong>:</p>
<ul>
<li>اندروید یک نسخه اصلاح شده از کرنل لینوکس را استفاده می‌کند</li>
<li>تغییرات خاص اندروید شامل Binder IPC، wakelocks و سایر ویژگی‌های مدیریت انرژی است</li>
<li>بسیاری از این تغییرات به تدریج به کرنل اصلی لینوکس راه یافته‌اند</li>
</ul>
<p><strong>گستره نفوذ اندروید</strong>:</p>
<ul>
<li>بیش از 2.5 میلیارد دستگاه فعال در سراسر جهان</li>
<li>حدود 70% از سهم بازار تلفن‌های هوشمند</li>
<li>گسترش به تبلت‌ها، تلویزیون‌ها، ساعت‌های هوشمند و سیستم‌های خودرو</li>
</ul>
<p><strong>سایر سیستم‌عامل‌های مبتنی بر لینوکس</strong>:</p>
<ol>
<li><p><strong>Chrome OS</strong>:</p>
<ul>
<li>سیستم‌عامل Google برای لپ‌تاپ‌ها</li>
<li>بر اساس کرنل لینوکس و Gentoo Linux</li>
<li>تمرکز بر برنامه‌های وب و امنیت</li>
</ul>
</li>
<li><p><strong>تایزن (Tizen)</strong>:</p>
<ul>
<li>سیستم‌عامل توسعه یافته توسط سامسونگ و اینتل</li>
<li>استفاده در ساعت‌های هوشمند، تلویزیون‌ها و لوازم خانگی هوشمند</li>
</ul>
</li>
<li><p><strong>Sailfish OS</strong>:</p>
<ul>
<li>سیستم‌عامل موبایل توسعه یافته توسط Jolla</li>
<li>ترکیبی از کد متن‌باز و اختصاصی</li>
</ul>
</li>
<li><p><strong>سیستم‌عامل‌های خودرو</strong>:</p>
<ul>
<li>Automotive Grade Linux (AGL)</li>
<li>سیستم‌های سرگرمی و اطلاعاتی خودرو (infotainment)</li>
</ul>
</li>
</ol>
<p>کرنل لینوکس با قابلیت سفارشی‌سازی بالا، کارایی خوب و هزینه صفر مجوز، به انتخابی عالی برای توسعه‌دهندگان سیستم‌عامل‌های مختلف تبدیل شده است. موفقیت اندروید نشان داد که لینوکس می‌تواند به خوبی در دنیای دستگاه‌های تعبیه‌شده و موبایل با منابع محدود عمل کند.</p>
<h3 id="-">لینوکس در سرورها و مراکز داده</h3>
<p>یکی از موفق‌ترین حوزه‌های کاربرد لینوکس، سرورها و مراکز داده است. امروزه، لینوکس پلتفرم غالب برای میزبانی وب، خدمات ابری و بسیاری از برنامه‌های سازمانی است.</p>
<p><strong>آمار و ارقام</strong>:</p>
<ul>
<li>بیش از 90% از سرورهای وب جهان از لینوکس استفاده می‌کنند</li>
<li>تمام 500 ابررایانه برتر جهان از لینوکس استفاده می‌کنند</li>
<li>اکثریت قریب به اتفاق زیرساخت‌های ابری عمومی روی لینوکس اجرا می‌شوند</li>
<li>بیش از 75% از سرورهای DNS اینترنت از لینوکس استفاده می‌کنند</li>
</ul>
<p><strong>دلایل موفقیت لینوکس در سرورها</strong>:</p>
<ol>
<li><p><strong>پایداری و کارایی</strong>:</p>
<ul>
<li>زمان‌های کارکرد (uptime) طولانی‌مدت</li>
<li>مدیریت کارآمد منابع سیستم</li>
<li>مقیاس‌پذیری عالی از سرورهای کوچک تا کلاسترهای بزرگ</li>
</ul>
</li>
<li><p><strong>امنیت</strong>:</p>
<ul>
<li>مدل امنیتی قوی</li>
<li>به‌روزرسانی‌های امنیتی سریع</li>
<li>جامعه بزرگ برای تشخیص و اصلاح آسیب‌پذیری‌ها</li>
</ul>
</li>
<li><p><strong>انعطاف‌پذیری</strong>:</p>
<ul>
<li>سفارشی‌سازی برای نیازهای خاص</li>
<li>پشتیبانی از انواع مختلف سخت‌افزار</li>
<li>مناسب برای workloadهای متنوع</li>
</ul>
</li>
<li><p><strong>هزینه</strong>:</p>
<ul>
<li>بدون هزینه مجوز برای کرنل و بسیاری از نرم‌افزارها</li>
<li>کاهش هزینه‌های سخت‌افزاری به دلیل کارایی بهتر</li>
<li>صرفه‌جویی در هزینه‌های پشتیبانی با اتوماسیون</li>
</ul>
</li>
</ol>
<p><strong>فناوری‌های کلیدی لینوکس در سرورها</strong>:</p>
<ul>
<li><strong>کانتینرها</strong> (Docker, LXC) و ارکستراسیون آنها (Kubernetes)</li>
<li><strong>سیستم‌های فایل مقیاس‌پذیر</strong> (XFS, ZFS, Btrfs)</li>
<li><strong>فریم‌ورک‌های شبکه</strong> با کارایی بالا (DPDK, eBPF)</li>
<li><strong>پشتیبانی از ویرچوالایزیشن</strong> (KVM, Xen)</li>
</ul>
<p>لینوکس به همراه نرم‌افزارهای متن‌باز دیگر مانند Apache, MySQL/MariaDB, PostgreSQL و PHP/Python/Node.js، پایه و اساس بخش بزرگی از زیرساخت وب و اینترنت امروزی را تشکیل می‌دهند. حتی شرکت‌هایی مانند مایکروسافت که زمانی رقیب سرسخت لینوکس بودند، امروزه آن را در خدمات ابری خود مانند Azure ارائه می‌دهند.</p>
<h3 id="-">اینترنت اشیا و سیستم‌های نهفته</h3>
<p>یکی از حوزه‌های رو به رشد کاربرد لینوکس، دستگاه‌های اینترنت اشیا (IoT) و سیستم‌های نهفته (embedded systems) است. انعطاف‌پذیری، مقیاس‌پذیری و کارایی کرنل لینوکس آن را به گزینه‌ای عالی برای این دستگاه‌ها تبدیل کرده است.</p>
<p><strong>کاربردهای لینوکس در IoT و سیستم‌های نهفته</strong>:</p>
<ol>
<li><p><strong>دستگاه‌های هوشمند خانگی</strong>:</p>
<ul>
<li>ترموستات‌ها و سیستم‌های تهویه هوشمند</li>
<li>سیستم‌های امنیتی خانگی</li>
<li>دستیارهای صوتی (مانند Amazon Echo)</li>
<li>روترها و دستگاه‌های شبکه خانگی</li>
</ul>
</li>
<li><p><strong>سیستم‌های صنعتی</strong>:</p>
<ul>
<li>اتوماسیون کارخانه‌ها</li>
<li>سیستم‌های کنترل صنعتی</li>
<li>تجهیزات مانیتورینگ و نظارت</li>
<li>ربات‌های صنعتی</li>
</ul>
</li>
<li><p><strong>وسایل نقلیه</strong>:</p>
<ul>
<li>سیستم‌های سرگرمی و اطلاعاتی خودرو</li>
<li>سیستم‌های ناوبری</li>
<li>خودروهای خودران</li>
<li>مدیریت ناوگان حمل و نقل</li>
</ul>
</li>
<li><p><strong>تجهیزات پزشکی</strong>:</p>
<ul>
<li>دستگاه‌های مانیتورینگ بیمار</li>
<li>تجهیزات تشخیصی</li>
<li>سیستم‌های تصویربرداری پزشکی</li>
</ul>
</li>
</ol>
<p><strong>مزایای لینوکس برای سیستم‌های نهفته</strong>:</p>
<ul>
<li><strong>مقیاس‌پذیری</strong>: می‌تواند برای دستگاه‌های بسیار کوچک با منابع محدود بهینه‌سازی شود</li>
<li><strong>مدیریت انرژی</strong>: ویژگی‌های مدیریت انرژی پیشرفته برای دستگاه‌های باتری‌دار</li>
<li><strong>پشتیبانی از سخت‌افزارهای متنوع</strong>: درایورها برای طیف گسترده‌ای از میکروکنترلرها و چیپ‌ست‌ها</li>
<li><strong>امنیت</strong>: مکانیزم‌های امنیتی قوی برای دستگاه‌های متصل به اینترنت</li>
<li><strong>به‌روزرسانی از راه دور</strong>: پشتیبانی از به‌روزرسانی‌های OTA (Over-The-Air)</li>
</ul>
<p><strong>توزیع‌های لینوکس برای IoT و سیستم‌های نهفته</strong>:</p>
<ul>
<li><strong>Yocto Project</strong>: چارچوبی برای ایجاد توزیع‌های لینوکس سفارشی برای سیستم‌های نهفته</li>
<li><strong>Buildroot</strong>: ابزار سبک‌تر برای ایجاد سیستم‌های لینوکس نهفته</li>
<li><strong>Ubuntu Core</strong>: توزیع لینوکس مخصوص IoT با تمرکز بر امنیت و به‌روزرسانی</li>
<li><strong>Raspbian/Raspberry Pi OS</strong>: برای دستگاه‌های Raspberry Pi</li>
</ul>
<p>با گسترش اینترنت اشیا و هوشمندسازی دستگاه‌های مختلف، نقش لینوکس در این حوزه روز به روز پررنگ‌تر می‌شود. پیش‌بینی می‌شود تا سال 2030، بیش از 50 میلیارد دستگاه IoT در جهان وجود داشته باشد که بخش قابل توجهی از آنها از نسخه‌ای از لینوکس استفاده خواهند کرد.</p>
<h3 id="-">ابررایانه‌ها</h3>
<p>یکی از موفقیت‌های چشمگیر لینوکس، تسلط کامل آن بر دنیای ابررایانه‌ها (supercomputers) است. از سال 2017، 100% از 500 ابررایانه برتر جهان (فهرست TOP500) از لینوکس استفاده می‌کنند، که نشان‌دهنده برتری بی‌چون و چرای این سیستم‌عامل در محاسبات با کارایی بالا (HPC - High-Performance Computing) است.</p>
<p><strong>دلایل موفقیت لینوکس در ابررایانه‌ها</strong>:</p>
<ol>
<li><p><strong>مقیاس‌پذیری</strong>: </p>
<ul>
<li>توانایی مدیریت هزاران هسته پردازنده</li>
<li>پشتیبانی از حجم عظیم حافظه (پتابایت)</li>
<li>مدیریت کارآمد منابع</li>
</ul>
</li>
<li><p><strong>کارایی</strong>:</p>
<ul>
<li>سربار (overhead) کم سیستم‌عامل</li>
<li>بهینه‌سازی برای workloadهای محاسباتی</li>
<li>پشتیبانی از آخرین فناوری‌های سخت‌افزاری</li>
</ul>
</li>
<li><p><strong>انعطاف‌پذیری</strong>:</p>
<ul>
<li>قابلیت سفارشی‌سازی کامل کرنل و کتابخانه‌ها</li>
<li>پشتیبانی از معماری‌های مختلف (x86-64, ARM, POWER, RISC-V)</li>
<li>امکان حذف اجزای غیرضروری</li>
</ul>
</li>
<li><p><strong>اکوسیستم نرم‌افزاری</strong>:</p>
<ul>
<li>ابزارها و کتابخانه‌های متن‌باز برای HPC</li>
<li>پشتیبانی از استانداردهای موازی‌سازی مانند MPI و OpenMP</li>
<li>بسترهایی برای یادگیری ماشین و هوش مصنوعی</li>
</ul>
</li>
</ol>
<p><strong>ویژگی‌های کرنل لینوکس مهم برای ابررایانه‌ها</strong>:</p>
<ul>
<li><strong>NUMA (Non-Uniform Memory Access)</strong>: مدیریت حافظه برای سیستم‌های چندپردازنده‌ای بزرگ</li>
<li><strong>زمانبندی پیشرفته</strong>: زمانبندی بهینه فرآیندها در سیستم‌های با تعداد زیادی پردازنده</li>
<li><strong>Huge Pages</strong>: بهبود کارایی با استفاده از صفحات حافظه بزرگتر</li>
<li><strong>cgroups و namespaces</strong>: مدیریت و ایزوله کردن منابع برای کاربران مختلف</li>
<li><strong>شبکه با کارایی بالا</strong>: پشتیبانی از InfiniBand و دیگر فناوری‌های شبکه با سرعت بالا</li>
</ul>
<p><strong>نمونه‌های برجسته ابررایانه‌های لینوکس</strong>:</p>
<ul>
<li><strong>Frontier</strong> (آمریکا): اولین ابررایانه اگزاسکیل جهان با قدرت محاسباتی بیش از یک exaFLOPS</li>
<li><strong>Fugaku</strong> (ژاپن): یکی از قدرتمندترین ابررایانه‌های جهان</li>
<li><strong>Summit</strong> (آمریکا): طراحی شده توسط IBM برای تحقیقات پیشرفته</li>
<li><strong>Sierra</strong> (آمریکا): استفاده شده برای شبیه‌سازی‌های هسته‌ای</li>
<li><strong>Sunway TaihuLight</strong> (چین): یکی از ابررایانه‌های پیشرو با معماری پردازنده بومی</li>
</ul>
<p>حتی ابررایانه‌های جدید با معماری‌های غیرمتعارف مانند پردازنده‌های کوانتومی و نورونی نیز معمولاً از لینوکس برای سیستم‌های کنترل و مدیریت خود استفاده می‌کنند. این نشان می‌دهد که لینوکس توانایی سازگاری با پیشرفته‌ترین فناوری‌های محاسباتی را دارد.</p>
<h3 id="-">تأثیر بر صنعت و جامعه</h3>
<p>فراتر از جنبه‌های فنی، کرنل لینوکس تأثیر عمیقی بر صنعت نرم‌افزار و جامعه به طور کلی داشته است. این تأثیرات شامل تغییر در مدل‌های کسب‌و‌کار، روش‌های توسعه نرم‌افزار و حتی جنبه‌های اجتماعی و اقتصادی است.</p>
<p><strong>تأثیر بر مدل‌های کسب‌و‌کار</strong>:</p>
<ol>
<li><p><strong>نرم‌افزار متن‌باز به عنوان یک مدل کسب‌و‌کار</strong>:</p>
<ul>
<li>شرکت‌هایی مانند Red Hat (اکنون بخشی از IBM) با ارائه خدمات و پشتیبانی برای نرم‌افزارهای متن‌باز به موفقیت‌های بزرگ دست یافته‌اند</li>
<li>ظهور مدل &quot;open core&quot; که در آن هسته محصول متن‌باز است اما ویژگی‌های پیشرفته به صورت تجاری ارائه می‌شوند</li>
</ul>
</li>
<li><p><strong>کاهش هزینه‌های توسعه</strong>:</p>
<ul>
<li>شرکت‌ها به جای توسعه سیستم‌عامل‌های اختصاصی، از لینوکس استفاده می‌کنند</li>
<li>اشتراک‌گذاری هزینه‌های نگهداری و توسعه بین شرکت‌های مختلف</li>
</ul>
</li>
<li><p><strong>نوآوری مشارکتی</strong>:</p>
<ul>
<li>حتی رقبا در برخی زمینه‌ها با یکدیگر همکاری می‌کنند</li>
<li>ایجاد بنیادهای صنعتی مانند Linux Foundation برای مدیریت پروژه‌های متن‌باز</li>
</ul>
</li>
</ol>
<p><strong>تأثیر بر روش‌های توسعه نرم‌افزار</strong>:</p>
<ol>
<li><p><strong>توسعه توزیع‌شده</strong>:</p>
<ul>
<li>الگوی توسعه لینوکس با هزاران توسعه‌دهنده از سراسر جهان، مدلی برای پروژه‌های بزرگ شده است</li>
<li>ابزارهایی مانند Git (که برای توسعه لینوکس ایجاد شد) استاندارد صنعت شده‌اند</li>
</ul>
</li>
<li><p><strong>معیارهای کیفیت</strong>:</p>
<ul>
<li>فرآیندهای بررسی کد و تضمین کیفیت در لینوکس الهام‌بخش بسیاری از پروژه‌های دیگر بوده است</li>
<li>استانداردهای کدنویسی و مستندسازی دقیق</li>
</ul>
</li>
<li><p><strong>CI/CD و DevOps</strong>:</p>
<ul>
<li>بسیاری از روش‌های DevOps مدرن، از فرآیندهای توسعه لینوکس الهام گرفته‌اند</li>
<li>اتوماسیون تست و استقرار</li>
</ul>
</li>
</ol>
<p><strong>تأثیر اجتماعی و اقتصادی</strong>:</p>
<ol>
<li><p><strong>دسترسی جهانی به فناوری</strong>:</p>
<ul>
<li>کشورها و جوامع با منابع محدود می‌توانند از نرم‌افزارهای پیشرفته بدون هزینه استفاده کنند</li>
<li>کاهش شکاف دیجیتالی</li>
</ul>
</li>
<li><p><strong>آموزش و پژوهش</strong>:</p>
<ul>
<li>دانشگاه‌ها و مؤسسات آموزشی از لینوکس برای آموزش علوم کامپیوتر استفاده می‌کنند</li>
<li>دسترسی به کد منبع کرنل، امکان پژوهش‌های پیشرفته را فراهم می‌کند</li>
</ul>
</li>
<li><p><strong>ایجاد مشاغل و فرصت‌های اقتصادی</strong>:</p>
<ul>
<li>رشد اکوسیستم خدمات و محصولات مبتنی بر لینوکس</li>
<li>امکان کارآفرینی با هزینه کمتر به دلیل عدم نیاز به پرداخت هزینه مجوز</li>
</ul>
</li>
<li><p><strong>استقلال فناوری</strong>:</p>
<ul>
<li>کشورها می‌توانند بدون وابستگی به شرکت‌های خارجی، زیرساخت‌های حیاتی خود را توسعه دهند</li>
<li>امکان بررسی کد منبع برای اطمینان از عدم وجود درهای پشتی (backdoors)</li>
</ul>
</li>
</ol>
<p>موفقیت لینوکس نشان داده است که مدل توسعه متن‌باز می‌تواند نه تنها از نظر فنی بلکه از نظر اقتصادی و اجتماعی نیز موفق باشد. این موفقیت الهام‌بخش هزاران پروژه متن‌باز دیگر شده است که امروزه بخش مهمی از زیرساخت دیجیتال ما را تشکیل می‌دهند.</p>
<h3 id="-">نوآوری‌های الهام گرفته از لینوکس</h3>
<p>موفقیت لینوکس و فلسفه توسعه آن، الهام‌بخش بسیاری از نوآوری‌ها و پروژه‌های دیگر در دنیای فناوری اطلاعات بوده است. لینوکس و جامعه آن، مفاهیم و ابزارهایی را معرفی کرده‌اند که فراتر از خود کرنل، تأثیر گسترده‌ای بر صنعت نرم‌افزار داشته‌اند.</p>
<p><strong>ابزارها و فناوری‌های الهام گرفته از لینوکس</strong>:</p>
<ol>
<li><p><strong>Git</strong>:</p>
<ul>
<li>سیستم کنترل نسخه توزیع‌شده که توسط لینوس توروالدز برای مدیریت کد کرنل لینوکس ایجاد شد</li>
<li>امروزه استاندارد صنعت برای مدیریت کد منبع است</li>
<li>پایه‌ای برای پلتفرم‌هایی مانند GitHub و GitLab</li>
</ul>
</li>
<li><p><strong>کانتینریزیشن</strong>:</p>
<ul>
<li>فناوری کانتینرها (Docker, LXC) بر اساس ویژگی‌های کرنل لینوکس مانند cgroups و namespaces ساخته شده است</li>
<li>انقلابی در نحوه توسعه، استقرار و مقیاس‌گذاری نرم‌افزارها ایجاد کرده است</li>
<li>پایه‌ای برای رویکردهای مدرن DevOps و microservices</li>
</ul>
</li>
<li><p><strong>eBPF (extended Berkeley Packet Filter)</strong>:</p>
<ul>
<li>مکانیزم اجرای کد ایمن در فضای کرنل</li>
<li>انقلابی در مانیتورینگ، امنیت شبکه و بهینه‌سازی کارایی</li>
<li>الهام‌بخش رویکردهای جدید به برنامه‌نویسی سیستمی</li>
</ul>
</li>
<li><p><strong>مکانیزم‌های مجازی‌سازی</strong>:</p>
<ul>
<li>KVM (Kernel-based Virtual Machine) بخشی از کرنل لینوکس است</li>
<li>پایه‌ای برای بسیاری از پلتفرم‌های ابری و مجازی‌سازی</li>
</ul>
</li>
</ol>
<p><strong>مفاهیم و رویکردها</strong>:</p>
<ol>
<li><p><strong>مدل توسعه متن‌باز</strong>:</p>
<ul>
<li>&quot;مدل بازار&quot; (در مقابل &quot;مدل کلیسای جامع&quot;) که توسط اریک ریموند برای توصیف توسعه لینوکس معرفی شد</li>
<li>الهام‌بخش هزاران پروژه متن‌باز دیگر</li>
<li>پایه‌ای برای همکاری در مقیاس بزرگ</li>
</ul>
</li>
<li><p><strong>انتشار زودهنگام و مکرر</strong>:</p>
<ul>
<li>فلسفه &quot;release early, release often&quot; که در توسعه لینوکس پیروی می‌شود</li>
<li>تأثیرگذار بر متدولوژی‌های چابک (Agile) و DevOps</li>
</ul>
</li>
<li><p><strong>&quot;Given enough eyeballs, all bugs are shallow&quot; (قانون لینوس)</strong>:</p>
<ul>
<li>اصلی که بیان می‌کند با تعداد کافی توسعه‌دهنده، تمام مشکلات قابل حل هستند</li>
<li>پایه‌ای برای رویکردهای بررسی همتا (peer review) و توسعه مشارکتی</li>
</ul>
</li>
<li><p><strong>&quot;Infrastructure as Code&quot;</strong>:</p>
<ul>
<li>رویکرد مدیریت و پیکربندی زیرساخت با استفاده از تکنیک‌های توسعه نرم‌افزار</li>
<li>ریشه در روش‌های مدیریت پیکربندی لینوکس دارد</li>
</ul>
</li>
</ol>
<p><strong>پروژه‌های بزرگ الهام گرفته از لینوکس</strong>:</p>
<ol>
<li><p><strong>بنیاد نرم‌افزار آزاد (FSF) و پروژه GNU</strong>:</p>
<ul>
<li>گرچه قبل از لینوکس وجود داشتند، اما موفقیت لینوکس به آنها انرژی جدیدی بخشید</li>
<li>همکاری GNU/Linux الگویی برای همکاری‌های آینده شد</li>
</ul>
</li>
<li><p><strong>Apache Software Foundation</strong>:</p>
<ul>
<li>الهام گرفته از مدل حاکمیت و توسعه لینوکس</li>
<li>میزبان ده‌ها پروژه متن‌باز موفق</li>
</ul>
</li>
<li><p><strong>Creative Commons</strong>:</p>
<ul>
<li>بسط مفهوم متن‌باز به فراتر از نرم‌افزار</li>
<li>الهام گرفته از مفاهیم مجوزهای متن‌باز مانند GPL</li>
</ul>
</li>
<li><p><strong>Mozilla Foundation</strong>:</p>
<ul>
<li>متن‌باز کردن مرورگر Netscape به عنوان Mozilla/Firefox</li>
<li>الهام گرفته از موفقیت مدل توسعه لینوکس</li>
</ul>
</li>
</ol>
<p>تأثیر لینوکس فراتر از کرنل و حتی فراتر از نرم‌افزار گسترش یافته است. ایده‌های اساسی آن - همکاری باز، شفافیت، توسعه توزیع‌شده، و اشتراک‌گذاری دانش - در زمینه‌های مختلف از تولید محتوا گرفته تا طراحی سخت‌افزار، از علوم داده تا آموزش، نفوذ کرده‌اند. لینوکس به یک الگوی موفق برای چگونگی همکاری انسان‌ها در مقیاس جهانی برای ایجاد محصولات پیچیده و با کیفیت بالا تبدیل شده است.</p>
<h2 id="-">نتیجه‌گیری</h2>
<p>کرنل لینوکس از یک پروژه شخصی کوچک که توسط یک دانشجوی فنلاندی آغاز شد، به یکی از مهم‌ترین نرم‌افزارهای جهان تبدیل شده است. این مسیر تکاملی شگفت‌انگیز، نه تنها در تاریخ نرم‌افزار بلکه در تاریخ همکاری انسانی نیز بی‌سابقه است.</p>
<p><strong>دستاوردهای کلیدی</strong>:</p>
<ol>
<li><p><strong>تکامل فنی</strong>: کرنل لینوکس از یک هسته ساده با حدود 10,000 خط کد به یک سیستم پیچیده با میلیون‌ها خط کد تبدیل شده است که از پیشرفته‌ترین ویژگی‌های سیستم‌عامل برخوردار است. این تکامل بدون شکستن سازگاری با برنامه‌های موجود انجام شده است، که یک دستاورد قابل توجه است.</p>
</li>
<li><p><strong>گستردگی کاربرد</strong>: لینوکس امروزه در همه جا حضور دارد، از گوشی‌های هوشمند تا ابررایانه‌ها، از سرورهای وب تا سیستم‌های نهفته در لوازم خانگی. این گستردگی کاربرد نشان‌دهنده انعطاف‌پذیری و مقیاس‌پذیری استثنایی کرنل لینوکس است.</p>
</li>
<li><p><strong>مدل توسعه متن‌باز</strong>: لینوکس ثابت کرد که مدل توسعه متن‌باز می‌تواند پروژه‌های بزرگ و پیچیده را با موفقیت مدیریت کند. این مدل الهام‌بخش هزاران پروژه دیگر شده و به طور اساسی نحوه تولید نرم‌افزار را تغییر داده است.</p>
</li>
<li><p><strong>تأثیر اقتصادی</strong>: لینوکس با ارائه یک پایه قدرتمند و رایگان برای اکوسیستم دیجیتال، ارزش اقتصادی عظیمی ایجاد کرده است. شرکت‌های بزرگی مانند Red Hat (حالا بخشی از IBM) کاملاً حول محور لینوکس ساخته شده‌اند، و بسیاری از غول‌های فناوری مانند Google، Amazon و Meta به طور گسترده از آن استفاده می‌کنند.</p>
</li>
</ol>
<p><strong>چالش‌های آینده</strong>:</p>
<p>با وجود موفقیت‌های چشمگیر، کرنل لینوکس همچنان با چالش‌هایی روبرو است:</p>
<ol>
<li><p><strong>مدیریت پیچیدگی</strong>: با افزایش مداوم پیچیدگی کد کرنل، مدیریت و نگهداری آن دشوارتر می‌شود. تلاش برای مدولارسازی بیشتر و بهبود ساختار کد برای مقابله با این چالش ضروری است.</p>
</li>
<li><p><strong>امنیت</strong>: با گسترش استفاده از لینوکس در دستگاه‌های حساس و حیاتی، امنیت آن اهمیت بیشتری پیدا می‌کند. کشف و اصلاح آسیب‌پذیری‌ها، به ویژه در کدهای قدیمی‌تر، یک چالش مداوم است.</p>
</li>
<li><p><strong>پشتیبانی از فناوری‌های جدید</strong>: همگام ماندن با فناوری‌های نوظهور مانند محاسبات کوانتومی، هوش مصنوعی و محاسبات لبه‌ای، مستلزم توسعه مداوم و نوآوری است.</p>
</li>
<li><p><strong>حفظ مشارکت جامعه</strong>: حفظ پویایی جامعه توسعه‌دهندگان و جذب نسل جدیدی از مشارکت‌کنندگان، برای تداوم موفقیت لینوکس حیاتی است.</p>
</li>
</ol>
<p><strong>نگاه به آینده</strong>:</p>
<p>آینده کرنل لینوکس با چشم‌انداز فناوری جهانی به هم پیوسته است. به عنوان زیرساخت اصلی برای بسیاری از فناوری‌های نوظهور، لینوکس همچنان نقشی حیاتی در شکل دادن به آینده دیجیتال خواهد داشت. کاربردهای جدید در زمینه‌هایی مانند اینترنت اشیا، کلان‌داده، و هوش مصنوعی، فرصت‌های جدیدی برای نوآوری و رشد فراهم می‌کنند.</p>
<p>کرنل لینوکس نشان داده است که با توسعه باز، همکاری جهانی و تعهد به کیفیت، می‌توان به دستاوردهای خارق‌العاده‌ای دست یافت. این درس‌ها فراتر از دنیای نرم‌افزار قابل کاربرد هستند و می‌توانند الهام‌بخش رویکردهای جدید به حل مشکلات پیچیده جهانی باشند.</p>
<p>همانطور که لینوس توروالدز، بنیانگذار لینوکس، بارها گفته است: &quot;همکاری نه تنها باعث می‌شود چیزهای بهتری بسازیم، بلکه به ما کمک می‌کند چیزهایی بسازیم که به تنهایی حتی تصورش را هم نمی‌کردیم.&quot; این روح همکاری و نوآوری، میراث واقعی کرنل لینوکس است که همچنان در حال شکل دادن به آینده فناوری است.### توزیع‌های لینوکس</p>
<p>توزیع‌های لینوکس، مجموعه‌ای از سیستم‌عامل‌های کامل هستند که بر اساس کرنل لینوکس ساخته شده‌اند. این توزیع‌ها با اضافه کردن ابزارها، کتابخانه‌ها، مدیر بسته و نرم‌افزارهای کاربردی به کرنل لینوکس، یک سیستم‌عامل کامل ارائه می‌دهند.</p>
<p><strong>توزیع‌های اصلی و ویژگی‌های آنها</strong>:</p>
<ol>
<li><p><strong>Debian</strong>:</p>
<ul>
<li>یکی از قدیمی‌ترین توزیع‌ها (1993)</li>
<li>کاملاً متن‌باز و غیرتجاری</li>
<li>مدیر بسته APT</li>
<li>تمرکز بر پایداری و آزادی نرم‌افزار</li>
<li>پایه‌ای برای توزیع‌های دیگر مانند Ubuntu</li>
</ul>
</li>
<li><p><strong>Ubuntu</strong>:</p>
<ul>
<li>محبوب‌ترین توزیع برای کاربران دسکتاپ</li>
<li>بر اساس Debian ساخته شده</li>
<li>تمرکز بر سهولت استفاده</li>
<li>انتشار منظم هر 6 ماه با نسخه‌های LTS هر 2 سال</li>
</ul>
</li>
<li><p><strong>Red Hat Enterprise Linux (RHEL)</strong>:</p>
<ul>
<li>توزیع تجاری با پشتیبانی سازمانی</li>
<li>تمرکز بر پایداری و امنیت برای محیط‌های سازمانی</li>
<li>مدیر بسته RPM</li>
<li>سیستم امنیتی SELinux</li>
</ul>
</li>
<li><p><strong>Fedora</strong>:</p>
<ul>
<li>پروژه جامعه‌محور حمایت شده توسط Red Hat</li>
<li>آزمایشگاه نوآوری برای ویژگی‌های جدید</li>
<li>اغلب ویژگی‌های آن بعداً به RHEL راه می‌یابند</li>
</ul>
</li>
<li><p><strong>SUSE Linux Enterprise / openSUSE</strong>:</p>
<ul>
<li>توزیع محبوب در اروپا</li>
<li>ابزارهای مدیریتی پیشرفته مانند YaST</li>
<li>نسخه‌های تجاری و جامعه‌محور</li>
</ul>
</li>
<li><p><strong>Arch Linux</strong>:</p>
<ul>
<li>مدل انتشار rolling-release (همیشه به‌روز)</li>
<li>فلسفه KISS (Keep It Simple, Stupid)</li>
<li>مستندات عالی و کنترل کامل برای کاربر</li>
</ul>
</li>
<li><p><strong>Alpine Linux</strong>:</p>
<ul>
<li>بسیار سبک و امن</li>
<li>استفاده گسترده در کانتینرهای Docker</li>
<li>استفاده از musl libc به جای glibc استاندارد</li>
</ul>
</li>
</ol>
<p>توزیع‌های لینوکس نشان می‌دهند که چگونه یک کرنل واحد می‌تواند برای کاربردهای مختلف سفارشی‌سازی شود، از گوشی‌های هوشم## نسخه‌های مهم کرنل لینوکس</p>
<p>تاریخچه توسعه کرنل لینوکس شامل انتشار نسخه‌های متعدد با ویژگی‌ها و پیشرفت‌های کلیدی است. هر نسخه مهم از کرنل لینوکس نشان‌دهنده نقطه عطفی در تکامل این سیستم‌عامل بوده است. در این بخش، به بررسی نسخه‌های کلیدی و ویژگی‌های آنها می‌پردازیم.</p>
<h3 id="-0-01-">لینوکس 0.01 و اولین نسخه‌ها</h3>
<p>لینوکس 0.01، اولین نسخه عمومی کرنل لینوکس بود که در 17 سپتامبر 1991 توسط لینوس توروالدز منتشر شد. این نسخه بسیار ابتدایی بود و قابلیت‌های محدودی داشت:</p>
<ul>
<li>حدود 10,000 خط کد به زبان C و اسمبلی</li>
<li>پشتیبانی فقط از معماری x86 اینتل</li>
<li>عملکرد محدود سیستم فایل</li>
<li>پشتیبانی از سخت‌افزار بسیار محدود</li>
<li>وابستگی به Minix برای کامپایل و توسعه</li>
<li>فاقد پشتیبانی از شبکه</li>
</ul>
<p>کد منبع اولیه لینوکس 0.01 به صورت فشرده با حجمی حدود 64 کیلوبایت توزیع شد و ابتدا تحت مجوز اختصاصی منتشر شد که استفاده تجاری را محدود می‌کرد. در این مرحله، لینوکس بیشتر یک پروژه آزمایشی و تفریحی بود تا یک سیستم‌عامل کامل.</p>
<p>نسخه‌های اولیه دیگر عبارت بودند از:</p>
<ul>
<li><strong>لینوکس 0.02</strong> (اکتبر 1991): پشتیبانی بهتر از سخت‌افزار و بهبود سیستم فایل</li>
<li><strong>لینوکس 0.11</strong> (دسامبر 1991): اولین نسخه‌ای که می‌توانست مستقل از Minix اجرا شود</li>
<li><strong>لینوکس 0.12</strong> (ژانویه 1992): پایداری بیشتر و اولین نشانه‌های اینکه پروژه می‌تواند به یک سیستم‌عامل واقعی تبدیل شود</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * بخشی از کد اولیه لینوکس (نسخه 0.01) - بوت‌لودر
 */</span>
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(void)        <span class="hljs-comment">/* This really IS void, no error here. */</span>
{            <span class="hljs-comment">/* The startup routine assumes (well, ...) this */</span>
<span class="hljs-comment">/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */</span>
     <span class="hljs-selector-tag">time_init</span>();
    <span class="hljs-selector-tag">tty_init</span>();
    <span class="hljs-selector-tag">trap_init</span>();
    <span class="hljs-selector-tag">sched_init</span>();
    <span class="hljs-selector-tag">buffer_init</span>();
    <span class="hljs-selector-tag">hd_init</span>();
    <span class="hljs-selector-tag">sti</span>();
    <span class="hljs-selector-tag">move_to_user_mode</span>();
    <span class="hljs-selector-tag">if</span> (!fork()) {        <span class="hljs-comment">/* we count on this going ok */</span>
        <span class="hljs-selector-tag">init</span>();
    }
<span class="hljs-comment">/*
 *   NOTE!!   For any other task 'pause()' would mean we have to get a
 * signal to awaken, but task0 is the sole exception (see 'schedule()')
 * as task 0 gets activated at every idle moment (when no other tasks
 * can run). For task0 'pause()' just means we go check if some other
 * task can run, and if not we return here.
 */</span>
    <span class="hljs-selector-tag">for</span>(;;) <span class="hljs-selector-tag">pause</span>();
}
</code></pre>
<h3 id="-1-0-">لینوکس 1.0 و تثبیت پروژه</h3>
<p>لینوکس 1.0 در 14 مارس 1994 منتشر شد و نقطه عطف مهمی بود که نشان‌دهنده بلوغ پروژه و قابلیت استفاده در محیط‌های تولید بود. تا این زمان، کرنل کاملاً تحت مجوز GPL قرار گرفته بود. </p>
<p>ویژگی‌های کلیدی لینوکس 1.0:</p>
<ul>
<li>پشتیبانی کامل از پروتکل TCP/IP و شبکه</li>
<li>سیستم فایل ext (Extended Filesystem)</li>
<li>پشتیبانی از درایورهای بیشتر برای سخت‌افزارهای متنوع</li>
<li>چند وظیفه‌ای پیش‌گیرانه (preemptive multitasking)</li>
<li>مدیریت حافظه مجازی</li>
<li>پشتیبانی کامل از مجوزهای فایل یونیکس</li>
<li>حدود 176,000 خط کد</li>
</ul>
<p>این نسخه به طور گسترده در سرتاسر جهان مورد استفاده قرار گرفت و توزیع‌های لینوکس مانند Slackware، Debian و Red Hat بر اساس آن ساخته شدند. لینوکس 1.0 همچنین برای اولین بار به جامعه کسب‌و‌کار نشان داد که یک سیستم‌عامل متن‌باز می‌تواند به عنوان جایگزینی جدی برای سیستم‌عامل‌های تجاری در نظر گرفته شود.</p>
<h3 id="-2-0-">لینوکس 2.0 و پشتیبانی از چندپردازنده</h3>
<p>لینوکس 2.0 در 9 ژوئن 1996 منتشر شد و یک پیشرفت قابل توجه بود که کرنل لینوکس را به عرصه کامپیوترهای سرور و حرفه‌ای وارد کرد. مهم‌ترین ویژگی این نسخه، پشتیبانی از سیستم‌های چندپردازنده‌ای (SMP - Symmetric Multi-Processing) بود.</p>
<p>ویژگی‌های کلیدی لینوکس 2.0:</p>
<ul>
<li>پشتیبانی از چندپردازنده (SMP) که امکان استفاده در سرورهای قدرتمندتر را فراهم کرد</li>
<li>سیستم فایل جدید ext2 با قابلیت‌های پیشرفته‌تر</li>
<li>پشتیبانی از ماژول‌های قابل بارگذاری در زمان اجرا (برای افزودن درایورها بدون نیاز به راه‌اندازی مجدد)</li>
<li>پشتیبانی از معماری‌های Alpha، SPARC و MIPS علاوه بر x86</li>
<li>پشتیبانی از SCSI و سایر سیستم‌های ذخیره‌سازی پیشرفته</li>
<li>بهبود در پشتیبانی از پروتکل‌های شبکه</li>
<li>حدود 400,000 خط کد</li>
</ul>
<p>لینوکس 2.0 همچنین شاهد رشد قابل توجه تعداد توسعه‌دهندگان بود و از یک پروژه شخصی به یک تلاش جمعی تبدیل شد. بسیاری از شرکت‌ها شروع به استفاده از لینوکس در محیط‌های تولیدی کردند و اولین برنامه‌های کاربردی تجاری برای آن توسعه یافتند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه ای از پشتیبانی SMP در لینوکس 2.0
 * kernel/smp.c
 */</span>
<span class="hljs-keyword">void</span> smp_message_pass(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> msg, unsigned <span class="hljs-keyword">long</span> data, <span class="hljs-keyword">int</span> wait)
{
    struct smp_call_struct <span class="hljs-keyword">call</span>;

    <span class="hljs-keyword">call</span>.func = (<span class="hljs-keyword">void</span> *) data;
    atomic_set(&amp;<span class="hljs-keyword">call</span>.finished, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">call</span>.priv = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (target == MSG_ALL_BUT_SELF) {
        <span class="hljs-keyword">int</span> i, cpu = smp_processor_id();
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; smp_num_cpus; i++)
            <span class="hljs-keyword">if</span> (i != cpu)
                send_IPI(i, msg, (unsigned <span class="hljs-keyword">int</span>) &amp;<span class="hljs-keyword">call</span>);
    } <span class="hljs-keyword">else</span>
        send_IPI(target, msg, (unsigned <span class="hljs-keyword">int</span>) &amp;<span class="hljs-keyword">call</span>);

    <span class="hljs-keyword">if</span> (wait)
        <span class="hljs-keyword">while</span> (!atomic_read(&amp;<span class="hljs-keyword">call</span>.finished));
}
</code></pre>
<h3 id="-2-6-">لینوکس 2.6 و تحولات بزرگ</h3>
<p>لینوکس 2.6 یکی از مهم‌ترین نسخه‌های کرنل بود که در 17 دسامبر 2003 منتشر شد. این نسخه تغییرات اساسی در معماری کرنل و مدل توسعه آن ایجاد کرد و پایه بسیاری از ویژگی‌های مدرن لینوکس امروزی را شکل داد. نسخه 2.6 از زمان انتشار به مدت حدود 8 سال (تا 2011) ادامه یافت و به تدریج ویژگی‌های بسیاری به آن اضافه شد.</p>
<p>ویژگی‌های کلیدی لینوکس 2.6:</p>
<ul>
<li><strong>زمانبندی O(1)</strong>: زمانبند جدیدی که کارایی بهتری در سیستم‌های چندپردازنده‌ای و سیستم‌های با تعداد زیادی فرآیند داشت</li>
<li><strong>قابلیت preemption</strong>: کرنل کاملاً قابل پیشگیری، که پاسخگویی سیستم را بهبود می‌بخشید</li>
<li><strong>بهبود مقیاس‌پذیری</strong>: پشتیبانی از سیستم‌های با تعداد بسیار زیادی از پردازنده‌ها (تا هزاران پردازنده)</li>
<li><strong>سیستم ورودی/خروجی</strong> جدید برای بهبود کارایی</li>
<li><strong>ALSA</strong>: زیرسیستم صوتی پیشرفته‌تر به جای OSS</li>
<li><strong>NPTL</strong> (Native POSIX Thread Library): پشتیبانی بهتر از چند نخی (multithreading)</li>
<li><strong>Hotplug و udev</strong>: مدیریت پویای دستگاه‌ها</li>
<li><strong>پشتیبانی از سیستم فایل‌های جدید</strong> مانند XFS، JFS و ext3</li>
<li><strong>CPU frequency scaling</strong>: برای مدیریت مصرف انرژی</li>
<li><strong>SELinux</strong>: برای امنیت بیشتر</li>
<li><strong>فضاهای نام (namespaces)</strong>: پایه‌ای برای مجازی‌سازی سبک (containerization)</li>
</ul>
<pre><code class="lang-c">/**
 * نمونه‌ای از کد زمانبندی <span class="hljs-type">O</span>(<span class="hljs-number">1</span>) در لینوکس <span class="hljs-number">2.6</span>
 * kernel/sched.c
 */
static void enqueue_task(<span class="hljs-keyword">struct</span> task_struct *p, prio_array_t *<span class="hljs-built_in">array</span>)
{
    unsigned long flags;

    spin_lock_irqsave(&amp;<span class="hljs-built_in">array</span>-&gt;lock, flags);

    <span class="hljs-keyword">if</span> (!p-&gt;<span class="hljs-built_in">array</span>) {
        <span class="hljs-built_in">array</span>-&gt;nr_active++;
        p-&gt;<span class="hljs-built_in">array</span> = <span class="hljs-built_in">array</span>;

        <span class="hljs-keyword">if</span> (p-&gt;prio &lt; <span class="hljs-built_in">array</span>-&gt;nr_active_bitmap)
            __set_bit(p-&gt;prio, <span class="hljs-built_in">array</span>-&gt;bitmap);

        list_add_tail(&amp;p-&gt;run_list, <span class="hljs-built_in">array</span>-&gt;queue + p-&gt;prio);
    }

    spin_unlock_irqrestore(&amp;<span class="hljs-built_in">array</span>-&gt;lock, flags);
}
</code></pre>
<h3 id="-">تغییر به سیستم شماره‌گذاری جدید</h3>
<p>در سال 2011، پس از هشت سال توسعه مداوم سری 2.6، توسعه‌دهندگان کرنل لینوکس تصمیم گرفتند سیستم شماره‌گذاری خود را تغییر دهند. این تغییر با انتشار لینوکس 3.0 در 21 جولای 2011 آغاز شد. لینوس توروالدز توضیح داد که این تغییر صرفاً شماره‌گذاری بوده و تغییر اساسی در کد یا معماری نبوده است، اما سیستم شماره‌گذاری جدید ساده‌تر و مستقیم‌تر است.</p>
<p><strong>سیستم شماره‌گذاری جدید</strong>:</p>
<ul>
<li>فقط از دو شماره استفاده می‌کند: X.Y (مثلاً 3.0، 3.1، 4.0 و غیره)</li>
<li>شماره اول (X) برای تغییرات بسیار بزرگ یا به طور دلخواه برای نشان دادن یک نقطه عطف تغییر می‌کند</li>
<li>شماره دوم (Y) برای هر نسخه جدید افزایش می‌یابد</li>
<li>نسخه‌های stable به صورت X.Y.Z نامگذاری می‌شوند</li>
</ul>
<p>این سیستم شماره‌گذاری جدید با روند انتشار منظم‌تر نسخه‌های جدید (تقریباً هر 2-3 ماه) همراه بود، که به توسعه‌دهندگان و توزیع‌کنندگان لینوکس امکان می‌داد برای انتشار و ادغام ویژگی‌های جدید برنامه‌ریزی بهتری داشته باشند.</p>
<h3 id="-">نسخه‌های جدید و ویژگی‌های کلیدی</h3>
<p>پس از تغییر سیستم شماره‌گذاری، نسخه‌های مهم کرنل لینوکس و ویژگی‌های کلیدی آنها عبارتند از:</p>
<p><strong>لینوکس 3.0</strong> (جولای 2011):</p>
<ul>
<li>پشتیبانی از Xen virtualization به صورت native</li>
<li>پشتیبانی از سخت‌افزارهای ARM جدید</li>
<li>بهبودهای سیستم فایل Btrfs</li>
<li>درایورهای گرافیکی بهبود یافته</li>
</ul>
<p><strong>لینوکس 4.0</strong> (آوریل 2015):</p>
<ul>
<li>پشتیبانی از live patching (به‌روزرسانی کرنل بدون نیاز به راه‌اندازی مجدد)</li>
<li>بهبود قابلیت‌های مجازی‌سازی</li>
<li>پشتیبانی از CrossTalk برای اشتراک‌گذاری داده بین پردازنده‌های اینتل</li>
<li>سیستم فایل OverlayFS</li>
</ul>
<p><strong>لینوکس 5.0</strong> (مارس 2019):</p>
<ul>
<li>پشتیبانی از AMD FreeSync</li>
<li>پشتیبانی از Adiantum برای رمزگذاری فایل‌سیستم</li>
<li>بهبود مدیریت انرژی</li>
<li>بهبودهای امنیتی برای مقابله با آسیب‌پذیری‌های Spectre و Meltdown</li>
<li>پشتیبانی بهتر از سخت‌افزارهای Raspberry Pi</li>
</ul>
<p><strong>لینوکس 6.0</strong> (اکتبر 2022):</p>
<ul>
<li>پشتیبانی بهبود یافته از پردازنده‌های RISC-V</li>
<li>بهبود درایورهای شبکه و کارت گرافیک</li>
<li>فایل‌سیستم بهبود یافته - ext4 و Btrfs با عملکرد بهتر</li>
<li>قابلیت Multi-Gen LRU برای مدیریت حافظه بهینه‌تر</li>
<li>پشتیبانی PCI باریه (PCI Device Feature)</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از پشتیبانی Live Patching در لینوکس 4.0
 * kernel/livepatch/core.c
 */</span>
<span class="hljs-type">int</span> klp_enable_patch(struct klp_patch *<span class="hljs-keyword">patch</span>)
{
    <span class="hljs-type">int</span> ret;

    <span class="hljs-keyword">if</span> (WARN_ON(<span class="hljs-keyword">patch</span>-&gt;enabled))
        <span class="hljs-keyword">return</span> -EINVAL;

    <span class="hljs-comment">/* Connect functions to their targets */</span>
    ret = klp_init_patch(<span class="hljs-keyword">patch</span>);
    <span class="hljs-keyword">if</span> (ret)
        <span class="hljs-keyword">return</span> ret;

    <span class="hljs-comment">/*
     * Enforce mutual exclusion with other patches being
     * (un)registered and other registration/unregistration
     * operations.
     */</span>
    mutex_lock(&amp;klp_mutex);

    ret = klp_prep_objects(<span class="hljs-keyword">patch</span>);
    <span class="hljs-keyword">if</span> (ret)
        goto err;

    <span class="hljs-comment">/* Mark the patch as enabled */</span>
    <span class="hljs-keyword">patch</span>-&gt;enabled = <span class="hljs-literal">true</span>;

    mutex_unlock(&amp;klp_mutex);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

err:
    mutex_unlock(&amp;klp_mutex);
    klp_cleanup_patch(<span class="hljs-keyword">patch</span>);
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<h3 id="-api-abi">تکامل API و ABI</h3>
<p>یکی از ویژگی‌های مهم کرنل لینوکس، تعهد آن به حفظ سازگاری برنامه‌های کاربردی (API stability) و سازگاری باینری برنامه‌ها (ABI stability) است. این بدان معناست که برنامه‌های نوشته شده برای نسخه‌های قدیمی‌تر لینوکس باید بتوانند روی نسخه‌های جدیدتر نیز بدون تغییر اجرا شوند.</p>
<p><strong>API (Application Programming Interface)</strong>:</p>
<ul>
<li>واسط برنامه‌نویسی که برنامه‌ها برای تعامل با کرنل از آن استفاده می‌کنند</li>
<li>در لینوکس، این شامل فراخوانی‌های سیستمی (system calls) است</li>
<li>کرنل لینوکس تلاش می‌کند API را برای برنامه‌های فضای کاربر ثابت نگه دارد</li>
</ul>
<p><strong>ABI (Application Binary Interface)</strong>:</p>
<ul>
<li>قراردادهای سطح پایین‌تر که سازگاری باینری را تضمین می‌کنند</li>
<li>شامل فرمت داده‌ها، قراردادهای فراخوانی (calling conventions) و غیره</li>
<li>در لینوکس، ABI باید ثابت بماند تا برنامه‌های کامپایل شده همچنان کار کنند</li>
</ul>
<p><strong>اصل &quot;Don&#39;t Break Userspace&quot;</strong>:</p>
<ul>
<li>یک قانون اساسی در توسعه کرنل لینوکس</li>
<li>حتی اگر کد موجود مشکل‌دار باشد، تغییرات نباید برنامه‌های کاربردی موجود را بشکنند</li>
<li>لینوس توروالدز: &quot;ما هرگز، تحت هیچ شرایطی، فضای کاربر را نمی‌شکنیم.&quot;</li>
</ul>
<p>با این حال، ABI داخلی کرنل (یعنی واسط بین ماژول‌های کرنل و کرنل اصلی) تضمین نمی‌شود و می‌تواند بین نسخه‌های مختلف تغییر کند. این بدان معناست که ماژول‌های کرنل معمولاً نیاز به کامپایل مجدد برای هر نسخه کرنل دارند.</p>
<p><strong>استراتژی‌های حفظ سازگاری</strong>:</p>
<ul>
<li>افزودن API/ABI جدید به جای تغییر موارد موجود</li>
<li>استفاده از versioned symbols و compatibility layers</li>
<li>استفاده از deprecated warnings قبل از حذف هر مورد قدیمی</li>
</ul>
<p>این تعهد به سازگاری، یکی از دلایل مهم موفقیت و پذیرش گسترده لینوکس بوده است. کاربران و توسعه‌دهندگان می‌توانند با اطمینان به کرنل لینوکس ارتقا دهند، بدون نگرانی از اینکه برنامه‌های آنها دیگر کار نکند.</p>
<h2 id="-">تاثیر کرنل لینوکس بر دنیای کامپیوتر</h2>
<p>کرنل لینوکس یکی از مهم‌ترین پروژه‌های نرم‌افزاری تاریخ است که تأثیر عمیقی بر دنیای فناوری اطلاعات و جامعه داشته است. از سرورهای وب گرفته تا تلفن‌های هوشمند، از ابررایانه‌ها تا دستگاه‌های اینترنت اشیا، لینوکس به یک زیرساخت بنیادی برای اکوسیستم دیجیتال مدرن تبدیل شده است. در این بخش، تأثیرات گسترده کرنل لینوکس را بررسی می‌کنیم.## نسخه‌های مهم کرنل لینوکس</p>
<p>تاریخچه توسعه کرنل لینوکس شامل انتشار نسخه‌های متعدد با ویژگی‌ها و پیشرفت‌های کلیدی است. هر نسخه مهم از کرنل لینوکس نشان‌دهنده نقطه عطفی در تکامل این سیستم‌عامل بوده است. در این بخش، به بررسی نسخه‌های کلیدی و ویژگی‌های آنها می‌پردازیم.</p>
<h3 id="-0-01-">لینوکس 0.01 و اولین نسخه‌ها</h3>
<p>لینوکس 0.01، اولین نسخه عمومی کرنل لینوکس بود که در 17 سپتامبر 1991 توسط لینوس توروالدز منتشر شد. این نسخه بسیار ابتدایی بود و قابلیت‌های محدودی داشت:</p>
<ul>
<li>حدود 10,000 خط کد به زبان C و اسمبلی</li>
<li>پشتیبانی فقط از معماری x86 اینتل</li>
<li>عملکرد محدود سیستم فایل</li>
<li>پشتیبانی از سخت‌افزار بسیار محدود</li>
<li>وابستگی به Minix برای کامپایل و توسعه</li>
<li>فاقد پشتیبانی از شبکه</li>
</ul>
<p>کد منبع اولیه لینوکس 0.01 به صورت فشرده با حجمی حدود 64 کیلوبایت توزیع شد و ابتدا تحت مجوز اختصاصی منتشر شد که استفاده تجاری را محدود می‌کرد. در این مرحله، لینوکس بیشتر یک پروژه آزمایشی و تفریحی بود تا یک سیستم‌عامل کامل.</p>
<p>نسخه‌های اولیه دیگر عبارت بودند از:</p>
<ul>
<li><strong>لینوکس 0.02</strong> (اکتبر 1991): پشتیبانی بهتر از سخت‌افزار و بهبود سیستم فایل</li>
<li><strong>لینوکس 0.11</strong> (دسامبر 1991): اولین نسخه‌ای که می‌توانست مستقل از Minix اجرا شود</li>
<li><strong>لینوکس 0.12</strong> (ژانویه 1992): پایداری بیشتر و اولین نشانه‌های اینکه پروژه می‌تواند به یک سیستم‌عامل واقعی تبدیل شود</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * بخشی از کد اولیه لینوکس (نسخه 0.01) - بوت‌لودر
 */</span>
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(void)        <span class="hljs-comment">/* This really IS void, no error here. */</span>
{            <span class="hljs-comment">/* The startup routine assumes (well, ...) this */</span>
<span class="hljs-comment">/*
 * Interrupts are still disabled. Do necessary setups, then
 * enable them
 */</span>
     <span class="hljs-selector-tag">time_init</span>();
    <span class="hljs-selector-tag">tty_init</span>();
    <span class="hljs-selector-tag">trap_init</span>();
    <span class="hljs-selector-tag">sched_init</span>();
    <span class="hljs-selector-tag">buffer_init</span>();
    <span class="hljs-selector-tag">hd_init</span>();
    <span class="hljs-selector-tag">sti</span>();
    <span class="hljs-selector-tag">move_to_user_mode</span>();
    <span class="hljs-selector-tag">if</span> (!fork()) {        <span class="hljs-comment">/* we count on this going ok */</span>
        <span class="hljs-selector-tag">init</span>();
    }
<span class="hljs-comment">/*
 *   NOTE!!   For any other task 'pause()' would mean we have to get a
 * signal to awaken, but task0 is the sole exception (see 'schedule()')
 * as task 0 gets activated at every idle moment (when no other tasks
 * can run). For task0 'pause()' just means we go check if some other
 * task can run, and if not we return here.
 */</span>
    <span class="hljs-selector-tag">for</span>(;;) <span class="hljs-selector-tag">pause</span>();
}
</code></pre>
<h3 id="-1-0-">لینوکس 1.0 و تثبیت پروژه</h3>
<p>لینوکس 1.0 در 14 مارس 1994 منتشر شد و نقطه عطف مهمی بود که نشان‌دهنده بلوغ پروژه و قابلیت استفاده در محیط‌های تولید بود. تا این زمان، کرنل کاملاً تحت مجوز GPL قرار گرفته بود. </p>
<p>ویژگی‌های کلیدی لینوکس 1.0:</p>
<ul>
<li>پشتیبانی کامل از پروتکل TCP/IP و شبکه</li>
<li>سیستم فایل ext (Extended Filesystem)</li>
<li>پشتیبانی از درایورهای بیشتر برای سخت‌افزارهای متنوع</li>
<li>چند وظیفه‌ای پیش‌گیرانه (preemptive multitasking)</li>
<li>مدیریت حافظه مجازی</li>
<li>پشتیبانی کامل از مجوزهای فایل یونیکس</li>
<li>حدود 176,000 خط کد</li>
</ul>
<p>این نسخه به طور گسترده در سرتاسر جهان مورد استفاده قرار گرفت و توزیع‌های لینوکس مانند Slackware، Debian و Red Hat بر اساس آن ساخته شدند. لینوکس 1.0 همچنین برای اولین بار به جامعه کسب‌و‌کار نشان داد که یک سیستم‌عامل متن‌باز می‌تواند به عنوان جایگزینی جدی برای سیستم‌عامل‌های تجاری در نظر گرفته شود.</p>
<h3 id="-2-0-">لینوکس 2.0 و پشتیبانی از چندپردازنده</h3>
<p>لینوکس 2.0 در 9 ژوئن 1996 منتشر شد و یک پیشرفت قابل توجه بود که کرنل لینوکس را به عرصه کامپیوترهای سرور و حرفه‌ای وارد کرد. مهم‌ترین ویژگی این نسخه، پشتیبانی از سیستم‌های چندپردازنده‌ای (SMP - Symmetric Multi-Processing) بود.</p>
<p>ویژگی‌های کلیدی لینوکس 2.0:</p>
<ul>
<li>پشتیبانی از چندپردازنده (SMP) که امکان استفاده در سرورهای قدرتمندتر را فراهم کرد</li>
<li>سیستم فایل جدید ext2 با قابلیت‌های پیشرفته‌تر</li>
<li>پشتیبانی از ماژول‌های قابل بارگذاری در زمان اجرا (برای افزودن درایورها بدون نیاز به راه‌اندازی مجدد)</li>
<li>پشتیبانی از معماری‌های Alpha، SPARC و MIPS علاوه بر x86</li>
<li>پشتیبانی از SCSI و سایر سیستم‌های ذخیره‌سازی پیشرفته</li>
<li>بهبود در پشتیبانی از پروتکل‌های شبکه</li>
<li>حدود 400,000 خط کد</li>
</ul>
<p>لینوکس 2.0 همچنین شاهد رشد قابل توجه تعداد توسعه‌دهندگان بود و از یک پروژه شخصی به یک تلاش جمعی تبدیل شد. بسیاری از شرکت‌ها شروع به استفاده از لینوکس در محیط‌های تولیدی کردند و اولین برنامه‌های کاربردی تجاری برای آن توسعه یافتند.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه ای از پشتیبانی SMP در لینوکس 2.0
 * kernel/smp.c
 */</span>
<span class="hljs-keyword">void</span> smp_message_pass(<span class="hljs-keyword">int</span> target, <span class="hljs-keyword">int</span> msg, unsigned <span class="hljs-keyword">long</span> data, <span class="hljs-keyword">int</span> wait)
{
    struct smp_call_struct <span class="hljs-keyword">call</span>;

    <span class="hljs-keyword">call</span>.func = (<span class="hljs-keyword">void</span> *) data;
    atomic_set(&amp;<span class="hljs-keyword">call</span>.finished, <span class="hljs-number">0</span>);
    <span class="hljs-keyword">call</span>.priv = <span class="hljs-number">0</span>;

    <span class="hljs-keyword">if</span> (target == MSG_ALL_BUT_SELF) {
        <span class="hljs-keyword">int</span> i, cpu = smp_processor_id();
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; smp_num_cpus; i++)
            <span class="hljs-keyword">if</span> (i != cpu)
                send_IPI(i, msg, (unsigned <span class="hljs-keyword">int</span>) &amp;<span class="hljs-keyword">call</span>);
    } <span class="hljs-keyword">else</span>
        send_IPI(target, msg, (unsigned <span class="hljs-keyword">int</span>) &amp;<span class="hljs-keyword">call</span>);

    <span class="hljs-keyword">if</span> (wait)
        <span class="hljs-keyword">while</span> (!atomic_read(&amp;<span class="hljs-keyword">call</span>.finished));
}
</code></pre>
<h3 id="-2-6-">لینوکس 2.6 و تحولات بزرگ</h3>
<p>لینوکس 2.6 یکی از مهم‌ترین نسخه‌های کرنل بود که در 17 دسامبر 2003 منتشر شد. این نسخه تغییرات اساسی در معماری کرنل و مدل توسعه آن ایجاد کرد و پایه بسیاری از ویژگی‌های مدرن لینوکس امروزی را شکل داد. نسخه 2.6 از زمان انتشار به مدت حدود 8 سال (تا 2011) ادامه یافت و به تدریج ویژگی‌های بسیاری به آن اضافه شد.</p>
<p>ویژگی‌های کلیدی لینوکس 2.6:</p>
<ul>
<li><strong>زمانبندی O(1)</strong>: زمانبند جدیدی که کارایی بهتری در سیستم‌های چندپردازنده‌ای و سیستم‌های با تعداد زیادی فرآیند داشت</li>
<li><strong>قابلیت preemption</strong>: کرنل کاملاً قابل پیشگیری، که پاسخگویی سیستم را بهبود می‌بخشید</li>
<li><strong>بهبود مقیاس‌پذیری</strong>: پشتیبانی از سیستم‌های با تعداد بسیار زیادی از پردازنده‌ها (تا هزاران پردازنده)</li>
<li><strong>سیستم ورودی/خروجی</strong> جدید برای بهبود کارایی</li>
<li><strong>ALSA</strong>: زیرسیستم صوتی پیشرفته‌تر به جای OSS</li>
<li><strong>NPTL</strong> (Native POSIX Thread Library): پشتیبانی بهتر از چند نخی (multithreading)</li>
<li><strong>Hotplug و udev</strong>: مدیریت پویای دستگاه‌ها</li>
<li><strong>پشتیبانی از سیستم فایل‌های جدید</strong> مانند XFS، JFS و ext3</li>
<li><strong>CPU frequency scaling</strong>: برای مدیریت مصرف انرژی</li>
<li><strong>SELinux</strong>: برای امنیت بیشتر</li>
<li><strong>فضاهای نام (namespaces)</strong>: پایه‌ای برای مجازی‌سازی سبک (containerization)</li>
</ul>
<pre><code class="lang-c">/**
 * نمونه‌ای از کد زمانبندی <span class="hljs-type">O</span>(<span class="hljs-number">1</span>) در لینوکس <span class="hljs-number">2.6</span>
 * kernel/sched.c
 */
static void enqueue_task(<span class="hljs-keyword">struct</span> task_struct *p, prio_array_t *<span class="hljs-built_in">array</span>)
{
    unsigned long flags;

    spin_lock_irqsave(&amp;<span class="hljs-built_in">array</span>-&gt;lock, flags);

    <span class="hljs-keyword">if</span> (!p-&gt;<span class="hljs-built_in">array</span>) {
        <span class="hljs-built_in">array</span>-&gt;nr_active++;
        p-&gt;<span class="hljs-built_in">array</span> = <span class="hljs-built_in">array</span>;

        <span class="hljs-keyword">if</span> (p-&gt;prio &lt; <span class="hljs-built_in">array</span>-&gt;nr_active_bitmap)
            __set_bit(p-&gt;prio, <span class="hljs-built_in">array</span>-&gt;bitmap);

        list_add_tail(&amp;p-&gt;run_list, <span class="hljs-built_in">array</span>-&gt;queue + p-&gt;prio);
    }

    spin_unlock_irqrestore(&amp;<span class="hljs-built_in">array</span>-&gt;lock, flags);
}
</code></pre>
<h3 id="-">تغییر به سیستم شماره‌گذاری جدید</h3>
<p>در سال 2011، پس از هشت سال توسعه مداوم سری 2.6، توسعه‌دهندگان کرنل لینوکس تصمیم گرفتند سیستم شماره‌گذاری خود را تغییر دهند. این تغییر با انتشار لینوکس 3.0 در 21 جولای 2011 آغاز شد. لینوس توروالدز توضیح داد که این تغییر صرفاً شماره‌گذاری بوده و تغییر اساسی در کد یا معماری نبوده است، اما سیستم شماره‌گذاری جدید ساده‌تر و مستقیم‌تر است.</p>
<p><strong>سیستم شماره‌گذاری جدید</strong>:</p>
<ul>
<li>فقط از دو شماره استفاده می‌کند: X.Y (مثلاً 3.0، 3.1، 4.0 و غیره)</li>
<li>شماره اول (X) برای تغییرات بسیار بزرگ یا به طور دلخواه برای نشان دادن یک نقطه عطف تغییر می‌کند</li>
<li>شماره دوم (Y) برای هر نسخه جدید افزایش می‌یابد</li>
<li>نسخه‌های stable به صورت X.Y.Z نامگذاری می‌شوند</li>
</ul>
<p>این سیستم شماره‌گذاری جدید با روند انتشار منظم‌تر نسخه‌های جدید (تقریباً هر 2-3 ماه) همراه بود، که به توسعه‌دهندگان و توزیع‌کنندگان لینوکس امکان می‌داد برای انتشار و ادغام ویژگی‌های جدید برنامه‌ریزی بهتری داشته باشند.</p>
<h3 id="-">نسخه‌های جدید و ویژگی‌های کلیدی</h3>
<p>پس از تغییر سیستم شماره‌گذاری، نسخه‌های مهم کرنل لینوکس و ویژگی‌های کلیدی آنها عبارتند از:</p>
<p><strong>لینوکس 3.0</strong> (جولای 2011):</p>
<ul>
<li>پشتیبانی از Xen virtualization به صورت native</li>
<li>پشتیبانی از سخت‌افزارهای ARM جدید</li>
<li>بهبودهای سیستم فایل Btrfs</li>
<li>درایورهای گرافیکی بهبود یافته</li>
</ul>
<p><strong>لینوکس 4.0</strong> (آوریل 2015):</p>
<ul>
<li>پشتیبانی از live patching (به‌روزرسانی کرنل بدون نیاز به راه‌اندازی مجدد)</li>
<li>بهبود قابلیت‌های مجازی‌سازی</li>
<li>پشتیبانی از CrossTalk برای اشتراک‌گذاری داده بین پردازنده‌های اینتل</li>
<li>سیستم فایل OverlayFS</li>
</ul>
<p><strong>لینوکس 5.0</strong> (مارس 2019):</p>
<ul>
<li>پشتیبانی از AMD FreeSync</li>
<li>پشتیبانی از Adiantum برای رمزگذاری فایل‌سیستم</li>
<li>بهبود مدیریت انرژی</li>
<li>بهبودهای امنیتی برای مقابله با آسیب‌پذیری‌های Spectre و Meltdown</li>
<li>پشتیبانی بهتر از سخت‌افزارهای Raspberry Pi</li>
</ul>
<p><strong>لینوکس 6.0</strong> (اکتبر 2022):</p>
<ul>
<li>پشتیبانی بهبود یافته از پردازنده‌های RISC-V</li>
<li>بهبود درایورهای شبکه و کارت گرافیک</li>
<li>فایل‌سیستم بهبود یافته - ext4 و Btrfs با عملکرد بهتر</li>
<li>قابلیت Multi-Gen LRU برای مدیریت حافظه بهینه‌تر</li>
<li>پشتیبانی PCI باریه (PCI Device Feature)</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از پشتیبانی Live Patching در لینوکس 4.0
 * kernel/livepatch/core.c
 */</span>
<span class="hljs-type">int</span> klp_enable_patch(struct klp_patch *<span class="hljs-keyword">patch</span>)
{
    <span class="hljs-type">int</span> ret;

    <span class="hljs-keyword">if</span> (WARN_ON(<span class="hljs-keyword">patch</span>-&gt;enabled))
        <span class="hljs-keyword">return</span> -EINVAL;

    <span class="hljs-comment">/* Connect functions to their targets */</span>
    ret = klp_init_patch(<span class="hljs-keyword">patch</span>);
    <span class="hljs-keyword">if</span> (ret)
        <span class="hljs-keyword">return</span> ret;

    <span class="hljs-comment">/*
     * Enforce mutual exclusion with other patches being
     * (un)registered and other registration/unregistration
     * operations.
     */</span>
    mutex_lock(&amp;klp_mutex);

    ret = klp_prep_objects(<span class="hljs-keyword">patch</span>);
    <span class="hljs-keyword">if</span> (ret)
        goto err;

    <span class="hljs-comment">/* Mark the patch as enabled */</span>
    <span class="hljs-keyword">patch</span>-&gt;enabled = <span class="hljs-literal">true</span>;

    mutex_unlock(&amp;klp_mutex);

    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;

err:
    mutex_unlock(&amp;klp_mutex);
    klp_cleanup_patch(<span class="hljs-keyword">patch</span>);
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<h3 id="-api-abi">تکامل API و ABI</h3>
<p>یکی از ویژگی‌های مهم کرنل لینوکس، تعهد آن به حفظ سازگاری برنامه‌های کاربردی (API stability) و سازگاری باینری برنامه‌ها (ABI stability) است. این بدان معناست که برنامه‌های نوشته شده برای نسخه‌های قدیمی‌تر لینوکس باید بتوانند روی نسخه‌های جدیدتر نیز بدون تغییر اجرا شوند.</p>
<p><strong>API (Application Programming Interface)</strong>:</p>
<ul>
<li>واسط برنامه‌نویسی که برنامه‌ها برای تعامل با کرنل از آن استفاده می‌کنند</li>
<li>در لینوکس، این شامل فراخوانی‌های سیستمی (system calls) است</li>
<li>کرنل لینوکس تلاش می‌کند API را برای برنامه‌های فضای کاربر ثابت نگه دارد</li>
</ul>
<p><strong>ABI (Application Binary Interface)</strong>:</p>
<ul>
<li>قراردادهای سطح پایین‌تر که سازگاری باینری را تضمین می‌کنند</li>
<li>شامل فرمت داده‌ها، قراردادهای فراخوانی (calling conventions) و غیره</li>
<li>در لینوکس، ABI باید ثابت بماند تا برنامه‌های کامپایل شده همچنان کار کنند</li>
</ul>
<p><strong>اصل &quot;Don&#39;t Break Userspace&quot;</strong>:</p>
<ul>
<li>یک قانون اساسی در توسعه کرنل لینوکس</li>
<li>حتی اگر کد موجود مشکل‌دار باشد، تغییرات نباید برنامه‌های کاربردی موجود را بشکنند</li>
<li>لینوس توروالدز: &quot;ما هرگز، تحت هیچ شرایطی، فضای کاربر را نمی‌شکنیم.&quot;</li>
</ul>
<p>با این حال، ABI داخلی کرنل (یعنی واسط بین ماژول‌های کرنل و کرنل اصلی) تضمین نمی‌شود و می‌تواند بین نسخه‌های مختلف تغییر کند. این بدان معناست که ماژول‌های کرنل معمولاً نیاز به کامپایل مجدد برای هر نسخه کرنل دارند.</p>
<p><strong>استراتژی‌های حفظ سازگاری</strong>:</p>
<ul>
<li>افزودن API/ABI جدید به جای تغییر موارد موجود</li>
<li>استفاده از versioned symbols و compatibility layers</li>
<li>استفاده از deprecated warnings قبل از حذف هر مورد قدیمی</li>
</ul>
<p>این تعهد به سازگاری، یکی از دلایل مهم موفقیت و پذیرش گسترده لینوکس بوده است. کاربران و توسعه‌دهندگان می‌توانند با اطمینان به کرنل لینوکس ارتقا دهند، بدون نگرانی از اینکه برنامه‌های آنها دیگر کار نکند.</p>
<h2 id="-">تاثیر کرنل لینوکس بر دنیای کامپیوتر</h2>
<p>کرنل لینوکس یکی از مهم‌ترین پروژه‌های نرم‌افزاری تاریخ است که تأثیر عمیقی بر دنیای فناوری اطلاعات و جامعه داشته است. از سرورهای وب گرفته تا تلفن‌های هوشمند، از ابررایانه‌ها تا دستگاه‌های اینترنت اشیا، لینوکس به یک زیرساخت بنیادی برای اکوسیستم دیجیتال مدرن تبدیل شده است. در این بخش، تأثیرات گسترده کرنل لینوکس را بررسی می‌کنیم.</p>
<h3 id="-">توزیع‌های لینوکس</h3>
<p>توزیع‌های لینوکس، مجموعه‌ای از سیستم‌عامل‌های کامل هستند که بر اساس کرنل لینوکس ساخته شده‌اند. این توزیع‌ها با اضافه کردن ابزارها، کتابخانه‌ها، مدیر بسته و نرم‌افزارهای کاربردی به کرنل لینوکس، یک سیستم‌عامل کامل ارائه می‌دهند.</p>
<p><strong>توزیع‌های اصلی و ویژگی‌های آنها</strong>:</p>
<ol>
<li><p><strong>Debian</strong>:</p>
<ul>
<li>یکی از قدیمی‌ترین توزیع‌ها (1993)</li>
<li>کاملاً متن‌باز و غیرتجاری</li>
<li>مدیر بسته APT</li>
<li>تمرکز بر پایداری و آزادی نرم‌افزار</li>
<li>پایه‌ای برای توزیع‌های دیگر مانند Ubuntu</li>
</ul>
</li>
<li><p><strong>Ubuntu</strong>:</p>
<ul>
<li>محبوب‌ترین توزیع برای کاربران دسکتاپ</li>
<li>بر اساس Debian ساخته شده</li>
<li>تمرکز بر سهولت استفاده</li>
<li>انتشار منظم هر 6 ماه با نسخه‌های LTS هر 2 سال</li>
</ul>
</li>
<li><p><strong>Red Hat Enterprise Linux (RHEL)</strong>:</p>
<ul>
<li>توزیع تجاری با پشتیبانی سازمانی</li>
<li>تمرکز بر پایداری و امنیت برای محیط‌های سازمانی</li>
<li>مدیر بسته RPM</li>
<li>سیستم امنیتی SELinux</li>
</ul>
</li>
<li><p><strong>Fedora</strong>:</p>
<ul>
<li>پروژه جامعه‌محور حمایت شده توسط Red Hat</li>
<li>آزمایشگاه نوآوری برای ویژگی‌های جدید</li>
<li>اغلب ویژگی‌های آن بعداً به RHEL راه می‌یابند</li>
</ul>
</li>
<li><p><strong>SUSE Linux Enterprise / openSUSE</strong>:</p>
<ul>
<li>توزیع محبوب در اروپا</li>
<li>ابزارهای مدیریتی پیشرفته مانند YaST</li>
<li>نسخه‌های تجاری و جامعه‌محور</li>
</ul>
</li>
<li><p><strong>Arch Linux</strong>:</p>
<ul>
<li>مدل انتشار rolling-release (همیشه به‌روز)</li>
<li>فلسفه KISS (Keep It Simple, Stupid)</li>
<li>مستندات عالی و کنترل کامل برای کاربر</li>
</ul>
</li>
<li><p><strong>Alpine Linux</strong>:</p>
<ul>
<li>بسیار سبک و امن</li>
<li>استفاده گسترده در کانتینرهای Docker</li>
<li>استفاده از musl libc به جای glibc استاندارد</li>
</ul>
</li>
</ol>
<p>توزیع‌های لینوکس نشان می‌دهند که چگونه یک کرنل واحد می‌تواند برای کاربردهای مختلف سفارشی‌سازی شود، از گوشی‌های هوشمند گرفته تا ابررایانه‌ها. این تنوع و انعطاف‌پذیری یکی از دلایل اصلی موفقیت لینوکس است.</p>
<h3 id="-">اندروید و سیستم‌عامل‌های مبتنی بر لینوکس</h3>
<p>اندروید، محبوب‌ترین سیستم‌عامل موبایل جهان، بر پایه کرنل لینوکس ساخته شده است. این موفقیت چشمگیر نشان‌دهنده انعطاف‌پذیری و مقیاس‌پذیری کرنل لینوکس است.</p>
<p><strong>اندروید و کرنل لینوکس</strong>:</p>
<ul>
<li>اندروید یک نسخه اصلاح شده از کرنل لینوکس را استفاده می‌کند</li>
<li>تغییرات خاص اندروید شامل Binder IPC، wakelocks و سایر ویژگی‌های مدیریت انرژی است</li>
<li>بسیاری از این تغییرات به تدریج به کرنل اصلی لینوکس راه یافته‌اند</li>
</ul>
<p><strong>گستره نفوذ اندروید</strong>:</p>
<ul>
<li>بیش از 2.5 میلیارد دستگاه فعال در سراسر جهان</li>
<li>حدود 70% از سهم بازار تلفن‌های هوشمند</li>
<li>گسترش به تبلت‌ها، تلویزیون‌ها، ساعت‌های هوشمند و سیستم‌های خودرو</li>
</ul>
<p><strong>سایر سیستم‌عامل‌های مبتنی بر لینوکس</strong>:</p>
<ol>
<li><p><strong>Chrome OS</strong>:</p>
<ul>
<li>سیستم‌عامل Google برای لپ‌تاپ‌ها</li>
<li>بر اساس کرنل لینوکس و Gentoo Linux</li>
<li>تمرکز بر برنامه‌های وب و امنیت</li>
</ul>
</li>
<li><p><strong>تایزن (Tizen)</strong>:</p>
<ul>
<li>سیستم‌عامل توسعه یافته توسط سامسونگ و اینتل</li>
<li>استفاده در ساعت‌های هوشمند، تلویزیون‌ها و لوازم خانگی هوشمند</li>
</ul>
</li>
<li><p><strong>Sailfish OS</strong>:</p>
<ul>
<li>سیستم‌عامل موبایل توسعه یافته توسط Jolla</li>
<li>ترکیبی از کد متن‌باز و اختصاصی</li>
</ul>
</li>
<li><p><strong>سیستم‌عامل‌های خودرو</strong>:</p>
<ul>
<li>Automotive Grade Linux (AGL)</li>
<li>سیستم‌های سرگرمی و اطلاعاتی خودرو (infotainment)</li>
</ul>
</li>
</ol>
<p>کرنل لینوکس با قابلیت سفارشی‌سازی بالا، کارایی خوب و هزینه صفر مجوز، به انتخابی عالی برای توسعه‌دهندگان سیستم‌عامل‌های مختلف تبدیل شده است. موفقیت اندروید نشان داد که لینوکس می‌تواند به خوبی در دنیای دستگاه‌های تعبیه‌شده و موبایل با منابع محدود عمل کند.</p>
<h3 id="-">لینوکس در سرورها و مراکز داده</h3>
<p>یکی از موفق‌ترین حوزه‌های کاربرد لینوکس، سرورها و مراکز داده است. امروزه، لینوکس پلتفرم غالب برای میزبانی وب، خدمات ابری و بسیاری از برنامه‌های سازمانی است.</p>
<p><strong>آمار و ارقام</strong>:</p>
<ul>
<li>بیش از 90% از سرورهای وب جهان از لینوکس استفاده می‌کنند</li>
<li>تمام 500 ابررایانه برتر جهان از لینوکس استفاده می‌کنند</li>
<li>اکثریت قریب به اتفاق زیرساخت‌های ابری عمومی روی لینوکس اجرا می‌شوند</li>
<li>بیش از 75% از سرورهای DNS اینترنت از لینوکس استفاده می‌کنند</li>
</ul>
<p><strong>دلایل موفقیت لینوکس در سرورها</strong>:</p>
<ol>
<li><p><strong>پایداری و کارایی</strong>:</p>
<ul>
<li>زمان‌های کارکرد (uptime) طولانی‌مدت</li>
<li>مدیریت کارآمد منابع سیستم</li>
<li>مقیاس‌پذیری عالی از سرورهای کوچک تا کلاسترهای بزرگ</li>
</ul>
</li>
<li><p><strong>امنیت</strong>:</p>
<ul>
<li>مدل امنیتی قوی</li>
<li>به‌روزرسانی‌های امنیتی سریع</li>
<li>جامعه بزرگ برای تشخیص و اصلاح آسیب‌پذیری‌ها</li>
</ul>
</li>
<li><p><strong>انعطاف‌پذیری</strong>:</p>
<ul>
<li>سفارشی‌سازی برای نیازهای خاص</li>
<li>پشتیبانی از انواع مختلف سخت‌افزار</li>
<li>مناسب برای workloadهای متنوع</li>
</ul>
</li>
<li><p><strong>هزینه</strong>:</p>
<ul>
<li>بدون هزینه مجوز برای کرنل و بسیاری از نرم‌افزارها</li>
<li>کاهش هزینه‌های سخت‌افزاری به دلیل کارایی بهتر</li>
<li>صرفه‌جویی در هزینه‌های پشتیبانی با اتوماسیون</li>
</ul>
</li>
</ol>
<p><strong>فناوری‌های کلیدی لینوکس در سرورها</strong>:</p>
<ul>
<li><strong>کانتینرها</strong> (Docker, LXC) و ارکستراسیون آنها (Kubernetes)</li>
<li><strong>سیستم‌های فایل مقیاس‌پذیر</strong> (XFS, ZFS, Btrfs)</li>
<li><strong>فریم‌ورک‌های شبکه</strong> با کارایی بالا (DPDK, eBPF)</li>
<li><strong>پشتیبانی از ویرچوالایزیشن</strong> (KVM, Xen)</li>
</ul>
<p>لینوکس به همراه نرم‌افزارهای متن‌باز دیگر مانند Apache, MySQL/MariaDB, PostgreSQL و PHP/Python/Node.js، پایه و اساس بخش بزرگی از زیرساخت وب و اینترنت امروزی را تشکیل می‌دهند. حتی شرکت‌هایی مانند مایکروسافت که زمانی رقیب سرسخت لینوکس بودند، امروزه آن را در خدمات ابری خود مانند Azure ارائه می‌دهند.</p>
<h3 id="-">اینترنت اشیا و سیستم‌های نهفته</h3>
<p>یکی از حوزه‌های رو به رشد کاربرد لینوکس، دستگاه‌های اینترنت اشیا (IoT) و سیستم‌های نهفته (embedded systems) است. انعطاف‌پذیری، مقیاس‌پذیری و کارایی کرنل لینوکس آن را به گزینه‌ای عالی برای این دستگاه‌ها تبدیل کرده است.</p>
<p><strong>کاربردهای لینوکس در IoT و سیستم‌های نهفته</strong>:</p>
<ol>
<li><p><strong>دستگاه‌های هوشمند خانگی</strong>:</p>
<ul>
<li>ترموستات‌ها و سیستم‌های تهویه هوشمند</li>
<li>سیستم‌های امنیتی خانگی</li>
<li>دستیارهای صوتی (مانند Amazon Echo)</li>
<li>روترها و دستگاه‌های شبکه خانگی</li>
</ul>
</li>
<li><p><strong>سیستم‌های صنعتی</strong>:</p>
<ul>
<li>اتوماسیون کارخانه‌ها</li>
<li>سیستم‌های کنترل صنعتی</li>
<li>تجهیزات مانیتورینگ و نظارت</li>
<li>ربات‌های صنعتی</li>
</ul>
</li>
<li><p><strong>وسایل نقلیه</strong>:</p>
<ul>
<li>سیستم‌های سرگرمی و اطلاعاتی خودرو</li>
<li>سیستم‌های ناوبری</li>
<li>خودروهای خودران</li>
<li>مدیریت ناوگان حمل و نقل</li>
</ul>
</li>
<li><p><strong>تجهیزات پزشکی</strong>:</p>
<ul>
<li>دستگاه‌های مانیتورینگ بیمار</li>
<li>تجهیزات تشخیصی</li>
<li>سیستم‌های تصویربرداری پزشکی</li>
</ul>
</li>
</ol>
<p><strong>مزایای لینوکس برای سیستم‌های نهفته</strong>:</p>
<ul>
<li><strong>مقیاس‌پذیری</strong>: می‌تواند برای دستگاه‌های بسیار کوچک با منابع محدود بهینه‌سازی شود</li>
<li><strong>مدیریت انرژی</strong>: ویژگی‌های مدیریت انرژی پیشرفته برای دستگاه‌های باتری‌دار</li>
<li><strong>پشتیبانی از سخت‌افزارهای متنوع</strong>: درایورها برای طیف گسترده‌ای از میکروکنترلرها و چیپ‌ست‌ها</li>
<li><strong>امنیت</strong>: مکانیزم‌های امنیتی قوی برای دستگاه‌های متصل به اینترنت</li>
<li><strong>به‌روزرسانی از راه دور</strong>: پشتیبانی از به‌روزرسانی‌های OTA (Over-The-Air)</li>
</ul>
<p><strong>توزیع‌های لینوکس برای IoT و سیستم‌های نهفته</strong>:</p>
<ul>
<li><strong>Yocto Project</strong>: چارچوبی برای ایجاد توزیع‌های لینوکس سفارشی برای سیستم‌های نهفته</li>
<li><strong>Buildroot</strong>: ابزار سبک‌تر برای ایجاد سیستم‌های لینوکس نهفته</li>
<li><strong>Ubuntu Core</strong>: توزیع لینوکس مخصوص IoT با تمرکز بر امنیت و به‌روزرسانی</li>
<li><strong>Raspbian/Raspberry Pi OS</strong>: برای دستگاه‌های Raspberry Pi</li>
</ul>
<p>با گسترش اینترنت اشیا و هوشمندسازی دستگاه‌های مختلف، نقش لینوکس در این حوزه روز به روز پررنگ‌تر می‌شود. پیش‌بینی می‌شود تا سال 2030، بیش از 50 میلیارد دستگاه IoT در جهان وجود داشته باشد که بخش قابل توجهی از آنها از نسخه‌ای از لینوکس استفاده خواهند کرد.</p>
<h3 id="-">ابررایانه‌ها</h3>
<p>یکی از موفقیت‌های چشمگیر لینوکس، تسلط کامل آن بر دنیای ابررایانه‌ها (supercomputers) است. از سال 2017، 100% از 500 ابررایانه برتر جهان (فهرست TOP500) از لینوکس استفاده می‌کنند، که نشان‌دهنده برتری بی‌چون و چرای این سیستم‌عامل در محاسبات با کارایی بالا (HPC - High-Performance Computing) است.</p>
<p><strong>دلایل موفقیت لینوکس در ابررایانه‌ها</strong>:</p>
<ol>
<li><p><strong>مقیاس‌پذیری</strong>: </p>
<ul>
<li>توانایی مدیریت هزاران هسته پردازنده</li>
<li>پشتیبانی از حجم عظیم حافظه (پتابایت)</li>
<li>مدیریت کارآمد منابع</li>
</ul>
</li>
<li><p><strong>کارایی</strong>:</p>
<ul>
<li>سربار (overhead) کم سیستم‌عامل</li>
<li>بهینه‌سازی برای workloadهای محاسباتی</li>
<li>پشتیبانی از آخرین فناوری‌های سخت‌افزاری</li>
</ul>
</li>
<li><p><strong>انعطاف‌پذیری</strong>:</p>
<ul>
<li>قابلیت سفارشی‌سازی کامل کرنل و کتابخانه‌ها</li>
<li>پشتیبانی از معماری‌های مختلف (x86-64, ARM, POWER, RISC-V)</li>
<li>امکان حذف اجزای غیرضروری</li>
</ul>
</li>
<li><p><strong>اکوسیستم نرم‌افزاری</strong>:</p>
<ul>
<li>ابزارها و کتابخانه‌های متن‌باز برای HPC</li>
<li>پشتیبانی از استانداردهای موازی‌سازی مانند MPI و OpenMP</li>
<li>بسترهایی برای یادگیری ماشین و هوش مصنوعی</li>
</ul>
</li>
</ol>
<p><strong>ویژگی‌های کرنل لینوکس مهم برای ابررایانه‌ها</strong>:</p>
<ul>
<li><strong>NUMA (Non-Uniform Memory Access)</strong>: مدیریت حافظه برای سیستم‌های چندپردازنده‌ای بزرگ</li>
<li><strong>زمانبندی پیشرفته</strong>: زمانبندی بهینه فرآیندها در سیستم‌های با تعداد زیادی پردازنده</li>
<li><strong>Huge Pages</strong>: بهبود کارایی با استفاده از صفحات حافظه بزرگتر</li>
<li><strong>cgroups و namespaces</strong>: مدیریت و ایزوله کردن منابع برای کاربران مختلف</li>
<li><strong>شبکه با کارایی بالا</strong>: پشتیبانی از InfiniBand و دیگر فناوری‌های شبکه با سرعت بالا</li>
</ul>
<p><strong>نمونه‌های برجسته ابررایانه‌های لینوکس</strong>:</p>
<ul>
<li><strong>Frontier</strong> (آمریکا): اولین ابررایانه اگزاسکیل جهان با قدرت محاسباتی بیش از یک exaFLOPS</li>
<li><strong>Fugaku</strong> (ژاپن): یکی از قدرتمندترین ابررایانه‌های جهان</li>
<li><strong>Summit</strong> (آمریکا): طراحی شده توسط IBM برای تحقیقات پیشرفته</li>
<li><strong>Sierra</strong> (آمریکا): استفاده شده برای شبیه‌سازی‌های هسته‌ای</li>
<li><strong>Sunway TaihuLight</strong> (چین): یکی از ابررایانه‌های پیشرو با معماری پردازنده بومی</li>
</ul>
<p>حتی ابررایانه‌های جدید با معماری‌های غیرمتعارف مانند پردازنده‌های کوانتومی و نورونی نیز معمولاً از لینوکس برای سیستم‌های کنترل و مدیریت خود استفاده می‌کنند. این نشان می‌دهد که لینوکس توانایی سازگاری با پیشرفته‌ترین فناوری‌های محاسباتی را دارد.</p>
<h3 id="-">تأثیر بر صنعت و جامعه</h3>
<p>فراتر از جنبه‌های فنی، کرنل لینوکس تأثیر عمیقی بر صنعت نرم‌افزار و جامعه به طور کلی داشته است. این تأثیرات شامل تغییر در مدل‌های کسب‌و‌کار، روش‌های توسعه نرم‌افزار و حتی جنبه‌های اجتماعی و اقتصادی است.</p>
<p><strong>تأثیر بر مدل‌های کسب‌و‌کار</strong>:</p>
<ol>
<li><p><strong>نرم‌افزار متن‌باز به عنوان یک مدل کسب‌و‌کار</strong>:</p>
<ul>
<li>شرکت‌هایی مانند Red Hat (اکنون بخشی از IBM) با ارائه خدمات و پشتیبانی برای نرم‌افزارهای متن‌باز به موفقیت‌های بزرگ دست یافته‌اند</li>
<li>ظهور مدل &quot;open core&quot; که در آن هسته محصول متن‌باز است اما ویژگی‌های پیشرفته به صورت تجاری ارائه می‌شوند</li>
</ul>
</li>
<li><p><strong>کاهش هزینه‌های توسعه</strong>:</p>
<ul>
<li>شرکت‌ها به جای توسعه سیستم‌عامل‌های اختصاصی، از لینوکس استفاده می‌کنند</li>
<li>اشتراک‌گذاری هزینه‌های نگهداری و توسعه بین شرکت‌های مختلف</li>
</ul>
</li>
<li><p><strong>نوآوری مشارکتی</strong>:</p>
<ul>
<li>حتی رقبا در برخی زمینه‌ها با یکدیگر همکاری می‌کنند</li>
<li>ایجاد بنیادهای صنعتی مانند Linux Foundation برای مدیریت پروژه‌های متن‌باز</li>
</ul>
</li>
</ol>
<p><strong>تأثیر بر روش‌های توسعه نرم‌افزار</strong>:</p>
<ol>
<li><p><strong>توسعه توزیع‌شده</strong>:</p>
<ul>
<li>الگوی توسعه لینوکس با هزاران توسعه‌دهنده از سراسر جهان، مدلی برای پروژه‌های بزرگ شده است</li>
<li>ابزارهایی مانند Git (که برای توسعه لینوکس ایجاد شد) استاندارد صنعت شده‌اند</li>
</ul>
</li>
<li><p><strong>معیارهای کیفیت</strong>:</p>
<ul>
<li>فرآیندهای بررسی کد و تضمین کیفیت در لینوکس الهام‌بخش بسیاری از پروژه‌های دیگر بوده است</li>
<li>استانداردهای کدنویسی و مستندسازی دقیق</li>
</ul>
</li>
<li><p><strong>CI/CD و DevOps</strong>:</p>
<ul>
<li>بسیاری از روش‌های DevOps مدرن، از فرآیندهای توسعه لینوکس الهام گرفته‌اند</li>
<li>اتوماسیون تست و استقرار</li>
</ul>
</li>
</ol>
<p><strong>تأثیر اجتماعی و اقتصادی</strong>:</p>
<ol>
<li><p><strong>دسترسی جهانی به فناوری</strong>:</p>
<ul>
<li>کشورها و جوامع با منابع محدود می‌توانند از نرم‌افزارهای پیشرفته بدون هزینه استفاده کنند</li>
<li>کاهش شکاف دیجیتالی</li>
</ul>
</li>
<li><p><strong>آموزش و پژوهش</strong>:</p>
<ul>
<li>دانشگاه‌ها و مؤسسات آموزشی از لینوکس برای آموزش علوم کامپیوتر استفاده می‌کنند</li>
<li>دسترسی به کد منبع کرنل، امکان پژوهش‌های پیشرفته را فراهم می‌کند</li>
</ul>
</li>
<li><p><strong>ایجاد مشاغل و فرصت‌های اقتصادی</strong>:</p>
<ul>
<li>رشد اکوسیستم خدمات و محصولات مبتنی بر لینوکس</li>
<li>امکان کارآفرینی با هزینه کمتر به دلیل عدم نیاز به پرداخت هزینه مجوز</li>
</ul>
</li>
<li><p><strong>استقلال فناوری</strong>:</p>
<ul>
<li>کشورها می‌توانند بدون وابستگی به شرکت‌های خارجی، زیرساخت‌های حیاتی خود را توسعه دهند</li>
<li>امکان بررسی کد منبع برای اطمینان از عدم وجود درهای پشتی (backdoors)</li>
</ul>
</li>
</ol>
<p>موفقیت لینوکس نشان داده است که مدل توسعه متن‌باز می‌تواند نه تنها از نظر فنی بلکه از نظر اقتصادی و اجتماعی نیز موفق باشد. این موفقیت الهام‌بخش هزاران پروژه متن‌باز دیگر شده است که امروزه بخش مهمی از زیرساخت دیجیتال ما را تشکیل می‌دهند.</p>
<h3 id="-">نوآوری‌های الهام گرفته از لینوکس</h3>
<p>موفقیت لینوکس و فلسفه توسعه آن، الهام‌بخش بسیاری از نوآوری‌ها و پروژه‌های دیگر در دنیای فناوری اطلاعات بوده است. لینوکس و جامعه آن، مفاهیم و ابزارهایی را معرفی کرده‌اند که فراتر از خود کرنل، تأثیر گسترده‌ای بر صنعت نرم‌افزار داشته‌اند.</p>
<p><strong>ابزارها و فناوری‌های الهام گرفته از لینوکس</strong>:</p>
<ol>
<li><p><strong>Git</strong>:</p>
<ul>
<li>سیستم کنترل نسخه توزیع‌شده که توسط لینوس توروالدز برای مدیریت کد کرنل لینوکس ایجاد شد</li>
<li>امروزه استاندارد صنعت برای مدیریت کد منبع است</li>
<li>پایه‌ای برای پلتفرم‌هایی مانند GitHub و GitLab</li>
</ul>
</li>
<li><p><strong>کانتینریزیشن</strong>:</p>
<ul>
<li>فناوری کانتینرها (Docker, LXC) بر اساس ویژگی‌های کرنل لینوکس مانند cgroups و namespaces ساخته شده است</li>
<li>انقلابی در نحوه توسعه، استقرار و مقیاس‌گذاری نرم‌افزارها ایجاد کرده است</li>
<li>پایه‌ای برای رویکردهای مدرن DevOps و microservices</li>
</ul>
</li>
<li><p><strong>eBPF (extended Berkeley Packet Filter)</strong>:</p>
<ul>
<li>مکانیزم اجرای کد ایمن در فضای کرنل</li>
<li>انقلابی در مانیتورینگ، امنیت شبکه و بهینه‌سازی کارایی</li>
<li>الهام‌بخش رویکردهای جدید به برنامه‌نویسی سیستمی</li>
</ul>
</li>
<li><p><strong>مکانیزم‌های مجازی‌سازی</strong>:</p>
<ul>
<li>KVM (Kernel-based Virtual Machine) بخشی از کرنل لینوکس است</li>
<li>پایه‌ای برای بسیاری از پلتفرم‌های ابری و مجازی‌سازی</li>
</ul>
</li>
</ol>
<p><strong>مفاهیم و رویکردها</strong>:</p>
<ol>
<li><p><strong>مدل توسعه متن‌باز</strong>:</p>
<ul>
<li>&quot;مدل بازار&quot; (در مقابل &quot;مدل کلیسای جامع&quot;) که توسط اریک ریموند برای توصیف توسعه لینوکس معرفی شد</li>
<li>الهام‌بخش هزاران پروژه متن‌باز دیگر</li>
<li>پایه‌ای برای همکاری در مقیاس بزرگ</li>
</ul>
</li>
<li><p><strong>انتشار زودهنگام و مکرر</strong>:</p>
<ul>
<li>فلسفه &quot;release early, release often&quot; که در توسعه لینوکس پیروی می‌شود</li>
<li>تأثیرگذار بر متدولوژی‌های چابک (Agile) و DevOps</li>
</ul>
</li>
<li><p><strong>&quot;Given enough eyeballs, all bugs are shallow&quot; (قانون لینوس)</strong>:</p>
<ul>
<li>اصلی که بیان می‌کند با تعداد کافی توسعه‌دهنده، تمام مشکلات قابل حل هستند</li>
<li>پایه‌ای برای رویکردهای بررسی همتا (peer review) و توسعه مشارکتی</li>
</ul>
</li>
<li><p><strong>&quot;Infrastructure as Code&quot;</strong>:</p>
<ul>
<li>رویکرد مدیریت و پیکربندی زیرساخت با استفاده از تکنیک‌های توسعه نرم‌افزار</li>
<li>ریشه در روش‌های مدیریت پیکربندی لینوکس دارد</li>
</ul>
</li>
</ol>
<p><strong>پروژه‌های بزرگ الهام گرفته از لینوکس</strong>:</p>
<ol>
<li><p><strong>بنیاد نرم‌افزار آزاد (FSF) و پروژه GNU</strong>:</p>
<ul>
<li>گرچه قبل از لینوکس وجود داشتند، اما موفقیت لینوکس به آنها انرژی جدیدی بخشید</li>
<li>همکاری GNU/Linux الگویی برای همکاری‌های آینده شد</li>
</ul>
</li>
<li><p><strong>Apache Software Foundation</strong>:</p>
<ul>
<li>الهام گرفته از مدل حاکمیت و توسعه لینوکس</li>
<li>میزبان ده‌ها پروژه متن‌باز موفق</li>
</ul>
</li>
<li><p><strong>Creative Commons</strong>:</p>
<ul>
<li>بسط مفهوم متن‌باز به فراتر از نرم‌افزار</li>
<li>الهام گرفته از مفاهیم مجوزهای متن‌باز مانند GPL</li>
</ul>
</li>
<li><p><strong>Mozilla Foundation</strong>:</p>
<ul>
<li>متن‌باز کردن مرورگر Netscape به عنوان Mozilla/Firefox</li>
<li>الهام گرفته از موفقیت مدل توسعه لینوکس</li>
</ul>
</li>
</ol>
<p>تأثیر لینوکس فراتر از کرنل و حتی فراتر از نرم‌افزار گسترش یافته است. ایده‌های اساسی آن - همکاری باز، شفافیت، توسعه توزیع‌شده، و اشتراک‌گذاری دانش - در زمینه‌های مختلف از تولید محتوا گرفته تا طراحی سخت‌افزار، از علوم داده تا آموزش، نفوذ کرده‌اند. لینوکس به یک الگوی موفق برای چگونگی همکاری انسان‌ها در مقیاس جهانی برای ایجاد محصولات پیچیده و با کیفیت بالا تبدیل شده است.</p>
<h2 id="-">نسخه‌های مهم کرنل لینوکس</h2>
<p>تکامل کرنل لینوکس از یک پروژه شخصی به یک سیستم‌عامل جهانی، روندی پیچیده و تدریجی بوده است. در طول بیش از سه دهه، نسخه‌های متعددی از کرنل لینوکس منتشر شده‌اند که هر کدام نقاط عطف مهمی در تاریخچه این سیستم‌عامل محسوب می‌شوند. در این بخش، نسخه‌های کلیدی کرنل لینوکس و ویژگی‌های مهم آنها را بررسی می‌کنیم.</p>
<h3 id="-0-01-">لینوکس 0.01 و اولین نسخه‌ها</h3>
<p>نخستین نسخه عمومی کرنل لینوکس، نسخه 0.01، در 17 سپتامبر 1991 توسط لینوس توروالدز منتشر شد. این نسخه ابتدایی دارای ویژگی‌های محدودی بود:</p>
<ul>
<li>تنها روی پردازنده‌های Intel 80386 کار می‌کرد</li>
<li>حدود 10,000 خط کد داشت</li>
<li>پشتیبانی محدود از سخت‌افزار</li>
<li>نیاز به Minix برای کامپایل و نصب</li>
<li>فاقد پشتیبانی شبکه</li>
<li>فاقد پشتیبانی از چندوظیفه‌ای پیشگیرانه کامل</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از کد هسته اولیه لینوکس 
 * init/main.c در لینوکس 0.01
 */</span>
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">main</span>(void)
{
    <span class="hljs-comment">/* 
     * راه‌اندازی اولیه سیستم
     * این کد بسیار ساده‌تر از نسخه‌های کنونی است
     */</span>
    <span class="hljs-selector-tag">mem_init</span>();       <span class="hljs-comment">/* مقداردهی اولیه مدیریت حافظه */</span>
    <span class="hljs-selector-tag">trap_init</span>();      <span class="hljs-comment">/* راه‌اندازی وقفه‌ها */</span>
    <span class="hljs-selector-tag">blk_dev_init</span>();   <span class="hljs-comment">/* مقداردهی اولیه دستگاه‌های بلاکی */</span>
    <span class="hljs-selector-tag">chr_dev_init</span>();   <span class="hljs-comment">/* مقداردهی اولیه دستگاه‌های کاراکتری */</span>
    <span class="hljs-selector-tag">tty_init</span>();       <span class="hljs-comment">/* راه‌اندازی ترمینال */</span>
    <span class="hljs-selector-tag">time_init</span>();      <span class="hljs-comment">/* مقداردهی اولیه زمان سیستم */</span>
    <span class="hljs-selector-tag">sched_init</span>();     <span class="hljs-comment">/* راه‌اندازی زمانبند */</span>

    <span class="hljs-comment">/* راه‌اندازی اولین فرآیند */</span>
    <span class="hljs-selector-tag">if</span> (!fork()) {    <span class="hljs-comment">/* فرآیند فرزند */</span>
        <span class="hljs-selector-tag">init</span>();       <span class="hljs-comment">/* اجرای فرآیند init */</span>
    }

    <span class="hljs-comment">/* حلقه بیکاری برای فرآیند صفر */</span>
    <span class="hljs-selector-tag">for</span>(;;) <span class="hljs-selector-tag">pause</span>();
}
</code></pre>
<p>پس از نسخه 0.01، نسخه‌های بعدی به سرعت منتشر شدند:</p>
<ul>
<li><strong>لینوکس 0.02</strong> (اکتبر 1991): اولین نسخه‌ای که می‌توانست GCC را اجرا کند</li>
<li><strong>لینوکس 0.03</strong> (اکتبر 1991): بهبود پشتیبانی از ترمینال</li>
<li><strong>لینوکس 0.10</strong> (دسامبر 1991): پشتیبانی بهتر از دستگاه‌های ذخیره‌سازی</li>
<li><strong>لینوکس 0.11</strong> (دسامبر 1991): اولین نسخه‌ای که می‌توانست مستقل از Minix نصب شود</li>
<li><strong>لینوکس 0.12</strong> (ژانویه 1992): پشتیبانی از سیستم فایل Minix</li>
</ul>
<p>در این مرحله، لینوکس هنوز یک سیستم‌عامل آزمایشی و ابتدایی بود، اما توجه جامعه برنامه‌نویسان را به خود جلب کرده بود. توسعه‌دهندگان از سراسر جهان شروع به مشارکت در توسعه آن کردند، و سرعت تکامل لینوکس به طور قابل توجهی افزایش یافت.</p>
<h3 id="-1-0-">لینوکس 1.0 و تثبیت پروژه</h3>
<p>نسخه 1.0 کرنل لینوکس در 14 مارس 1994 منتشر شد. این انتشار نقطه عطفی در تاریخ لینوکس بود و نشان‌دهنده بلوغ نسبی پروژه:</p>
<ul>
<li>حدود 176,000 خط کد</li>
<li>پشتیبانی از سیستم فایل ext</li>
<li>پشتیبانی از پروتکل TCP/IP</li>
<li>پشتیبانی از درایورهای شبکه</li>
<li>پشتیبانی از X Window System</li>
<li>کرنل حفاظت‌شده حافظه با چندوظیفه‌ای پیشگیرانه</li>
<li>سازگاری با استانداردهای POSIX</li>
</ul>
<p>نسخه 1.0 به طور رسمی مجوز GNU GPL را پذیرفت که تضمین می‌کرد کرنل لینوکس همیشه آزاد باقی بماند. این تصمیم کلیدی به محبوبیت آن کمک کرد و باعث شد تا شرکت‌ها و توسعه‌دهندگان بیشتری به توسعه آن مشارکت کنند.</p>
<p>پس از نسخه 1.0، لینوکس به سرعت تکامل یافت:</p>
<ul>
<li><strong>لینوکس 1.2</strong> (مارس 1995): پشتیبانی از پردازنده‌های Alpha و SPARC</li>
<li><strong>لینوکس 1.3</strong> (ژوئن 1995): معرفی سیستم فایل ext2</li>
</ul>
<h3 id="-2-0-">لینوکس 2.0 و پشتیبانی از چندپردازنده</h3>
<p>نسخه 2.0 کرنل لینوکس در 9 ژوئن 1996 منتشر شد. این نسخه ویژگی‌های بسیار مهمی را به همراه آورد، از جمله:</p>
<ul>
<li><strong>پشتیبانی از SMP (Symmetric Multi-Processing)</strong>: امکان استفاده از چندین پردازنده به طور همزمان</li>
<li><strong>پشتیبانی از ماژول‌های کرنل بارگذاری شده در زمان اجرا</strong></li>
<li><strong>معرفی Memory Type Range Registers (MTRR)</strong></li>
<li><strong>پشتیبانی از معماری‌های مختلف</strong>: PowerPC, SPARC, Alpha</li>
<li><strong>پشتیبانی از IPv6</strong></li>
<li><strong>پشتیبانی از SCSI با عملکرد بالا</strong></li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه کد مشخص‌کننده قابلیت SMP در لینوکس 2.0
 * kernel/smp.c
 */</span>
<span class="hljs-selector-tag">void</span> <span class="hljs-selector-tag">smp_boot_cpus</span>(void)
{
    <span class="hljs-selector-tag">int</span> <span class="hljs-selector-tag">i</span>;

    <span class="hljs-comment">/* بازیابی اطلاعات SMP از BIOS */</span>
    <span class="hljs-selector-tag">smp_scan_config</span>();

    <span class="hljs-comment">/* راه‌اندازی پردازنده اصلی */</span>
    <span class="hljs-selector-tag">smp_boot_one_cpu</span>(<span class="hljs-number">0</span>, cpu_present_map);

    <span class="hljs-comment">/* راه‌اندازی سایر پردازنده‌ها */</span>
    <span class="hljs-selector-tag">for</span> (i = <span class="hljs-number">1</span>; i &lt; NR_CPUS; i++) {
        <span class="hljs-selector-tag">if</span> (cpu_isset(i, cpu_present_map))
            <span class="hljs-selector-tag">smp_boot_one_cpu</span>(i, cpu_present_map);
    }

    <span class="hljs-comment">/* همگام‌سازی بین تمام پردازنده‌ها */</span>
    <span class="hljs-selector-tag">smp_commence</span>();
}
</code></pre>
<p>پس از نسخه 2.0، چندین نسخه مهم دیگر منتشر شدند:</p>
<ul>
<li><strong>لینوکس 2.2</strong> (ژانویه 1999): بهبود عملکرد و مقیاس‌پذیری SMP، پشتیبانی از RAID نرم‌افزاری</li>
<li><strong>لینوکس 2.4</strong> (ژانویه 2001): پشتیبانی از USB، دستگاه‌های ISA Plug and Play، ACPI، حافظه فیزیکی بیشتر از 4GB و پشتیبانی از فایل‌های بزرگتر از 2GB</li>
</ul>
<h3 id="-2-6-">لینوکس 2.6 و تحولات بزرگ</h3>
<p>نسخه 2.6 کرنل لینوکس در 18 دسامبر 2003 منتشر شد. این نسخه یکی از مهم‌ترین نسخه‌ها در تاریخ لینوکس بود و تغییرات اساسی متعددی را به همراه داشت:</p>
<ul>
<li><strong>زمانبند O(1)</strong>: الگوریتم زمانبندی جدید با پیچیدگی زمانی ثابت، بدون توجه به تعداد فرآیندها</li>
<li><strong>پیشگیری قابل پیکربندی و پذیری استثنایی کرنل</strong>: قابلیت پیشگیری بخش‌های بیشتری از کرنل</li>
<li><strong>NPTL (Native POSIX Thread Library)</strong>: پشتیبانی بهتر از نخ‌ها</li>
<li><strong>Futex (Fast Userspace Mutex)</strong>: مکانیزم همگام‌سازی سریع‌تر</li>
<li><strong>پشتیبانی از NUMA (Non-Uniform Memory Access)</strong></li>
<li><strong>hotplug CPU و حافظه</strong>: امکان اضافه و حذف پردازنده و حافظه در زمان اجرا</li>
<li><strong>CFS (Completely Fair Scheduler)</strong>: معرفی شده در 2.6.23، کاملاً زمانبند تغییر کرد</li>
<li><strong>4KiB-1TiB حافظه فیزیکی روی x86-64</strong></li>
<li><strong>درایورهای دستگاه بهتر و پشتیبانی از سخت‌افزارهای جدید</strong></li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه کد زمانبند O(1) در لینوکس 2.6
 * kernel/sched.c
 */</span>
<span class="hljs-keyword">static</span> void scheduler_tick(void)
{
    <span class="hljs-keyword">int</span> cpu = smp_processor_id();
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">rq</span></span> *rq = cpu_rq(cpu);
    <span class="hljs-class"><span class="hljs-keyword">struct</span> <span class="hljs-title">task_struct</span></span> *curr = rq-&gt;curr;

    <span class="hljs-comment">/* به‌روزرسانی آمار */</span>
    update_rq_clock(rq);
    update_cpu_load(rq);

    <span class="hljs-comment">/* کاهش کوانتوم زمانی فرآیند جاری */</span>
    <span class="hljs-keyword">if</span> (curr-&gt;policy == SCHED_OTHER) {
        curr-&gt;time_slice--;
        <span class="hljs-keyword">if</span> (!curr-&gt;time_slice)
            task_running_tick(rq, curr);
    } <span class="hljs-keyword">else</span> {
        <span class="hljs-comment">/* فرآیندهای بلادرنگ به روش متفاوتی مدیریت می‌شوند */</span>
        update_rt_task(rq, curr);
    }

    <span class="hljs-comment">/* بررسی فرآیندهای با اولویت بالاتر */</span>
    check_preempt_tick(rq, curr);
}
</code></pre>
<p>نسخه 2.6 برای مدت طولانی‌تری (از 2003 تا 2011) ادامه یافت و شامل ده‌ها نسخه فرعی بود که هر کدام ویژگی‌های مهمی را معرفی کردند:</p>
<ul>
<li><strong>Linux 2.6.11</strong> (2005): پشتیبانی از مجازی‌سازی Xen</li>
<li><strong>Linux 2.6.18</strong> (2006): معرفی CGroups (Control Groups)</li>
<li><strong>Linux 2.6.24</strong> (2008): معرفی فضاهای نام (Namespaces) و KVM</li>
<li><strong>Linux 2.6.25</strong> (2008): پشتیبانی از مکانیسم امنیتی SELinux</li>
<li><strong>Linux 2.6.29</strong> (2009): سیستم فایل Btrfs</li>
<li><strong>Linux 2.6.32</strong> (2009): پایه بسیاری از توزیع‌های LTS، معرفی قابلیت Cgroups v1</li>
<li><strong>Linux 2.6.39</strong> (2011): آخرین نسخه قبل از تغییر شماره‌گذاری</li>
</ul>
<h3 id="-">تغییر به سیستم شماره‌گذاری جدید</h3>
<p>در سال 2011، لینوس توروالدز تصمیم گرفت سیستم شماره‌گذاری نسخه‌های کرنل را تغییر دهد تا از پیچیدگی شماره نسخه‌های فرعی جلوگیری کند. در سیستم جدید:</p>
<ul>
<li>اولین عدد (مثل 3 در 3.0) شماره نسخه اصلی است و تنها برای تغییرات انقلابی بزرگ تغییر می‌کند</li>
<li>دومین عدد (مثل 0 در 3.0) شماره نسخه فرعی است و هر چند ماه با انتشار نسخه جدید افزایش می‌یابد</li>
<li>سومین عدد (مثل 1 در 3.0.1) برای نسخه‌های پایدار استفاده می‌شود و نشان‌دهنده اصلاحات باگ است</li>
</ul>
<p>نسخه 3.0 در 22 ژوئیه 2011 منتشر شد و عملاً ادامه نسخه 2.6.39 بود، اما با شماره نسخه جدید.</p>
<h3 id="-">نسخه‌های جدید و ویژگی‌های کلیدی</h3>
<p>پس از تغییر سیستم شماره‌گذاری، کرنل لینوکس به توسعه خود ادامه داد و نسخه‌های مهم زیر منتشر شدند:</p>
<p><strong>لینوکس 3.x (2011-2015):</strong></p>
<ul>
<li><strong>Linux 3.0</strong> (2011): بهبود پشتیبانی از Android، Xen و مجازی‌سازی</li>
<li><strong>Linux 3.2</strong> (2012): بهبود سیستم فایل Btrfs، پشتیبانی از Ext4 metadata checksums</li>
<li><strong>Linux 3.8</strong> (2013): پشتیبانی از ARM 64-bit</li>
<li><strong>Linux 3.10</strong> (2013): بهبود مدیریت حافظه، یکی از نسخه‌های LTS پراستفاده</li>
<li><strong>Linux 3.14</strong> (2014): معرفی زمانبند انرژی-دوست</li>
</ul>
<p><strong>لینوکس 4.x (2015-2019):</strong></p>
<ul>
<li><strong>Linux 4.0</strong> (2015): قابلیت patching بدون reboot (live patching)</li>
<li><strong>Linux 4.4</strong> (2016): پشتیبانی از 3D GPU، نسخه LTS محبوب</li>
<li><strong>Linux 4.9</strong> (2016): یکی دیگر از نسخه‌های LTS پراستفاده، معرفی BPF JIT</li>
<li><strong>Linux 4.14</strong> (2017): پشتیبانی از AMD Secure Memory Encryption</li>
<li><strong>Linux 4.19</strong> (2018): معرفی الگوریتم زمانبندی CAKE و بهبود عملکرد TCP</li>
</ul>
<p><strong>لینوکس 5.x (2019-2023):</strong></p>
<ul>
<li><strong>Linux 5.0</strong> (2019): پشتیبانی از AMD FreeSync، بهبود عملکرد Spectre و Meltdown</li>
<li><strong>Linux 5.4</strong> (2019): معرفی فایل سیستم exFAT، بهبود امنیت</li>
<li><strong>Linux 5.10</strong> (2020): پشتیبانی از RISC-V، نسخه LTS</li>
<li><strong>Linux 5.15</strong> (2021): پشتیبانی از سیستم فایل NTFS3، بهبود عملکرد io_uring</li>
<li><strong>Linux 5.19</strong> (2022): بهبود عملکرد برای ARM و RISC-V</li>
</ul>
<p><strong>لینوکس 6.x (2023-اکنون):</strong></p>
<ul>
<li><strong>Linux 6.0</strong> (2022): معرفی شده بیشتر به دلیل تغییر شماره نسخه، بهبود پشتیبانی از RISC-V</li>
<li><strong>Linux 6.1</strong> (2022): بهبود‌های امنیتی و پشتیبانی از نسل جدید سخت‌افزارها، نسخه LTS</li>
<li><strong>Linux 6.5</strong> (2023): بهبود مدیریت حافظه و پشتیبانی از معماری‌های نوین</li>
</ul>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * نمونه‌ای از کد io_uring در نسخه‌های جدید کرنل
 * io_uring، یکی از پیشرفت‌های اخیر برای عملیات I/O ناهمگام
 */</span>
<span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">io_uring_setup</span>(<span class="hljs-params">u32 entries, <span class="hljs-keyword">struct</span> io_uring_params *<span class="hljs-keyword">params</span></span>)
</span>{
    <span class="hljs-keyword">struct</span> io_uring_sq *sq;
    <span class="hljs-keyword">struct</span> io_uring_cq *cq;
    <span class="hljs-keyword">int</span> ret;

    <span class="hljs-comment">/* بررسی پارامترها */</span>
    <span class="hljs-keyword">if</span> (entries == <span class="hljs-number">0</span> || entries &gt; IO_URING_MAX_ENTRIES)
        <span class="hljs-keyword">return</span> -EINVAL;

    <span class="hljs-comment">/* تخصیص حافظه برای ساختارهای داده */</span>
    sq = kzalloc(<span class="hljs-keyword">sizeof</span>(*sq), GFP_KERNEL);
    <span class="hljs-keyword">if</span> (!sq)
        <span class="hljs-keyword">return</span> -ENOMEM;

    cq = kzalloc(<span class="hljs-keyword">sizeof</span>(*cq), GFP_KERNEL);
    <span class="hljs-keyword">if</span> (!cq) {
        kfree(sq);
        <span class="hljs-keyword">return</span> -ENOMEM;
    }

    <span class="hljs-comment">/* مقداردهی اولیه ساختارهای صف ارسال و دریافت */</span>
    ret = io_sq_init(sq, entries, <span class="hljs-keyword">params</span>);
    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">goto</span> err;

    ret = io_cq_init(cq, entries, <span class="hljs-keyword">params</span>);
    <span class="hljs-keyword">if</span> (ret &lt; <span class="hljs-number">0</span>)
        <span class="hljs-keyword">goto</span> err;

    <span class="hljs-comment">/* ثبت و برگرداندن فایل دسکریپتور */</span>
    ret = io_uring_register_fd(sq, cq);

    <span class="hljs-keyword">return</span> ret;

err:
    kfree(sq);
    kfree(cq);
    <span class="hljs-keyword">return</span> ret;
}
</code></pre>
<h3 id="-api-abi">تکامل API و ABI</h3>
<p>یکی از ویژگی‌های برجسته کرنل لینوکس، تعهد آن به حفظ سازگاری با برنامه‌های کاربردی موجود است. این اصل که با عنوان &quot;<strong>Don&#39;t break userspace</strong>&quot; شناخته می‌شود، تضمین می‌کند که برنامه‌های قدیمی همچنان روی نسخه‌های جدیدتر کرنل کار می‌کنند.</p>
<p><strong>تکامل API کرنل:</strong></p>
<p>API کرنل (واسط برنامه‌نویسی کرنل) شامل توابع، ساختارهای داده و ثابت‌هایی است که ماژول‌های کرنل می‌توانند از آنها استفاده کنند. برخلاف ABI، API کرنل به ثبات کامل متعهد نیست:</p>
<ul>
<li><strong>تغییرات تدریجی</strong>: API قدیمی‌تر ممکن است به تدریج منسوخ شده و با APIهای جدیدتر جایگزین شوند</li>
<li><strong>دوره انتقال</strong>: معمولاً یک دوره انتقال برای توسعه‌دهندگان فراهم می‌شود تا کد خود را با API جدید سازگار کنند</li>
<li><strong>علامت‌گذاری توابع منسوخ</strong>: توابع منسوخ شده با ماکروهایی مانند <code>EXPORT_SYMBOL_GPL_FUTURE</code> و <code>__deprecated</code> علامت‌گذاری می‌شوند</li>
</ul>
<p><strong>تکامل ABI کرنل:</strong></p>
<p>ABI کرنل (واسط باینری برنامه‌های کاربردی) شامل فراخوانی‌های سیستمی، فرمت‌های فایل، و واسط‌های دستگاه است که برنامه‌های کاربردی برای تعامل با کرنل استفاده می‌کنند. لینوکس متعهد به حفظ سازگاری ABI است:</p>
<ul>
<li><strong>پایداری فراخوانی‌های سیستمی</strong>: فراخوانی‌های سیستمی موجود هرگز تغییر نمی‌کنند و همیشه رفتار یکسانی دارند</li>
<li><strong>اضافه کردن فراخوانی‌های جدید</strong>: به جای تغییر فراخوانی‌های موجود، فراخوانی‌های سیستمی جدید اضافه می‌شوند</li>
<li><strong>سازگاری رو به عقب</strong>: همواره سازگاری با نسخه‌های قبلی حفظ می‌شود</li>
<li><strong>تست گسترده</strong>: تغییرات ABI به دقت بررسی و تست می‌شوند تا از حفظ سازگاری اطمینان حاصل شود</li>
</ul>
<p>این تعهد به سازگاری یکی از دلایل اصلی موفقیت و محبوبیت لینوکس است، زیرا به کاربران و توسعه‌دهندگان اطمینان می‌دهد که نرم‌افزارهای آنها با ارتقاء نسخه کرنل دچار مشکل نخواهند شد.</p>
<pre><code class="lang-c"><span class="hljs-comment">/**
 * مثالی از حفظ سازگاری ABI در فراخوانی‌های سیستمی
 * کرنل لینوکس با افزودن نسخه‌های جدیدتر فراخوانی‌ها 
 * به جای تغییر فراخوانی‌های موجود، سازگاری را حفظ می‌کند
 */</span>

<span class="hljs-comment">/* فراخوانی سیستمی اصلی open */</span>
SYSCALL_DEFINE3(open, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, filename, <span class="hljs-keyword">int</span>, flags, <span class="hljs-keyword">umode_t</span>, mode)
{
    <span class="hljs-comment">/* پیاده‌سازی اصلی... */</span>
    <span class="hljs-keyword">return</span> do_sys_open(AT_FDCWD, filename, flags, mode);
}

<span class="hljs-comment">/* 
 * فراخوانی سیستمی جدیدتر openat
 * به جای تغییر فراخوانی open، فراخوانی جدیدی اضافه شده
 * که قابلیت‌های بیشتری دارد
 */</span>
SYSCALL_DEFINE4(openat, <span class="hljs-keyword">int</span>, dfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, filename, <span class="hljs-keyword">int</span>, flags,
                <span class="hljs-keyword">umode_t</span>, mode)
{
    <span class="hljs-comment">/* پیاده‌سازی با قابلیت‌های جدید... */</span>
    <span class="hljs-keyword">return</span> do_sys_open(dfd, filename, flags, mode);
}

<span class="hljs-comment">/* 
 * و حتی یک نسخه جدیدتر: openat2
 * که ویژگی‌های امنیتی بیشتری دارد
 */</span>
SYSCALL_DEFINE4(openat2, <span class="hljs-keyword">int</span>, dfd, <span class="hljs-keyword">const</span> <span class="hljs-keyword">char</span> __user *, filename,
                <span class="hljs-keyword">struct</span> open_how __user *, how, <span class="hljs-keyword">size_t</span>, size)
{
    <span class="hljs-comment">/* پیاده‌سازی با امکانات پیشرفته‌تر... */</span>
    <span class="hljs-keyword">return</span> do_sys_openat2(dfd, filename, how, size);
}
</code></pre>
<p>کرنل لینوکس با حفظ تعادل بین نوآوری و پایداری، یک پلتفرم استثنایی برای توسعه‌دهندگان و کاربران فراهم کرده است. تکامل تدریجی آن از یک پروژه شخصی کوچک به یک سیستم‌عامل پیشرفته، نشان‌دهنده قدرت مدل توسعه متن‌باز و همکاری جهانی است.</p>
<h2 id="-">تاثیر کرنل لینوکس بر دنیای کامپیوتر</h2>
<p>کرنل لینوکس در طی چند دهه گذشته تأثیر عمیقی بر دنیای فناوری اطلاعات و صنعت کامپیوتر داشته است. با گسترش روزافزون این سیستم‌عامل از سیستم‌های کوچک نهفته تا ابررایانه‌ها، لینوکس به یک بازیگر کلیدی در اکوسیستم جهانی کامپیوتر تبدیل شده است.</p>
<h3 id="-">توزیع‌های لینوکس</h3>
<p>توزیع‌های لینوکس، سیستم‌های عامل کاملی هستند که بر اساس کرنل لینوکس ساخته می‌شوند و با افزودن ابزارها، کتابخانه‌ها و نرم‌افزارهای کاربردی، تجربه کاربری منسجمی را ارائه می‌دهند:</p>
<ul>
<li><strong>Debian</strong>: یکی از قدیمی‌ترین توزیع‌های لینوکس با تمرکز بر پایداری و امنیت</li>
<li><strong>Ubuntu</strong>: توزیع محبوب مبتنی بر Debian با کاربرپسندی بالا</li>
<li><strong>Fedora/RHEL</strong>: مدیریت توسط Red Hat با تمرکز بر نوآوری و محیط سازمانی</li>
<li><strong>SUSE/openSUSE</strong>: توزیع قدرتمند با ابزارهای مدیریتی پیشرفته</li>
<li><strong>Arch Linux</strong>: با فلسفه سادگی و سفارشی‌سازی پیشرفته</li>
</ul>
<p>این تنوع به کاربران امکان می‌دهد سیستمی را انتخاب کنند که دقیقاً با نیازهای آنها مطابقت داشته باشد، از سیستم‌های سبک برای سخت‌افزارهای قدیمی تا پلتفرم‌های پیشرفته برای محیط‌های سازمانی.</p>
<h3 id="-">اندروید و سیستم‌عامل‌های مبتنی بر لینوکس</h3>
<p>اندروید به عنوان پرکاربردترین سیستم‌عامل موبایل در جهان، بر پایه کرنل لینوکس ساخته شده است:</p>
<ul>
<li>بیش از 2.5 میلیارد دستگاه اندرویدی فعال در سراسر جهان</li>
<li>کرنل لینوکس با تغییرات خاصی برای دستگاه‌های موبایل بهینه‌سازی شده است</li>
<li>ویژگی‌هایی مانند Binder IPC و wakelocks به کرنل اندروید اضافه شده‌اند</li>
</ul>
<p>سایر سیستم‌عامل‌های مهم مبتنی بر لینوکس عبارتند از:</p>
<ul>
<li><strong>Chrome OS</strong>: سیستم‌عامل Google برای لپ‌تاپ‌ها</li>
<li><strong>Tizen</strong>: توسعه‌یافته توسط سامسونگ برای تلویزیون‌های هوشمند و ساعت‌ها</li>
<li><strong>سیستم‌عامل‌های خودرو</strong>: مانند Automotive Grade Linux (AGL)</li>
</ul>
<h3 id="-">لینوکس در سرورها و مراکز داده</h3>
<p>لینوکس به پلتفرم غالب در زیرساخت‌های اینترنت و مراکز داده تبدیل شده است:</p>
<ul>
<li>بیش از 90% از سرورهای وب جهان از لینوکس استفاده می‌کنند</li>
<li>تقریباً تمام زیرساخت‌های ابری بزرگ (AWS، Google Cloud، Azure) بر پایه لینوکس هستند</li>
<li>مزایای اصلی:<ul>
<li>پایداری و زمان فعالیت (uptime) بالا</li>
<li>امنیت قوی و به‌روزرسانی‌های سریع</li>
<li>انعطاف‌پذیری و قابلیت سفارشی‌سازی</li>
<li>مقیاس‌پذیری از سرورهای کوچک تا خوشه‌های بزرگ</li>
</ul>
</li>
</ul>
<p>فناوری‌های کلیدی مانند کانتینرها (Docker، Kubernetes) و سیستم‌های مجازی‌سازی (KVM) که زیربنای زیرساخت‌های مدرن هستند، همگی بر پایه ویژگی‌های کرنل لینوکس توسعه یافته‌اند.</p>
<h3 id="-">اینترنت اشیا و سیستم‌های نهفته</h3>
<p>انعطاف‌پذیری و مقیاس‌پذیری کرنل لینوکس، آن را به گزینه‌ای عالی برای دستگاه‌های اینترنت اشیا (IoT) و سیستم‌های نهفته تبدیل کرده است:</p>
<ul>
<li><strong>هوشمندسازی خانه</strong>: ترموستات‌ها، دوربین‌های امنیتی، اسپیکرهای هوشمند</li>
<li><strong>کاربردهای صنعتی</strong>: سیستم‌های کنترل و اتوماسیون کارخانه‌ها</li>
<li><strong>خودروها</strong>: سیستم‌های سرگرمی و ناوبری، خودروهای خودران</li>
<li><strong>تجهیزات پزشکی</strong>: سیستم‌های مانیتورینگ و تشخیصی</li>
</ul>
<p>مزایای اصلی لینوکس در این زمینه:</p>
<ul>
<li>امکان سفارشی‌سازی برای محیط‌های با منابع محدود</li>
<li>ویژگی‌های پیشرفته مدیریت انرژی</li>
<li>پشتیبانی از به‌روزرسانی از راه دور (OTA)</li>
<li>پایداری و امنیت بالا</li>
</ul>
<h3 id="-">ابررایانه‌ها</h3>
<p>لینوکس تسلط کاملی بر دنیای ابررایانه‌ها دارد:</p>
<ul>
<li>100% از 500 ابررایانه برتر جهان (فهرست TOP500) از لینوکس استفاده می‌کنند</li>
<li>قابلیت‌های مقیاس‌پذیری لینوکس امکان مدیریت هزاران هسته پردازنده را فراهم می‌کند</li>
<li>ویژگی‌های مهم کرنل برای ابررایانه‌ها:<ul>
<li>پشتیبانی از NUMA (Non-Uniform Memory Access)</li>
<li>زمانبندی پیشرفته برای سیستم‌های چندپردازنده‌ای</li>
<li>پشتیبانی از Huge Pages برای بهبود کارایی حافظه</li>
<li>مدیریت منابع پیشرفته با cgroups</li>
</ul>
</li>
</ul>
<h3 id="-">تأثیر بر صنعت و جامعه</h3>
<p>تأثیر لینوکس فراتر از جنبه‌های فنی صرف بوده و بر مدل‌های کسب‌وکار و جامعه نیز تأثیر گذاشته است:</p>
<ul>
<li><p><strong>تحول در مدل‌های کسب‌وکار</strong>:</p>
<ul>
<li>ظهور شرکت‌های موفق متن‌باز مانند Red Hat</li>
<li>کاهش هزینه‌های توسعه نرم‌افزار با اشتراک‌گذاری منابع</li>
<li>همکاری میان رقبا در پروژه‌های مشترک</li>
</ul>
</li>
<li><p><strong>تأثیر اجتماعی</strong>:</p>
<ul>
<li>دسترسی جهانی به فناوری‌های پیشرفته</li>
<li>کاهش شکاف دیجیتالی</li>
<li>ایجاد فرصت‌های آموزشی برابر</li>
<li>استقلال فناوری برای کشورها</li>
</ul>
</li>
<li><p><strong>تأثیر بر توسعه نرم‌افزار</strong>:</p>
<ul>
<li>ترویج روش‌های توسعه مشارکتی و توزیع‌شده</li>
<li>بهبود استانداردهای کیفیت و فرآیندهای بررسی کد</li>
<li>الهام‌بخش جنبش DevOps و CI/CD</li>
</ul>
</li>
</ul>
<h3 id="-">نوآوری‌های الهام گرفته از لینوکس</h3>
<p>مدل توسعه و فناوری‌های لینوکس الهام‌بخش نوآوری‌های متعددی در دنیای فناوری بوده‌اند:</p>
<ul>
<li><strong>Git</strong>: سیستم کنترل نسخه توزیع‌شده که توسط لینوس توروالدز برای مدیریت کد کرنل ایجاد شد</li>
<li><strong>کانتینریزیشن</strong>: فناوری‌های Docker و Kubernetes که بر پایه ویژگی‌های کرنل لینوکس (cgroups و namespaces) ساخته شده‌اند</li>
<li><strong>eBPF</strong>: انقلابی در مانیتورینگ و امنیت شبکه</li>
<li><strong>مجازی‌سازی</strong>: فناوری‌های KVM و Xen که زیربنای زیرساخت‌های ابری هستند</li>
</ul>
<p>مفاهیم کلیدی توسعه لینوکس مانند &quot;release early, release often&quot; و &quot;given enough eyeballs, all bugs are shallow&quot; (قانون لینوس) بر متدولوژی‌های توسعه نرم‌افزار مدرن از جمله Agile و DevOps تأثیر عمیقی داشته‌اند.</p>
<p>پروژه‌های بزرگ متن‌باز دیگر مانند Apache، Mozilla و Creative Commons از مدل توسعه و مفاهیم لینوکس الهام گرفته‌اند، و این تأثیر فراتر از نرم‌افزار به حوزه‌های دیگر مانند تولید محتوا، آموزش و طراحی سخت‌افزار نیز گسترش یافته است.</p>
<h2 id="-">چالش‌های پیش روی کرنل لینوکس</h2>
<p>با وجود موفقیت چشمگیر کرنل لینوکس در گستره وسیعی از کاربردها، این پروژه همچنان با چالش‌های متعددی روبرو است که باید برای حفظ مرتبط بودن و تداوم موفقیت آن در آینده به آنها پرداخته شود.</p>
<h3 id="-">پیچیدگی روزافزون کد</h3>
<p>با گذشت زمان، کد کرنل لینوکس به طور مداوم در حال رشد و پیچیده‌تر شدن است:</p>
<ul>
<li>از حدود 10,000 خط کد در نسخه 0.01 به بیش از 30 میلیون خط کد در نسخه‌های کنونی رسیده است</li>
<li>هر نسخه جدید حدود 13,000 تغییر توسط بیش از 1,600 توسعه‌دهنده دریافت می‌کند</li>
<li>چالش‌های مرتبط با پیچیدگی:<ul>
<li>دشواری درک سیستم به عنوان یک کل</li>
<li>زمان بیشتر برای وارد شدن توسعه‌دهندگان جدید</li>
<li>احتمال بالاتر برای معرفی باگ‌ها و مشکلات امنیتی</li>
<li>نیاز به ابزارهای تحلیل و تست پیشرفته‌تر</li>
</ul>
</li>
</ul>
<p>تلاش‌های جاری برای مقابله با این چالش شامل بهبود مستندسازی، استفاده از ابزارهای تحلیل استاتیک کد، و تقویت فرآیندهای بررسی کد است.</p>
<h3 id="-">حفظ سازگاری</h3>
<p>یکی از اصول بنیادی توسعه کرنل لینوکس، حفظ سازگاری با برنامه‌های موجود است. اصل &quot;Don&#39;t break userspace&quot; نشان‌دهنده این تعهد است، اما این تعهد چالش‌هایی را نیز به همراه دارد:</p>
<ul>
<li>نیاز به حفظ کد قدیمی که ممکن است بهینه نباشد</li>
<li>محدودیت در اعمال تغییرات معماری گسترده</li>
<li>پیچیدگی افزوده به دلیل لایه‌های سازگاری</li>
<li>چالش‌های مرتبط با تکامل ABI و API</li>
</ul>
<p>با این وجود، این سازگاری یکی از دلایل اصلی موفقیت لینوکس است و توسعه‌دهندگان روش‌هایی را برای معرفی قابلیت‌های جدید بدون شکستن سازگاری رو به عقب یافته‌اند.</p>
<h3 id="-">امنیت و حریم خصوصی</h3>
<p>با گسترش استفاده از لینوکس در سیستم‌های حیاتی و حساس، امنیت به چالشی بزرگتر تبدیل شده است:</p>
<ul>
<li>افزایش سطح حمله با گسترش کد و قابلیت‌ها</li>
<li>آسیب‌پذیری‌های پیچیده مانند Spectre و Meltdown</li>
<li>چالش‌های امنیتی خاص در IoT و سیستم‌های نهفته</li>
<li>نیاز به تعادل بین امنیت و کارایی</li>
<li>مسائل مربوط به حریم خصوصی در دنیای متصل</li>
</ul>
<p>برای مقابله با این چالش‌ها، پروژه‌هایی مانند Kernel Self Protection Project (KSPP) و مکانیزم‌های امنیتی پیشرفته مانند seccomp، SELinux و AppArmor توسعه یافته‌اند.</p>
<h3 id="-">سخت‌افزارهای اختصاصی</h3>
<p>یکی از چالش‌های مداوم برای کرنل لینوکس، پشتیبانی از سخت‌افزارهای اختصاصی است که سازندگان آنها تمایلی به ارائه مستندات یا درایورهای متن‌باز ندارند:</p>
<ul>
<li>کارت‌های گرافیک با معماری‌های اختصاصی</li>
<li>مودم‌ها و چیپ‌ست‌های شبکه‌ای</li>
<li>پردازنده‌های سیگنال دیجیتال (DSP)</li>
<li>شتاب‌دهنده‌های سخت‌افزاری خاص</li>
</ul>
<p>این محدودیت‌ها باعث می‌شود کاربران لینوکس گاهی مجبور به استفاده از درایورهای غیر متن‌باز شوند که با فلسفه نرم‌افزار آزاد در تضاد است، یا اینکه از قابلیت‌های کامل سخت‌افزار خود بهره‌مند نشوند.</p>
<h3 id="-">مسائل حقوقی و مالکیت معنوی</h3>
<p>کرنل لینوکس با چالش‌های حقوقی متعددی مواجه است که توسعه آن را پیچیده می‌کند:</p>
<ul>
<li>دعاوی نقض پتنت علیه کدهای متن‌باز</li>
<li>تنش‌های بین مجوز GPL و درایورهای اختصاصی</li>
<li>مشکلات مربوط به کدهای &quot;تمیز&quot; (clean-room implementation)</li>
<li>چالش‌های شناسایی و حذف کدهای دارای حق نسخه‌برداری غیرمجاز</li>
</ul>
<p>پروژه‌هایی مانند Open Invention Network (OIN) برای حفاظت از لینوکس در برابر دعاوی پتنت ایجاد شده‌اند، و Linux Foundation منابع قانونی قابل توجهی را برای مقابله با این چالش‌ها اختصاص داده است.</p>
<h3 id="-">تنوع معماری‌ها</h3>
<p>پشتیبانی از طیف گسترده‌ای از معماری‌های پردازنده یکی از قوت‌های لینوکس است، اما همچنین چالش‌هایی را نیز ایجاد می‌کند:</p>
<ul>
<li>نیاز به تست روی پلتفرم‌های مختلف</li>
<li>پیچیدگی بیشتر کد با افزایش تعداد معماری‌های پشتیبانی شده</li>
<li>چالش نگهداری کد برای معماری‌های قدیمی‌تر</li>
<li>تعادل بین بهینه‌سازی‌های خاص معماری و کد مستقل از معماری</li>
</ul>
<p>با ظهور معماری‌های جدید مانند RISC-V و شتاب‌دهنده‌های تخصصی مانند TPU و NPU، این چالش‌ها پیچیده‌تر می‌شوند.</p>
<h3 id="-">رقابت با سایر سیستم‌عامل‌ها</h3>
<p>لینوکس در بازارهای مختلف با سیستم‌عامل‌های رقیب مواجه است:</p>
<ul>
<li><strong>دسکتاپ</strong>: رقابت با Windows و macOS که سهم بازار بیشتری دارند</li>
<li><strong>موبایل</strong>: رقابت بین اندروید (مبتنی بر لینوکس) و iOS</li>
<li><strong>سیستم‌های نهفته</strong>: رقابت با سیستم‌عامل‌های RTOS مانند FreeRTOS و VxWorks</li>
<li><strong>سرور و ابر</strong>: رقابت با نسخه‌های تجاری یونیکس و Windows Server</li>
</ul>
<p>برای حفظ مزیت رقابتی، لینوکس باید به نوآوری ادامه دهد و همزمان میراث بزرگ خود از کد و سازگاری با برنامه‌های موجود را مدیریت کند.</p>
<p>نکته مثبت اینجاست که کرنل لینوکس در طول تاریخ خود نشان داده که قادر به تطبیق با چالش‌های جدید و تکامل است. با توجه به مدل توسعه باز و انعطاف‌پذیر آن، لینوکس احتمالاً می‌تواند بسیاری از این چالش‌ها را با موفقیت پشت سر بگذارد.</p>
<h2 id="-">آینده کرنل لینوکس</h2>
<p>با توجه به پیشرفت‌های سریع فناوری و تحول مداوم نیازهای محاسباتی، آینده کرنل لینوکس با چالش‌ها و فرصت‌های متعددی روبرو است. در این بخش، جهت‌گیری‌های احتمالی و روندهای آینده توسعه کرنل لینوکس را بررسی می‌کنیم.</p>
<h3 id="-">جهت‌گیری‌های آینده</h3>
<p>کرنل لینوکس برای حفظ مرتبط بودن و پاسخگویی به نیازهای متغیر، چندین مسیر توسعه را دنبال می‌کند:</p>
<ul>
<li><strong>مقیاس‌پذیری بیشتر</strong>: بهبود عملکرد از سیستم‌های کوچک IoT تا ابررایانه‌های اگزاسکیل</li>
<li><strong>امنیت پیشرفته</strong>: تقویت حفاظت‌های کرنل، هاردنینگ و مکانیزم‌های جداسازی</li>
<li><strong>پاسخگویی بهتر</strong>: کاهش تأخیر و بهبود قابلیت پیش‌بینی برای کاربردهای بلادرنگ</li>
<li><strong>مدیریت انرژی هوشمندتر</strong>: بهینه‌سازی مصرف انرژی برای طیف گسترده‌ای از دستگاه‌ها</li>
<li><strong>ساده‌سازی زیرساخت</strong>: تلاش برای مقابله با پیچیدگی فزاینده کد</li>
</ul>
<p>جامعه توسعه‌دهندگان لینوکس همچنین در حال کاوش راه‌هایی برای جذب و ادغام بهتر توسعه‌دهندگان جدید و ایجاد روندهای توسعه پایدارتر است.</p>
<h3 id="-">فناوری‌های نوظهور</h3>
<p>کرنل لینوکس باید خود را با فناوری‌های نوظهور سازگار کند که شامل:</p>
<ul>
<li><strong>معماری‌های جدید پردازنده</strong>: پشتیبانی بهتر از RISC-V و سایر معماری‌های متن‌باز</li>
<li><strong>محاسبات کوانتومی</strong>: آماده‌سازی برای تعامل با پردازنده‌های کوانتومی</li>
<li><strong>سخت‌افزارهای تخصصی هوش مصنوعی</strong>: بهینه‌سازی برای TPU، NPU و شتاب‌دهنده‌های عصبی</li>
<li><strong>ذخیره‌سازی‌های نوین</strong>: پشتیبانی از فناوری‌های غیرفرار (Persistent Memory)</li>
<li><strong>شبکه‌های نسل جدید</strong>: پشتیبانی از 5G/6G و فناوری‌های ارتباطی آینده</li>
</ul>
<p>کرنل لینوکس نیاز دارد قابلیت‌های خود را برای پشتیبانی از این فناوری‌ها گسترش دهد، در حالی که همچنان با سیستم‌های موجود سازگار باشد.</p>
<h3 id="-">لینوکس و محاسبات ابری</h3>
<p>با توجه به اهمیت روزافزون محاسبات ابری، کرنل لینوکس در حال تکامل برای بهینه‌سازی بیشتر در این محیط‌ها است:</p>
<ul>
<li><strong>مجازی‌سازی کارآمدتر</strong>: بهبود مداوم KVM و سایر فناوری‌های مجازی‌سازی</li>
<li><strong>کانتینریزیشن سبک‌تر</strong>: بهبود namespaces، cgroups و سایر ویژگی‌های جداسازی</li>
<li><strong>تعادل بار خودکار</strong>: مکانیزم‌های پیشرفته برای توزیع بهینه کار در محیط‌های توزیع‌شده</li>
<li><strong>امنیت چندمستأجری</strong>: تقویت جداسازی و حفاظت در محیط‌های چندمستأجری</li>
<li><strong>مقیاس‌پذیری خودکار</strong>: قابلیت‌های تطبیق پویا با بارهای کاری متغیر</li>
</ul>
<p>این تغییرات به لینوکس امکان می‌دهد همچنان به عنوان پایه اصلی زیرساخت‌های ابری باقی بماند.</p>
<h3 id="-">کرنل لینوکس و هوش مصنوعی</h3>
<p>با انقلاب هوش مصنوعی و یادگیری ماشین، کرنل لینوکس در حال سازگاری برای پشتیبانی بهتر از این کاربردها است:</p>
<ul>
<li><strong>پشتیبانی بهتر از شتاب‌دهنده‌ها</strong>: درایورهای بهینه‌شده برای GPU، TPU و FPGA</li>
<li><strong>دسترسی کارآمد به داده</strong>: بهینه‌سازی مسیرهای I/O برای پردازش حجم زیاد داده</li>
<li><strong>زمانبندی هوشمند</strong>: الگوریتم‌های زمانبندی بهبودیافته برای workloadهای ML/AI</li>
<li><strong>محاسبات لبه‌ای</strong>: بهینه‌سازی برای اجرای مدل‌های AI در دستگاه‌های با منابع محدود</li>
<li><strong>پردازش بلادرنگ</strong>: کاهش تأخیر برای کاربردهای AI مانند خودروهای خودران</li>
</ul>
<p>این قابلیت‌ها به لینوکس امکان می‌دهد پلتفرم ترجیحی برای توسعه و استقرار راه‌حل‌های هوش مصنوعی باقی بماند.</p>
<h3 id="-">برنامه‌های بلندمدت</h3>
<p>چندین ابتکار بلندمدت در حال شکل‌گیری است که می‌تواند آینده کرنل لینوکس را شکل دهد:</p>
<ul>
<li><strong>Project Rust for Linux</strong>: تلاش برای اضافه کردن پشتیبانی از زبان Rust برای نوشتن درایورها و اجزای کرنل</li>
<li><strong>Real-time Linux</strong>: ادغام وصله‌های بلادرنگ در جریان اصلی کرنل</li>
<li><strong>Linux Kernel Library (LKL)</strong>: امکان استفاده از کرنل لینوکس به عنوان یک کتابخانه در برنامه‌های کاربر</li>
<li><strong>بازنویسی بخش‌های قدیمی</strong>: تلاش برای نوسازی و بازسازی زیرسیستم‌های قدیمی</li>
<li><strong>کرنل هاردنینگ پیشرفته</strong>: تلاش مداوم برای افزایش امنیت کرنل</li>
</ul>
<p>این پروژه‌ها به نوسازی پایه کد کرنل و افزایش امنیت و قابلیت اطمینان آن کمک می‌کنند.</p>
<h3 id="-">چالش‌های آینده</h3>
<p>علیرغم پیشرفت‌های نوید بخش، کرنل لینوکس با چالش‌های جدی در آینده مواجه است:</p>
<ul>
<li><strong>مدیریت پیچیدگی</strong>: با رشد مداوم کد، مدیریت پیچیدگی دشوارتر می‌شود</li>
<li><strong>نیروی انسانی</strong>: نیاز به جذب توسعه‌دهندگان جدید و حفظ توسعه‌دهندگان باتجربه</li>
<li><strong>تغییرات بنیادی</strong>: دشواری اعمال تغییرات معماری گسترده به دلیل نیاز به حفظ سازگاری</li>
<li><strong>تعادل بین نوآوری و پایداری</strong>: حفظ تعادل بین معرفی ویژگی‌های جدید و حفظ پایداری</li>
<li><strong>تهدیدهای امنیتی پیشرفته</strong>: مقابله با حملات روزافزون و پیچیده‌تر</li>
</ul>
<p>توانایی جامعه لینوکس در پاسخ به این چالش‌ها، تعیین‌کننده موفقیت بلندمدت آن خواهد بود.</p>
<h3 id="-">نوآوری‌های پیش‌بینی شده</h3>
<p>برخی از نوآوری‌های پیش‌بینی شده در آینده کرنل لینوکس عبارتند از:</p>
<ul>
<li><strong>زمانبندی هوشمند مبتنی بر یادگیری ماشین</strong>: استفاده از الگوریتم‌های ML برای بهینه‌سازی تخصیص منابع</li>
<li><strong>امنیت خودترمیم</strong>: مکانیزم‌های تشخیص و ترمیم خودکار آسیب‌پذیری‌ها</li>
<li><strong>مجازی‌سازی تطبیقی</strong>: مجازی‌سازی هوشمند با استفاده تلفیقی از کانتینرها و ماشین‌های مجازی</li>
<li><strong>اجزای قابل تعویض کرنل</strong>: معماری ماژولارتر که امکان تعویض اجزا در زمان اجرا را فراهم می‌کند</li>
<li><strong>معرفی زبان‌های برنامه‌نویسی مدرن</strong>: استفاده تدریجی از زبان‌های امن‌تر مانند Rust در کنار C</li>
</ul>
<p>این نوآوری‌ها می‌توانند لینوکس را امن‌تر، کارآمدتر و انعطاف‌پذیرتر کنند، در حالی که همچنان سازگاری با سیستم‌های موجود حفظ می‌شود.</p>
<p>با توجه به تاریخچه موفق لینوکس در سازگاری با تغییرات فناوری و رفع چالش‌ها، می‌توان انتظار داشت که کرنل لینوکس به تکامل و گسترش در فضاهای محاسباتی جدید ادامه دهد و نقش محوری خود در اکوسیستم فناوری اطلاعات را حفظ کند.</p>
<h2 id="-">نتیجه‌گیری</h2>
<p>کرنل لینوکس یکی از موفق‌ترین و تأثیرگذارترین پروژه‌های نرم‌افزاری در تاریخ محاسبات است. در این تحقیق، جنبه‌های مختلف کرنل لینوکس از تاریخچه پیدایش تا معماری، ویژگی‌ها، فرآیند توسعه و تأثیر آن بر دنیای کامپیوتر را بررسی کردیم. اکنون می‌توانیم یافته‌های کلیدی را جمع‌بندی کنیم.</p>
<p>کرنل لینوکس از یک پروژه شخصی کوچک که توسط لینوس توروالدز در سال 1991 آغاز شد، به یک سیستم‌عامل جهانی تبدیل شده است که بر روی میلیاردها دستگاه از گوشی‌های هوشمند تا ابررایانه‌ها اجرا می‌شود. این مسیر تکاملی چشمگیر، نشان‌دهنده قدرت مدل توسعه متن‌باز و همکاری جهانی است.</p>
<p>معماری مونولیتیک ماژولار کرنل لینوکس، انعطاف‌پذیری قابل توجهی را با حفظ کارایی بالا فراهم کرده است. ویژگی‌های کلیدی آن مانند چند وظیفه‌ای پیشگیرانه، پشتیبانی از چندپردازنده، قابلیت حمل، سازگاری با استانداردهای POSIX، و مقیاس‌پذیری، آن را برای طیف گسترده‌ای از کاربردها مناسب ساخته‌اند.</p>
<p>زیرسیستم‌های حیاتی کرنل مانند مدیریت حافظه، زمانبندی فرآیندها، سیستم فایل و مدیریت دستگاه‌ها، در طول سال‌ها تکامل یافته‌اند تا کارایی، قابلیت اطمینان و امنیت را بهبود بخشند. سیستم ماژول‌های قابل بارگذاری کرنل امکان گسترش پویا و پشتیبانی از سخت‌افزارهای جدید را بدون نیاز به تغییر کرنل اصلی فراهم کرده است.</p>
<p>مدل توسعه متن‌باز لینوکس، با همکاری هزاران توسعه‌دهنده از سراسر جهان، الگویی برای پروژه‌های بزرگ نرم‌افزاری شده است. فرآیند منضبط بررسی کد، سیستم کنترل نسخه توزیع‌شده (Git)، و چرخه انتشار منظم، به توسعه پایدار و با کیفیت بالای کرنل کمک کرده‌اند.</p>
<p>پشتیبانی بلندمدت (LTS) از نسخه‌های خاص کرنل، ثبات و امنیت را برای محیط‌های تولیدی فراهم کرده، در حالی که نسخه‌های جدید به طور مداوم ویژگی‌ها و بهبودهای تازه را معرفی می‌کنند. تعهد به حفظ سازگاری با برنامه‌های موجود (اصل &quot;Don&#39;t break userspace&quot;) یکی از دلایل موفقیت بلندمدت لینوکس بوده است.</p>
<p>تأثیر کرنل لینوکس فراتر از جنبه‌های فنی گسترش یافته و بر مدل‌های کسب‌وکار، روش‌های توسعه نرم‌افزار و جامعه به طور کلی تأثیر گذاشته است. موفقیت لینوکس نشان داده که مدل توسعه متن‌باز می‌تواند نه تنها از نظر فنی بلکه از نظر اقتصادی و اجتماعی نیز موفق باشد.</p>
<p>علیرغم موفقیت‌های بزرگ، کرنل لینوکس با چالش‌های متعددی مواجه است، از جمله پیچیدگی روزافزون کد، مسائل امنیتی، پشتیبانی از سخت‌افزارهای اختصاصی، و رقابت با سایر سیستم‌عامل‌ها. با این حال، جامعه لینوکس تاکنون نشان داده که قادر به تطبیق با چالش‌های جدید و غلبه بر آنها است.</p>
<p>آینده کرنل لینوکس با فرصت‌های هیجان‌انگیز و چالش‌های پیچیده‌ای همراه است. با ظهور فناوری‌های جدید مانند هوش مصنوعی، محاسبات کوانتومی، اینترنت اشیا و محاسبات لبه‌ای، لینوکس به تکامل خود ادامه خواهد داد تا با این تغییرات سازگار شود و همچنان نقش محوری در اکوسیستم فناوری اطلاعات داشته باشد.</p>
<p>در مجموع، کرنل لینوکس نه تنها یک دستاورد فنی برجسته است، بلکه نمونه‌ای درخشان از قدرت همکاری جهانی، کدگذاری متن‌باز و نوآوری مشترک است. با نگاهی به مسیر طی شده از سال 1991 تاکنون، می‌توان با اطمینان گفت که کرنل لینوکس به پیشرفت و تأثیرگذاری خود بر دنیای فناوری اطلاعات و فراتر از آن ادامه خواهد داد.</p>
<h2 id="-">منابع</h2>
<p>این پژوهش با استفاده از منابع متنوع و معتبر در زمینه کرنل لینوکس، سیستم‌عامل‌ها و برنامه‌نویسی سیستم تهیه شده است. منابع اصلی مورد استفاده به شرح زیر است:</p>
<ol>
<li><p>Torvalds, L., &amp; Diamond, D. (2001). Just for Fun: The Story of an Accidental Revolutionary. Harper Business.</p>
</li>
<li><p>Love, R. (2010). Linux Kernel Development (3rd Edition). Addison-Wesley Professional.</p>
</li>
<li><p>Bovet, D. P., &amp; Cesati, M. (2005). Understanding the Linux Kernel (3rd Edition). O&#39;Reilly Media.</p>
</li>
<li><p>Corbet, J., Rubini, A., &amp; Kroah-Hartman, G. (2005). Linux Device Drivers (3rd Edition). O&#39;Reilly Media.</p>
</li>
<li><p>Kerrisk, M. (2010). The Linux Programming Interface: A Linux and UNIX System Programming Handbook. No Starch Press.</p>
</li>
<li><p>Tanenbaum, A. S., &amp; Bos, H. (2014). Modern Operating Systems (4th Edition). Pearson.</p>
</li>
<li><p>Mauerer, W. (2008). Professional Linux Kernel Architecture. Wrox.</p>
</li>
<li><p>Kroah-Hartman, G. (2007). Linux Kernel in a Nutshell. O&#39;Reilly Media.</p>
</li>
<li><p>Rusling, D. A. (1999). The Linux Kernel. Linux Documentation Project.</p>
</li>
<li><p>Linux Kernel Documentation. <a href="https://www.kernel.org/doc/">https://www.kernel.org/doc/</a></p>
</li>
<li><p>Linux Kernel Archives. <a href="https://www.kernel.org/">https://www.kernel.org/</a></p>
</li>
<li><p>Linux Kernel Mailing List Archives. <a href="https://lore.kernel.org/">https://lore.kernel.org/</a></p>
</li>
<li><p>The Linux Foundation. (2016-2023). Linux Kernel Development Reports. <a href="https://www.linuxfoundation.org/">https://www.linuxfoundation.org/</a></p>
</li>
<li><p>Linux Weekly News (LWN). <a href="https://lwn.net/">https://lwn.net/</a></p>
</li>
<li><p>The Linux Documentation Project. <a href="https://tldp.org/">https://tldp.org/</a></p>
</li>
<li><p>Torvalds, L. et al. (1991-2023). Linux Kernel Source Code. <a href="https://github.com/torvalds/linux">https://github.com/torvalds/linux</a></p>
</li>
<li><p>Kernelnewbies. <a href="https://kernelnewbies.org/">https://kernelnewbies.org/</a></p>
</li>
<li><p>Edge, J. (Ed.). (2005-2023). Articles from LWN.net on Linux Kernel Development.</p>
</li>
<li><p>Gcc, A. V. (2004). The Linux Kernel Primer: A Top-Down Approach for x86 and PowerPC Architectures. Prentice Hall.</p>
</li>
<li><p>Silberschatz, A., Galvin, P. B., &amp; Gagne, G. (2018). Operating System Concepts (10th Edition). Wiley.</p>
</li>
<li><p>Linux Cross Reference (LXR). <a href="https://elixir.bootlin.com/linux/latest/source">https://elixir.bootlin.com/linux/latest/source</a></p>
</li>
<li><p>Linux Kernel Networking: Implementation and Theory. (2014). Apress.</p>
</li>
<li><p>Linux Journal. (1994-2019). Articles on Linux Kernel Development.</p>
</li>
<li><p>Gorman, M. (2004). Understanding the Linux Virtual Memory Manager. Prentice Hall.</p>
</li>
<li><p>McKenney, P. E. (2010). Is Parallel Programming Hard, And, If So, What Can You Do About It? <a href="https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html">https://mirrors.edge.kernel.org/pub/linux/kernel/people/paulmck/perfbook/perfbook.html</a></p>
</li>
<li><p>Chen, S., &amp; Schimmel, D. (1995). UNIX Systems for Modern Architectures: Symmetric Multiprocessing and Caching for Kernel Programmers. Addison-Wesley Professional.</p>
</li>
<li><p>Rodriguez, A., Whitehouse, S., &amp; Waterman, A. (2016). The RISC-V Instruction Set Manual. RISC-V Foundation.</p>
</li>
<li><p>Kernel Security Watch. <a href="https://kernsec.org/">https://kernsec.org/</a></p>
</li>
<li><p>Open Source Security Foundation. <a href="https://openssf.org/">https://openssf.org/</a></p>
</li>
<li><p>Kernel Self-Protection Project. <a href="https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project">https://kernsec.org/wiki/index.php/Kernel_Self_Protection_Project</a></p>
</li>
</ol>
<p>این منابع طیف گسترده‌ای از اطلاعات از اسناد فنی گرفته تا تاریخچه تکامل کرنل لینوکس، روش‌های توسعه و پیش‌بینی‌های آینده را پوشش می‌دهند. برای مطالعه عمیق‌تر در مورد جنبه‌های خاص کرنل لینوکس، مراجعه به این منابع توصیه می‌شود.</p>
