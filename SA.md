# بررسی و تحلیل کرنل لینوکس
**تحقیق و نگارش: مهدی رادفر**  
**تاریخ: اردیبهشت ۱۴۰۴**

---

## فهرست مطالب
- [بررسی و تحلیل کرنل لینوکس](#بررسی-و-تحلیل-کرنل-لینوکس)
  - [فهرست مطالب](#فهرست-مطالب)
  - [مقدمه](#مقدمه)
  - [مقدمه](#مقدمه-1)
    - [اهمیت کرنل در سیستم‌عامل](#اهمیت-کرنل-در-سیستمعامل)
    - [جایگاه لینوکس در دنیای سیستم‌عامل‌ها](#جایگاه-لینوکس-در-دنیای-سیستمعاملها)
    - [هدف و ساختار این تحقیق](#هدف-و-ساختار-این-تحقیق)
    - [جایگاه لینوکس در دنیای سیستم‌عامل‌ها](#جایگاه-لینوکس-در-دنیای-سیستمعاملها-1)
  - [تاریخچه پیدایش لینوکس](#تاریخچه-پیدایش-لینوکس)
    - [زمینه‌های شکل‌گیری پروژه لینوکس](#زمینههای-شکلگیری-پروژه-لینوکس)
    - [یونیکس و تأثیر آن بر لینوکس](#یونیکس-و-تأثیر-آن-بر-لینوکس)
    - [پروژه گنو و رابطه آن با لینوکس](#پروژه-گنو-و-رابطه-آن-با-لینوکس)
    - [لینوس توروالدز و ایده اولیه کرنل لینوکس](#لینوس-توروالدز-و-ایده-اولیه-کرنل-لینوکس)
    - [اولین نسخه‌های کرنل لینوکس](#اولین-نسخههای-کرنل-لینوکس)
    - [تکامل تدریجی لینوکس](#تکامل-تدریجی-لینوکس)
  - [معماری کرنل لینوکس](#معماری-کرنل-لینوکس)
    - [کرنل مونولیتیک در مقابل میکروکرنل](#کرنل-مونولیتیک-در-مقابل-میکروکرنل)
    - [مزایا و معایب معماری مونولیتیک لینوکس](#مزایا-و-معایب-معماری-مونولیتیک-لینوکس)
    - [ساختار لایه‌ای کرنل لینوکس](#ساختار-لایهای-کرنل-لینوکس)
    - [ماژول‌های کرنل](#ماژولهای-کرنل)
    - [فضای کرنل و فضای کاربر](#فضای-کرنل-و-فضای-کاربر)
    - [سیستم فراخوانی سیستمی](#سیستم-فراخوانی-سیستمی)
    - [خلاصه معماری کرنل لینوکس](#خلاصه-معماری-کرنل-لینوکس)
  - [ویژگی‌های اصلی کرنل لینوکس](#ویژگیهای-اصلی-کرنل-لینوکس)
    - [چند وظیفه‌ای پیشگیرانه](#چند-وظیفهای-پیشگیرانه)
    - [پشتیبانی از چند پردازنده](#پشتیبانی-از-چند-پردازنده)
    - [قابلیت حمل](#قابلیت-حمل)
    - [استانداردهای POSIX](#استانداردهای-posix)
    - [پشتیبانی از سخت‌افزارهای متنوع](#پشتیبانی-از-سختافزارهای-متنوع)
    - [مقیاس‌پذیری](#مقیاسپذیری)
  - [خلاصه ویژگی‌های اصلی کرنل لینوکس](#خلاصه-ویژگیهای-اصلی-کرنل-لینوکس)
  - [بررسی کد کرنل لینوکس](#بررسی-کد-کرنل-لینوکس)
    - [زبان برنامه‌نویسی C و اسمبلی در کرنل](#زبان-برنامهنویسی-c-و-اسمبلی-در-کرنل)
    - [ساختار درختی کد منبع](#ساختار-درختی-کد-منبع)
    - [استانداردهای کدنویسی](#استانداردهای-کدنویسی)
    - [تحلیل بخش‌های کلیدی کد کرنل](#تحلیل-بخشهای-کلیدی-کد-کرنل)
      - [1. فراخوانی سیستمی (System Call)](#1-فراخوانی-سیستمی-system-call)
      - [2. زمانبندی فرآیندها](#2-زمانبندی-فرآیندها)
      - [3. مدیریت حافظه](#3-مدیریت-حافظه)
      - [4. سیستم فایل مجازی (VFS)](#4-سیستم-فایل-مجازی-vfs)
    - [بررسی نمونه کدهای کرنل](#بررسی-نمونه-کدهای-کرنل)
      - [1. مدیریت وقفه‌ها](#1-مدیریت-وقفهها)
    - [صفحه‌بندی و جدول صفحات](#صفحهبندی-و-جدول-صفحات)
    - [فضای آدرس پروسه](#فضای-آدرس-پروسه)
    - [مدیریت حافظه نهان](#مدیریت-حافظه-نهان)
    - [تخصیص و آزادسازی حافظه](#تخصیص-و-آزادسازی-حافظه)
    - [صفحه گردانی](#صفحه-گردانی)
    - [زباله‌روبی و جمع‌آوری حافظه](#زبالهروبی-و-جمعآوری-حافظه)
  - [زمانبندی فرآیندها](#زمانبندی-فرآیندها)
    - [فرآیندها و نخ‌ها در لینوکس](#فرآیندها-و-نخها-در-لینوکس)
    - [الگوریتم‌های زمانبندی](#الگوریتمهای-زمانبندی)
    - [کلاس‌های زمانبندی](#کلاسهای-زمانبندی)
    - [زمانبند کاملاً قابل پیش‌بینی](#زمانبند-کاملاً-قابل-پیشبینی)
    - [زمانبندی بلادرنگ](#زمانبندی-بلادرنگ)
    - [سیاست‌های زمانبندی](#سیاستهای-زمانبندی)
    - [توزیع بار بین پردازنده‌ها](#توزیع-بار-بین-پردازندهها)
  - [سیستم فایل در لینوکس](#سیستم-فایل-در-لینوکس)
    - [معماری VFS](#معماری-vfs)
    - [انواع سیستم فایل در لینوکس](#انواع-سیستم-فایل-در-لینوکس)
    - [ext2، ext3 و ext4](#ext2-ext3-و-ext4)
    - [Btrfs و ZFS](#btrfs-و-zfs)
    - [سیستم‌های فایل شبکه](#سیستمهای-فایل-شبکه)
    - [عملکرد ورودی/خروجی](#عملکرد-ورودیخروجی)
    - [کش و بافر سیستم فایل](#کش-و-بافر-سیستم-فایل)
  - [مدیریت دستگاه‌ها](#مدیریت-دستگاهها)
    - [درایورهای دستگاه](#درایورهای-دستگاه)
    - [سیستم‌های فایل دستگاه](#سیستمهای-فایل-دستگاه)
    - [مدل درایور لینوکس](#مدل-درایور-لینوکس)
    - [hotplug و پشتیبانی از اتصال داغ](#hotplug-و-پشتیبانی-از-اتصال-داغ)
    - [مدیریت انرژی](#مدیریت-انرژی)
    - [درایورهای گرافیکی](#درایورهای-گرافیکی)
    - [تعامل با سخت‌افزار](#تعامل-با-سختافزار)
6. [مدیریت حافظه در کرنل لینوکس](#مدیریت-حافظه-در-کرنل-لینوکس)
   - [حافظه فیزیکی و حافظه مجازی](#حافظه-فیزیکی-و-حافظه-مجازی)
   - [صفحه‌بندی و جدول صفحات](#صفحه‌بندی-و-جدول-صفحات)
   - [فضای آدرس پروسه](#فضای-آدرس-پروسه)
   - [مدیریت حافظه نهان](#مدیریت-حافظه-نهان)
   - [تخصیص و آزادسازی حافظه](#تخصیص-و-آزادسازی-حافظه)
   - [صفحه گردانی](#صفحه-گردانی)
   - [زباله‌روبی و جمع‌آوری حافظه](#زباله‌روبی-و-جمع‌آوری-حافظه)
7. [زمانبندی فرآیندها](#زمانبندی-فرآیندها)
   - [فرآیندها و نخ‌ها در لینوکس](#فرآیندها-و-نخ‌ها-در-لینوکس)
   - [الگوریتم‌های زمانبندی](#الگوریتم‌های-زمانبندی)
   - [کلاس‌های زمانبندی](#کلاس‌های-زمانبندی)
   - [زمانبند کاملاً قابل پیش‌بینی](#زمانبند-کاملاً-قابل-پیش‌بینی)
   - [زمانبندی بلادرنگ](#زمانبندی-بلادرنگ)
   - [سیاست‌های زمانبندی](#سیاست‌های-زمانبندی)
   - [توزیع بار بین پردازنده‌ها](#توزیع-بار-بین-پردازنده‌ها)
8. [سیستم فایل در لینوکس](#سیستم-فایل-در-لینوکس)
   - [معماری VFS](#معماری-VFS)
   - [انواع سیستم فایل در لینوکس](#انواع-سیستم-فایل-در-لینوکس)
   - [ext2، ext3 و ext4](#ext2-ext3-و-ext4)
   - [Btrfs و ZFS](#Btrfs-و-ZFS)
   - [سیستم‌های فایل شبکه](#سیستم‌های-فایل-شبکه)
   - [عملکرد ورودی/خروجی](#عملکرد-ورودی-خروجی)
   - [کش و بافر سیستم فایل](#کش-و-بافر-سیستم-فایل)
9. [مدیریت دستگاه‌ها](#مدیریت-دستگاه‌ها)
   - [درایورهای دستگاه](#درایورهای-دستگاه)
   - [سیستم‌های فایل دستگاه](#سیستم‌های-فایل-دستگاه)
   - [مدل درایور لینوکس](#مدل-درایور-لینوکس)
   - [hotplug و پشتیبانی از اتصال داغ](#hotplug-و-پشتیبانی-از-اتصال-داغ)
   - [مدیریت انرژی](#مدیریت-انرژی)
   - [درایورهای گرافیکی](#درایورهای-گرافیکی)
   - [تعامل با سخت‌افزار](#تعامل-با-سخت‌افزار)
10. [امنیت در کرنل لینوکس](#امنیت-در-کرنل-لینوکس)
    - [مدل امنیتی لینوکس](#مدل-امنیتی-لینوکس)
    - [SELinux و AppArmor](#SELinux-و-AppArmor)
    - [مجوزها و کنترل دسترسی](#مجوزها-و-کنترل-دسترسی)
    - [فضای‌های نام و کانتینرها](#فضای‌های-نام-و-کانتینرها)
    - [مشکلات امنیتی و وصله‌ها](#مشکلات-امنیتی-و-وصله‌ها)
    - [استراتژی‌های امنیتی](#استراتژی‌های-امنیتی)
    - [کرنل هاردنینگ](#کرنل-هاردنینگ)
11. [فرآیند توسعه کرنل لینوکس](#فرآیند-توسعه-کرنل-لینوکس)
    - [مدل توسعه متن‌باز](#مدل-توسعه-متن‌باز)
    - [گردش کار توسعه کرنل](#گردش-کار-توسعه-کرنل)
    - [سیستم کنترل نسخه Git](#سیستم-کنترل-نسخه-Git)
    - [روند بررسی و ادغام کد](#روند-بررسی-و-ادغام-کد)
    - [چرخه انتشار کرنل](#چرخه-انتشار-کرنل)
    - [پشتیبانی بلندمدت](#پشتیبانی-بلندمدت)
    - [مشارکت‌کنندگان اصلی و شرکت‌ها](#مشارکت‌کنندگان-اصلی-و-شرکت‌ها)
12. [نسخه‌های مهم کرنل لینوکس](#نسخه‌های-مهم-کرنل-لینوکس)
    - [لینوکس 0.01 و اولین نسخه‌ها](#لینوکس-0.01-و-اولین-نسخه‌ها)
    - [لینوکس 1.0 و تثبیت پروژه](#لینوکس-1.0-و-تثبیت-پروژه)
    - [لینوکس 2.0 و پشتیبانی از چندپردازنده](#لینوکس-2.0-و-پشتیبانی-از-چندپردازنده)
    - [لینوکس 2.6 و تحولات بزرگ](#لینوکس-2.6-و-تحولات-بزرگ)
    - [تغییر به سیستم شماره‌گذاری جدید](#تغییر-به-سیستم-شماره‌گذاری-جدید)
    - [نسخه‌های جدید و ویژگی‌های کلیدی](#نسخه‌های-جدید-و-ویژگی‌های-کلیدی)
    - [تکامل API و ABI](#تکامل-API-و-ABI)
13. [تاثیر کرنل لینوکس بر دنیای کامپیوتر](#تاثیر-کرنل-لینوکس-بر-دنیای-کامپیوتر)
    - [توزیع‌های لینوکس](#توزیع‌های-لینوکس)
    - [اندروید و سیستم‌عامل‌های مبتنی بر لینوکس](#اندروید-و-سیستم‌عامل‌های-مبتنی-بر-لینوکس)
    - [لینوکس در سرورها و مراکز داده](#لینوکس-در-سرورها-و-مراکز-داده)
    - [اینترنت اشیا و سیستم‌های نهفته](#اینترنت-اشیا-و-سیستم‌های-نهفته)
    - [ابررایانه‌ها](#ابررایانه‌ها)
    - [تأثیر بر صنعت و جامعه](#تأثیر-بر-صنعت-و-جامعه)
    - [نوآوری‌های الهام گرفته از لینوکس](#نوآوری‌های-الهام-گرفته-از-لینوکس)
14. [چالش‌های پیش روی کرنل لینوکس](#چالش‌های-پیش-روی-کرنل-لینوکس)
    - [پیچیدگی روزافزون کد](#پیچیدگی-روزافزون-کد)
    - [حفظ سازگاری](#حفظ-سازگاری)
    - [امنیت و حریم خصوصی](#امنیت-و-حریم-خصوصی)
    - [سخت‌افزارهای اختصاصی](#سخت‌افزارهای-اختصاصی)
    - [مسائل حقوقی و مالکیت معنوی](#مسائل-حقوقی-و-مالکیت-معنوی)
    - [تنوع معماری‌ها](#تنوع-معماری‌ها)
    - [رقابت با سایر سیستم‌عامل‌ها](#رقابت-با-سایر-سیستم‌عامل‌ها)
15. [آینده کرنل لینوکس](#آینده-کرنل-لینوکس)
    - [جهت‌گیری‌های آینده](#جهت‌گیری‌های-آینده)
    - [فناوری‌های نوظهور](#فناوری‌های-نوظهور)
    - [لینوکس و محاسبات ابری](#لینوکس-و-محاسبات-ابری)
    - [کرنل لینوکس و هوش مصنوعی](#کرنل-لینوکس-و-هوش-مصنوعی)
    - [برنامه‌های بلندمدت](#برنامه‌های-بلندمدت)
    - [چالش‌های آینده](#چالش‌های-آینده)
    - [نوآوری‌های پیش‌بینی شده](#نوآوری‌های-پیش‌بینی-شده)
16. [نتیجه‌گیری](#نتیجه‌گیری)
17. [منابع](#منابع)

---

## مقدمه

## مقدمه

### اهمیت کرنل در سیستم‌عامل

کرنل یا هسته سیستم‌عامل، قلب تپنده هر سیستم کامپیوتری است که وظیفه مدیریت منابع سخت‌افزاری و ایجاد یک لایه انتزاعی برای برنامه‌های کاربردی را بر عهده دارد. کرنل به عنوان واسط بین سخت‌افزار و نرم‌افزار، نقشی حیاتی در عملکرد کل سیستم ایفا می‌کند. بدون کرنل کارآمد، حتی قدرتمندترین سخت‌افزارها نیز نمی‌توانند به درستی مورد استفاده قرار گیرند.

کرنل مسئولیت‌های متعددی دارد که از جمله مهم‌ترین آنها می‌توان به موارد زیر اشاره کرد:

- **مدیریت حافظه**: تخصیص و آزادسازی حافظه، پیاده‌سازی حافظه مجازی، و محافظت از فضای آدرس پروسه‌ها
- **زمانبندی پردازنده**: تعیین اینکه کدام فرآیند در چه زمانی باید اجرا شود
- **مدیریت فایل‌ها**: ارائه واسط برای ذخیره‌سازی و بازیابی اطلاعات
- **مدیریت دستگاه‌ها**: ارتباط با سخت‌افزارهای متصل به سیستم از طریق درایورها
- **ارتباطات بین فرآیندی**: فراهم کردن مکانیزم‌هایی برای تبادل داده بین پروسه‌ها
- **امنیت و کنترل دسترسی**: اطمینان از دسترسی صحیح به منابع سیستم

تصمیمات طراحی در سطح کرنل تأثیر مستقیمی بر کارایی، امنیت، قابلیت اطمینان و انعطاف‌پذیری کل سیستم‌عامل دارد. به همین دلیل، مطالعه و بررسی کرنل یک سیستم‌عامل می‌تواند بینش عمیقی از عملکرد داخلی آن سیستم و فلسفه طراحی آن ارائه دهد.

### جایگاه لینوکس در دنیای سیستم‌عامل‌ها

لینوکس امروزه به یکی از مهم‌ترین و پرکاربردترین سیستم‌عامل‌های جهان تبدیل شده است. این سیستم‌عامل متن‌باز که با الهام از یونیکس توسعه یافته، در طیف گسترده‌ای از دستگاه‌ها از ابررایانه‌ها گرفته تا گوشی‌های هوشمند (از طریق اندروید) و دستگاه‌های اینترنت اشیا (IoT) مورد استفاده قرار می‌گیرد.

برخی از دلایل اهمیت و موفقیت لینوکس عبارتند از:

- **متن‌باز بودن**: کد منبع لینوکس آزادانه در دسترس عموم قرار دارد که امکان بررسی، اصلاح و بهبود آن را توسط هزاران توسعه‌دهنده در سراسر جهان فراهم می‌کند.
- **پایداری و امنیت**: لینوکس به دلیل معماری داخلی خود و مدل توسعه آن، از پایداری و امنیت بالایی برخوردار است.
- **انعطاف‌پذیری**: قابلیت سفارشی‌سازی بالای لینوکس امکان استفاده از آن را در شرایط و محیط‌های مختلف فراهم می‌کند.
- **کارایی**: بهینه‌سازی مداوم کد کرنل لینوکس باعث شده است که این سیستم‌عامل از کارایی بالایی در استفاده از منابع سخت‌افزاری برخوردار باشد.
- **پشتیبانی از سخت‌افزارهای متنوع**: لینوکس تقریباً از تمامی معماری‌های پردازنده و انواع مختلف سخت‌افزار پشتیبانی می‌کند.

امروزه، لینوکس سیستم‌عامل غالب در زمینه‌های متعددی مانند سرورها، ابررایانه‌ها، محاسبات ابری و دستگاه‌های هوشمند است. بیش از ۹۰ درصد سرورهای وب و تقریباً تمامی ابررایانه‌های جهان از لینوکس استفاده می‌کنند. همچنین، اندروید به عنوان یک سیستم‌عامل مبتنی بر کرنل لینوکس، پرطرفدارترین سیستم‌عامل موبایل در جهان محسوب می‌شود.

### هدف و ساختار این تحقیق

هدف اصلی این تحقیق، ارائه یک بررسی جامع و عمیق از کرنل لینوکس است. در این نوشتار، به جنبه‌های مختلف کرنل لینوکس از تاریخچه پیدایش گرفته تا معماری داخلی، ویژگی‌های کلیدی، فرآیند توسعه و آینده آن پرداخته می‌شود.

این تحقیق به گونه‌ای ساختاربندی شده است که هم برای افراد تازه‌کار در زمینه لینوکس قابل فهم باشد و هم برای متخصصان و توسعه‌دهندگان با تجربه، اطلاعات ارزشمندی در بر داشته باشد. در طول این مقاله، نمونه‌هایی از کد منبع کرنل لینوکس ارائه و تحلیل خواهد شد تا درک بهتری از عملکرد داخلی آن فراهم شود.

ساختار این تحقیق به شرح زیر است:

- ابتدا با **تاریخچه پیدایش لینوکس** آغاز می‌کنیم تا زمینه‌های شکل‌گیری و تکامل این پروژه مهم را بررسی کنیم.
- سپس به بررسی **معماری کرنل لینوکس** می‌پردازیم و مفاهیمی مانند کرنل مونولیتیک، ماژول‌ها و فضای کرنل و کاربر را توضیح می‌دهیم.
- در ادامه، **ویژگی‌های اصلی کرنل لینوکس** را مورد بحث قرار می‌دهیم.
- بخش مهمی از این تحقیق به **بررسی کد کرنل لینوکس** اختصاص دارد، جایی که به زبان برنامه‌نویسی، ساختار کد و استانداردهای کدنویسی می‌پردازیم.
- سپس، سیستم‌های کلیدی کرنل لینوکس مانند **مدیریت حافظه**، **زمانبندی فرآیندها**، **سیستم فایل** و **مدیریت دستگاه‌ها** را با جزئیات بررسی می‌کنیم.
- موضوع مهم **امنیت در کرنل لینوکس** نیز مورد بحث قرار می‌گیرد.
- **فرآیند توسعه کرنل لینوکس** و مدل متن‌باز آن به همراه **نسخه‌های مهم کرنل** بررسی می‌شود.
- در نهایت، **تأثیر کرنل لینوکس بر دنیای کامپیوتر**، **چالش‌های پیش رو** و **آینده کرنل لینوکس** مورد بحث قرار می‌گیرد.

این تحقیق با هدف ارائه یک منبع جامع و به‌روز در زمینه کرنل لینوکس تهیه شده است و امید است که بتواند دیدگاه عمیق‌تری نسبت به این سیستم‌عامل قدرتمند ارائه دهد.

### جایگاه لینوکس در دنیای سیستم‌عامل‌ها

لینوکس امروزه به یکی از مهم‌ترین و پرکاربردترین سیستم‌عامل‌های جهان تبدیل شده است. این سیستم‌عامل متن‌باز که با الهام از یونیکس توسعه یافته، در طیف گسترده‌ای از دستگاه‌ها از ابررایانه‌ها گرفته تا گوشی‌های هوشمند (از طریق اندروید) و دستگاه‌های اینترنت اشیا (IoT) مورد استفاده قرار می‌گیرد.

برخی از دلایل اهمیت و موفقیت لینوکس عبارتند از:

- **متن‌باز بودن**: کد منبع لینوکس آزادانه در دسترس عموم قرار دارد که امکان بررسی، اصلاح و بهبود آن را توسط هزاران توسعه‌دهنده در سراسر جهان فراهم می‌کند.
- **پایداری و امنیت**: لینوکس به دلیل معماری داخلی خود و مدل توسعه آن، از پایداری و امنیت بالایی برخوردار است.
- **انعطاف‌پذیری**: قابلیت سفارشی‌سازی بالای لینوکس امکان استفاده از آن را در شرایط و محیط‌های مختلف فراهم می‌کند.
- **کارایی**: بهینه‌سازی مداوم کد کرنل لینوکس باعث شده است که این سیستم‌عامل از کارایی بالایی در استفاده از منابع سخت‌افزاری برخوردار باشد.
- **پشتیبانی از سخت‌افزارهای متنوع**: لینوکس تقریباً از تمامی معماری‌های پردازنده و انواع مختلف سخت‌افزار پشتیبانی می‌کند.

امروزه، لینوکس سیستم‌عامل غالب در زمینه‌های متعددی مانند سرورها، ابررایانه‌ها، محاسبات ابری و دستگاه‌های هوشمند است. بیش از ۹۰ درصد سرورهای وب و تقریباً تمامی ابررایانه‌های جهان از لینوکس استفاده می‌کنند. همچنین، اندروید به عنوان یک سیستم‌عامل مبتنی بر کرنل لینوکس، پرطرفدارترین سیستم‌عامل موبایل در جهان محسوب می‌شود.

 برنامه‌نویسی، ساختار کد و استانداردهای کدنویسی می‌پردازیم.
- سپس، سیستم‌های کلیدی کرنل لینوکس مانند **مدیریت حافظه**، **زمانبندی فرآیندها**، **سیستم فایل** و **مدیریت دستگاه‌ها** را با جزئیات بررسی می‌کنیم.
- موضوع مهم **امنیت در کرنل لینوکس** نیز مورد بحث قرار می‌گیرد.
- **فرآیند توسعه کرنل لینوکس** و مدل متن‌باز آن به همراه **نسخه‌های مهم کرنل** بررسی می‌شود.
- در نهایت، **تأثیر کرنل لینوکس بر دنیای کامپیوتر**، **چالش‌های پیش رو** و **آینده کرنل لینوکس** مورد بحث قرار می‌گیرد.

این تحقیق با هدف ارائه یک منبع جامع و به‌روز در زمینه کرنل لینوکس تهیه شده است و امید است که بتواند دیدگاه عمیق‌تری نسبت به این سیستم‌عامل قدرتمند ارائه دهد.

## تاریخچه پیدایش لینوکس

### زمینه‌های شکل‌گیری پروژه لینوکس

در اواخر دهه ۱۹۸۰ و اوایل دهه ۱۹۹۰، دنیای سیستم‌عامل‌ها با چالش‌هایی مواجه بود. سیستم‌عامل‌های تجاری مانند یونیکس گران‌قیمت و محدود به سخت‌افزارهای خاص بودند، و سیستم‌عامل‌هایی مانند MS-DOS و ویندوز هنوز از قابلیت‌های پیشرفته‌ای مانند چندوظیفه‌ای کامل، حافظه مجازی و امنیت کافی برخوردار نبودند.

در این دوران، نیاز به یک سیستم‌عامل قدرتمند، ارزان و قابل دسترس که قابلیت‌های یونیکس را داشته باشد، به‌شدت احساس می‌شد. به‌ویژه در محیط‌های آکادمیک و تحقیقاتی، دسترسی به سیستم‌عاملی با کد منبع باز می‌توانست زمینه‌ای برای یادگیری، پژوهش و توسعه‌های بیشتر فراهم کند.

این زمینه باعث شد چندین پروژه با هدف ایجاد سیستم‌عامل‌های آزاد و متن‌باز شکل بگیرند. از جمله مهم‌ترین آنها، پروژه گنو (GNU) بود که توسط ریچارد استالمن در سال ۱۹۸۳ آغاز شده بود، با هدف ایجاد یک سیستم‌عامل کاملاً آزاد و متن‌باز مشابه یونیکس.

### یونیکس و تأثیر آن بر لینوکس

یونیکس (UNIX) به عنوان یک سیستم‌عامل چندکاربره و چندوظیفه‌ای در اوایل دهه ۱۹۷۰ در آزمایشگاه‌های بل توسط کن تامپسون، دنیس ریچی و دیگران توسعه یافت. این سیستم‌عامل با فلسفه طراحی خاص خود که بر پایه سادگی، ماژولار بودن و استفاده از ابزارهای کوچک اما قدرتمند بود، تأثیر عمیقی بر دنیای کامپیوتر گذاشت.

برخی از اصول طراحی یونیکس که بعدها در لینوکس نیز دنبال شد، عبارتند از:

1. **هر برنامه فقط یک کار را انجام دهد، اما آن کار را به خوبی انجام دهد**
2. **همه چیز یک فایل است** (حتی دستگاه‌های سخت‌افزاری)
3. **ایجاد برنامه‌های کوچک که با یکدیگر همکاری می‌کنند**
4. **استفاده از متن ساده برای ذخیره داده‌ها**
5. **طراحی نرم‌افزار به گونه‌ای که با دیگر برنامه‌ها سازگار باشد**

با گسترش استفاده از یونیکس در محیط‌های دانشگاهی و تجاری، این سیستم‌عامل به یک استاندارد در صنعت کامپیوتر تبدیل شد. با این حال، قیمت بالا و محدودیت‌های مجوز، دسترسی به این سیستم‌عامل قدرتمند را برای بسیاری از کاربران محدود می‌کرد. همین امر زمینه‌ساز تلاش‌هایی برای ایجاد نسخه‌های آزاد و سازگار با یونیکس شد.

لینوکس با الهام از ایده‌ها و معماری یونیکس طراحی شد، اما برخلاف یونیکس، به صورت آزاد و متن‌باز توسعه یافت. این رویکرد باعث شد که لینوکس به سرعت توسط جامعه‌ای از توسعه‌دهندگان در سراسر جهان پذیرفته و گسترش یابد.

### پروژه گنو و رابطه آن با لینوکس

پروژه گنو (GNU's Not Unix) در سال ۱۹۸۳ توسط ریچارد استالمن با هدف ایجاد یک سیستم‌عامل کاملاً آزاد و متن‌باز آغاز شد. استالمن که از روند رو به رشد نرم‌افزارهای انحصاری ناراضی بود، بنیاد نرم‌افزار آزاد (FSF) را تأسیس کرد و توسعه ابزارها و نرم‌افزارهای سیستمی آزاد را آغاز نمود.

تا اوایل دهه ۱۹۹۰، پروژه گنو موفق به توسعه بسیاری از ابزارهای ضروری سیستم‌عامل شده بود، از جمله:

- کامپایلر GCC (GNU Compiler Collection)
- پوسته Bash (Bourne Again SHell)
- ادیتور متنی Emacs
- کتابخانه‌های سیستمی
- ابزارهای کاربردی مختلف

با این حال، یک جزء اساسی همچنان ناقص بود: کرنل سیستم‌عامل. پروژه گنو در حال توسعه کرنل خود به نام GNU Hurd بود، اما این پروژه با پیچیدگی‌های زیادی مواجه شده و پیشرفت آن کند بود.

در همین زمان بود که لینوس توروالدز کرنل لینوکس را منتشر کرد. این کرنل به سرعت با نرم‌افزارهای پروژه گنو ترکیب شد و یک سیستم‌عامل کامل و کاربردی به وجود آورد که امروزه به آن GNU/Linux می‌گوییم.

رابطه بین گنو و لینوکس یک رابطه همزیستی بوده است: کرنل لینوکس یک پلتفرم برای اجرای نرم‌افزارهای گنو فراهم کرد، و ابزارهای گنو، لینوکس را از یک کرنل ساده به یک سیستم‌عامل کامل تبدیل کردند. این ترکیب باعث شد که آرمان ریچارد استالمن در مورد یک سیستم‌عامل کاملاً آزاد، سریع‌تر از آنچه انتظار می‌رفت، محقق شود.

### لینوس توروالدز و ایده اولیه کرنل لینوکس

لینوس توروالدز، دانشجوی 21 ساله فنلاندی در دانشگاه هلسینکی، در سال 1991 پروژه‌ای را آغاز کرد که بعدها به کرنل لینوکس تبدیل شد. او در آن زمان به سیستم‌عامل Minix علاقه‌مند بود، سیستم‌عاملی آموزشی که توسط اندرو تاننباوم برای اهداف آموزشی توسعه یافته بود.

توروالدز از محدودیت‌های Minix ناراضی بود و می‌خواست سیستم‌عاملی ایجاد کند که بتواند از تمام قابلیت‌های پردازنده Intel 80386 استفاده کند. او در ابتدا قصد داشت فقط یک شبیه‌ساز ترمینال بنویسد که بتواند از طریق آن به سرورهای یونیکس دانشگاه متصل شود، اما به تدریج پروژه او گسترش یافت.

در 25 آگوست 1991، توروالدز پیام معروف خود را در گروه خبری comp.os.minix منتشر کرد:

> "سلام به همه کسانی که از Minix استفاده می‌کنند. من در حال ساخت یک سیستم‌عامل (رایگان) (فقط یک سرگرمی، چیزی حرفه‌ای مثل GNU نخواهد بود) برای کلون‌های AT 386(486) هستم..."

در این پیام، او از پروژه خود به عنوان یک سرگرمی یاد کرد و ادعا نمود که چیزی در حد و اندازه گنو نخواهد بود. این تخمین متواضعانه، یکی از بزرگترین اشتباهات پیش‌بینی در تاریخ کامپیوتر بود!

انگیزه اصلی توروالدز از نوشتن لینوکس، یادگیری بیشتر درباره معماری پردازنده‌های x86 و همچنین ایجاد یک سیستم‌عامل مطابق با نیازهای خودش بود. او نمی‌خواست به محدودیت‌های سیستم‌های موجود محدود شود و آزادی بیشتری برای تجربه و یادگیری می‌خواست.

### اولین نسخه‌های کرنل لینوکس

اولین نسخه عمومی لینوکس، نسخه 0.01، در سپتامبر 1991 منتشر شد. این نسخه بسیار ابتدایی بود و تنها شامل حداقل امکانات مورد نیاز بود. کد منبع آن حدود 10,000 خط بود و حتی قادر به اجرای خودش نبود (یعنی نمی‌توانست روی خودش کامپایل شود).

برخی از ویژگی‌های این نسخه اولیه عبارت بودند از:

- پشتیبانی ابتدایی از سیستم فایل
- درایورهای محدود برای سخت‌افزار
- قابلیت اجرای برنامه‌های ساده در خط فرمان
- مدیریت حافظه و فرآیندها به صورت بسیار ابتدایی

نسخه 0.01 فقط روی سخت‌افزار خاصی کار می‌کرد و نیاز به Minix برای اجرا داشت (به عنوان میزبان برای کامپایل و راه‌اندازی).

با انتشار کد منبع، تعداد زیادی از برنامه‌نویسان در سراسر جهان به پروژه علاقه‌مند شدند و شروع به مشارکت در توسعه آن کردند. این مشارکت باعث شد که لینوکس به سرعت پیشرفت کند.

نسخه 0.02 در اکتبر 1991 منتشر شد و شامل بهبودهایی در سیستم فایل و پشتیبانی از سخت‌افزارهای بیشتر بود. در این مرحله، توروالدز تصمیم گرفت کرنل را تحت مجوز GPL (General Public License) منتشر کند، مجوزی که توسط بنیاد نرم‌افزار آزاد برای پروژه گنو ایجاد شده بود.

در دسامبر 1991، نسخه 0.11 منتشر شد که اولین نسخه‌ای بود که می‌توانست مستقل از Minix اجرا شود. این نقطه عطفی برای پروژه بود، زیرا لینوکس دیگر به سیستم‌عامل دیگری وابسته نبود.

نسخه 0.12 در ژانویه 1992 منتشر شد و شامل پشتیبانی از درایورهای بیشتر، بهبود عملکرد و پایداری بیشتر بود. در این زمان، تعداد کاربران لینوکس به چند صد نفر رسیده بود.

فرآیند توسعه با سرعت ادامه یافت و در مارس 1992، نسخه 0.95 منتشر شد که قابلیت‌هایی مانند پشتیبانی از سیستم فایل ext، مدیریت حافظه مجازی و پشتیبانی از پروتکل‌های شبکه TCP/IP را به همراه داشت.

```c
/**
 * A sample of early Linux kernel code (version 0.01) - main.c
 * This code shows the kernel's entry point and initialization
 */

/*
 * (C) 1991 Linus Torvalds
 */

void main(void) {
    /* 
     * Initialize the console, memory system, and scheduling
     * These function calls represent the core initialization 
     * sequence of the early Linux kernel
     */
    tty_init();            /* Console initialization */
    mem_init();            /* Memory management setup */
    sched_init();          /* Process scheduler initialization */
    
    /* Start the first process (init) */
    move_to_user_mode();
    if (!fork()) {         /* Fork failed */
        init();
    }
    
    /* This point is never reached */
    for(;;);
}
```

این کد نمونه‌ای ساده‌شده از ورودی اصلی کرنل در نسخه‌های اولیه است که نشان می‌دهد چگونه کرنل راه‌اندازی می‌شود و سیستم‌های اصلی مانند کنسول، مدیریت حافظه و زمانبندی فرآیندها را آغاز می‌کند.

### تکامل تدریجی لینوکس

پس از انتشار نسخه‌های اولیه، لینوکس به سرعت تکامل یافت. با افزایش تعداد توسعه‌دهندگان و کاربران، قابلیت‌ها و پایداری سیستم نیز بهبود یافت. برخی از مراحل کلیدی در تکامل لینوکس عبارتند از:

**نسخه 1.0 (مارس 1994):**
- اولین نسخه رسمی و پایدار
- پشتیبانی از سیستم فایل‌های متعدد
- بهبود عملکرد شبکه
- پشتیبانی بهتر از سخت‌افزارهای مختلف
- پایداری قابل توجه برای استفاده در محیط‌های تولیدی

**نسخه 2.0 (ژوئن 1996):**
- پشتیبانی از چندپردازنده (SMP - Symmetric Multi-Processing)
- بهبود مدیریت حافظه
- افزایش پشتیبانی از سخت‌افزارها
- پشتیبانی بهتر از پروتکل‌های شبکه

**نسخه 2.2 (ژانویه 1999):**
- بهبود عملکرد SMP
- پشتیبانی از معماری‌های پردازنده بیشتر
- افزایش پشتیبانی از پروتکل‌های شبکه
- سیستم صف ورودی/خروجی جدید

**نسخه 2.4 (ژانویه 2001):**
- پشتیبانی از USB و FireWire
- پشتیبانی بهتر از دستگاه‌های موبایل
- پشتیبانی از ISA Plug and Play
- بهبود عملکرد برای سرورها

**نسخه 2.6 (دسامبر 2003):**
- طراحی مجدد زمانبندی O(1)
- بهبود قابل توجه در مقیاس‌پذیری
- پشتیبانی از NUMA (Non-Uniform Memory Access)
- درایورهای دستگاه قابل بارگذاری در حین اجرا (hotplug)
- کاهش زمان پاسخ دسکتاپ

در طول این سال‌ها، مدل توسعه لینوکس نیز تکامل یافت. در ابتدا، توروالدز شخصاً تمام کدها را بررسی و ادغام می‌کرد، اما با افزایش پیچیدگی و اندازه پروژه، یک مدل سلسله مراتبی توسعه به وجود آمد. در این مدل، توسعه‌دهندگان ارشد مسئولیت بخش‌های خاصی از کرنل را بر عهده گرفتند.

سیستم کنترل نسخه نیز تغییر کرد. در ابتدا، فایل‌های تغییرات (patch) از طریق ایمیل مبادله می‌شدند. سپس از سیستم‌هایی مانند CVS و BitKeeper استفاده شد. در نهایت، در سال 2005، توروالدز سیستم کنترل نسخه Git را ایجاد کرد که امروزه نه تنها برای توسعه لینوکس، بلکه برای بسیاری از پروژه‌های نرم‌افزاری دیگر در سراسر جهان استفاده می‌شود.

با گذشت زمان، لینوکس از یک پروژه شخصی کوچک به یک سیستم‌عامل قدرتمند و همه‌جانبه تبدیل شد که در طیف گسترده‌ای از دستگاه‌ها، از ابررایانه‌ها گرفته تا گوشی‌های هوشمند، اجرا می‌شود. امروزه، هزاران توسعه‌دهنده از شرکت‌های مختلف در سراسر جهان در توسعه کرنل لینوکس مشارکت می‌کنند، و این روند تکاملی همچنان ادامه دارد.

```c
/**
 * Evolution of the Linux networking stack 
 * Comparison between early versions and modern implementation
 */

/* Early version (circa 1992) - simplified */
int tcp_rcv(struct sk_buff *skb) {
    /* Basic error checking */
    if (!skb || !skb->data) 
        return -EINVAL;
    
    /* Simple, linear processing of packet */
    process_tcp_header(skb);
    process_tcp_options(skb);
    process_tcp_data(skb);
    
    return 0;
}

/* Modern version - conceptual representation */
int tcp_v4_rcv(struct sk_buff *skb) {
    struct tcphdr *th;
    struct sock *sk;
    
    /* Extensive checksum and validation */
    if (!pskb_may_pull(skb, sizeof(struct tcphdr)) || 
        __tcp_checksum_complete(skb))
        goto discard_it;
    
    /* Complex header processing */
    th = tcp_hdr(skb);
    
    /* Socket lookup using efficient hash tables */
    sk = __inet_lookup_skb(&tcp_hashinfo, skb, th->source, th->dest);
    
    /* State machine handling with sophisticated locking */
    if (sk_fullsock(sk)) {
        if (sk->sk_state == TCP_TIME_WAIT) {
            /* Time-wait state handling */
            tcp_v4_time_wait(skb, sk);
            goto discard_it;
        }
        
        /* Socket delivery with NAPI, epoll, and other modern features */
        if (tcp_filter(sk, skb))
            goto discard_it;
            
        /* Manage TCP window scaling, timestamps, SACK */
        tcp_options_write((__be32 *)(th + 1),
                         tp, &opts);
                         
        /* Handle congestion control algorithms */
        tcp_cong_control(sk, skb, ack, rtt_us);
    }
    
    /* Complex error handling and more... */
    
    return 0;
    
discard_it:
    /* Reference counting and memory management */
    kfree_skb(skb);
    return 0;
}
```

این نمونه‌کد نشان‌دهنده تفاوت بین پیاده‌سازی ساده و اولیه پشته شبکه TCP در لینوکس و نسخه مدرن و پیچیده آن است. تکامل کد کرنل لینوکس شامل بهبودهای زیادی در کارایی، قابلیت‌های پیشرفته، مدیریت خطا و ساختارهای داده پیچیده شده است.

## معماری کرنل لینوکس

### کرنل مونولیتیک در مقابل میکروکرنل

کرنل‌ها از نظر معماری به چند دسته تقسیم می‌شوند که دو طراحی اصلی آنها کرنل مونولیتیک و میکروکرنل هستند. این دو معماری از نظر فلسفی و عملی تفاوت‌های اساسی با یکدیگر دارند.

**کرنل مونولیتیک (Monolithic Kernel):**
کرنل مونولیتیک یک معماری است که در آن تمامی سرویس‌های سیستم‌عامل (مدیریت حافظه، زمانبندی، سیستم فایل، درایورها) در یک فضای آدرس واحد و در حالت هسته (kernel mode) اجرا می‌شوند. در این معماری:

- تمام کد کرنل به صورت یک فایل اجرایی بزرگ کامپایل می‌شود
- تعاملات بین اجزای کرنل با هزینه کمتری انجام می‌شود (فراخوانی تابع معمولی)
- دسترسی مستقیم به تمام منابع سخت‌افزاری وجود دارد
- معمولاً سرعت اجرای بالاتری دارد

**میکروکرنل (Microkernel):**
میکروکرنل یک معماری است که در آن فقط حداقل عملکردهای ضروری (مانند مدیریت پایه حافظه، ارتباطات بین فرآیندی و زمانبندی اولیه) در هسته قرار می‌گیرند و بقیه سرویس‌ها (مانند سیستم فایل، درایورها، پروتکل‌های شبکه) به صورت فرآیندهای کاربر اجرا می‌شوند. در این معماری:

- هسته کوچک‌تر و ساده‌تر است
- اجزای سیستم از طریق ارسال پیام با یکدیگر ارتباط برقرار می‌کنند
- ثبات و امنیت بیشتری دارد (خرابی یک سرویس می‌تواند بدون تأثیر بر کل سیستم برطرف شود)
- معمولاً سربار ارتباطی بیشتری دارد و کندتر است

لینوکس از معماری مونولیتیک استفاده می‌کند، اما با قابلیت بارگذاری ماژول‌های کرنل در زمان اجرا، تا حدی انعطاف‌پذیری معماری ماژولار را نیز به ارمغان آورده است. این طراحی که گاهی "کرنل مونولیتیک ماژولار" نامیده می‌شود، مزایای هر دو رویکرد را ترکیب کرده است.

بحث معروفی بین لینوس توروالدز (توسعه دهنده لینوکس) و اندرو تاننباوم (طراح Minix با معماری میکروکرنل) در اوایل دهه ۱۹۹۰ در مورد مزایا و معایب این دو رویکرد درگرفت. تاننباوم معتقد بود که میکروکرنل آینده سیستم‌عامل‌ها را تشکیل می‌دهد، در حالی که توروالدز از مزایای عملکردی کرنل مونولیتیک دفاع می‌کرد. تاریخ نشان داد که هر دو دیدگاه ارزش‌های خود را دارند و در حوزه‌های مختلف کاربرد دارند.

### مزایا و معایب معماری مونولیتیک لینوکس

طراحی مونولیتیک لینوکس مزایا و معایب خاص خود را دارد که در طول زمان با بلوغ پروژه و اضافه شدن ویژگی‌هایی مانند ماژول‌های قابل بارگذاری کرنل، تعادل بهتری بین آنها ایجاد شده است.

**مزایا:**

1. **کارایی بالا**: به دلیل اجرای تمام کد کرنل در یک فضای آدرس واحد، تعاملات بین اجزای کرنل با هزینه کمتری انجام می‌شود. فراخوانی‌های تابع مستقیم بسیار سریع‌تر از ارسال پیام بین فرآیندها هستند.

2. **دسترسی مستقیم به سخت‌افزار**: تمام بخش‌های کرنل می‌توانند مستقیماً به تمام منابع سخت‌افزاری دسترسی داشته باشند، که باعث ساده‌تر شدن توسعه و کارایی بیشتر می‌شود.

3. **اشتراک آسان داده‌ها**: ساختارهای داده می‌توانند به راحتی بین بخش‌های مختلف کرنل به اشتراک گذاشته شوند.

4. **بهینه‌سازی سراسری**: امکان بهینه‌سازی کد در سطح کل کرنل وجود دارد.

5. **انعطاف‌پذیری با ماژول‌ها**: سیستم ماژول‌های لینوکس اجازه می‌دهد بخش‌های کرنل به صورت پویا بارگذاری و حذف شوند، که انعطاف‌پذیری را افزایش می‌دهد.

**معایب:**

1. **پیچیدگی**: با بزرگ شدن کرنل، مدیریت و توسعه آن پیچیده‌تر می‌شود. پایگاه کد کرنل لینوکس امروزه بسیار بزرگ و پیچیده است.

2. **خطرات ثبات**: یک اشکال در هر بخش از کرنل می‌تواند کل سیستم را دچار مشکل کند. هیچ جداسازی حافظه‌ای بین اجزای مختلف کرنل وجود ندارد.

3. **چالش‌های امنیتی**: آسیب‌پذیری در یک بخش از کرنل می‌تواند کل سیستم را در معرض خطر قرار دهد.

4. **نیاز به راه‌اندازی مجدد برای به‌روزرسانی‌های اساسی**: برخی تغییرات در کرنل نیازمند راه‌اندازی مجدد سیستم هستند، هرچند با قابلیت‌هایی مانند kpatch و kGraft می‌توان برخی وصله‌ها را بدون راه‌اندازی مجدد اعمال کرد.

5. **مسائل مقیاس‌پذیری**: مشکلات مقیاس‌پذیری می‌تواند در سیستم‌های چندپردازنده بزرگ رخ دهد، هرچند توسعه‌دهندگان لینوکس تلاش زیادی برای بهبود این مسائل انجام داده‌اند.

لینوکس برای کاهش معایب معماری مونولیتیک، راهکارهایی را اتخاذ کرده است:

```c
/**
 * Example of Linux kernel module structure
 * This shows how Linux combines monolithic architecture with modularity
 */

#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

/* Module metadata */
MODULE_LICENSE("GPL");
MODULE_AUTHOR("Author Name");
MODULE_DESCRIPTION("Example kernel module");
MODULE_VERSION("1.0");

/* Module initialization function */
static int __init example_init(void) {
    printk(KERN_INFO "Example module loaded\n");
    return 0;
}

/* Module cleanup function */
static void __exit example_exit(void) {
    printk(KERN_INFO "Example module unloaded\n");
}

/* Register init/exit functions */
module_init(example_init);
module_exit(example_exit);
```

این کد یک نمونه ساده از ساختار یک ماژول کرنل لینوکس را نشان می‌دهد. ماژول‌های کرنل به لینوکس اجازه می‌دهند که مزایای انعطاف‌پذیری معماری ماژولار را در یک کرنل مونولیتیک ترکیب کند.

### ساختار لایه‌ای کرنل لینوکس

کرنل لینوکس، علی‌رغم ماهیت مونولیتیک خود، دارای یک ساختار لایه‌ای است که به سازماندهی و مدیریت پیچیدگی آن کمک می‌کند. این لایه‌بندی بیشتر یک مفهوم منطقی است، زیرا در عمل، اجزای کرنل می‌توانند مستقیماً با یکدیگر ارتباط برقرار کنند.

لایه‌های اصلی کرنل لینوکس به شرح زیر هستند (از بالا به پایین):

**۱. لایه فراخوانی سیستمی (System Call Interface)**:
- واسط بین فضای کاربر و فضای کرنل
- نقطه ورودی به کرنل برای برنامه‌های کاربردی
- تبدیل درخواست‌های برنامه‌ها به عملیات کرنل

**۲. لایه مدیریت فرآیند (Process Management)**:
- مدیریت ایجاد، تعلیق، ادامه و خاتمه فرآیندها
- زمانبندی فرآیندها برای اجرا روی پردازنده‌ها
- سیستم‌های مرتبط با ارتباطات بین فرآیندی (IPC)

**۳. لایه حافظه مجازی (Virtual Memory)**:
- مدیریت فضای آدرس مجازی برای فرآیندها
- پیاده‌سازی صفحه‌بندی و سازوکارهای مرتبط
- مدیریت صفحه گردانی و سیاست‌های تعویض

**۴. لایه سیستم فایل (File System)**:
- ارائه سیستم فایل مجازی (VFS) به عنوان یک لایه انتزاعی
- پشتیبانی از انواع مختلف سیستم‌های فایل (ext4, XFS, Btrfs و غیره)
- مدیریت فایل‌ها، دایرکتوری‌ها و مجوزها

**۵. لایه کش و بافر (Caching Layer)**:
- ذخیره موقت داده‌ها برای بهبود کارایی
- مدیریت کش دیسک و بافرها
- سیاست‌های همگام‌سازی داده‌ها با دیسک

**۶. لایه شبکه (Network Stack)**:
- پیاده‌سازی پروتکل‌های شبکه
- مدیریت اتصالات و بسته‌های شبکه
- پشتیبانی از سوکت‌ها و واسط‌های شبکه

**۷. لایه درایورهای دستگاه (Device Drivers)**:
- ارتباط با سخت‌افزارهای متصل به سیستم
- مدیریت انواع مختلف دستگاه‌ها (بلوکی، کاراکتری و غیره)
- پیاده‌سازی رابط‌های خاص سخت‌افزار

**۸. لایه مدیریت معماری (Architecture Management)**:
- کد وابسته به معماری سخت‌افزاری خاص
- مدیریت وقفه‌ها و تایمرها
- راه‌اندازی و مدیریت سخت‌افزار پایه

این لایه‌بندی به توسعه‌دهندگان کمک می‌کند تا با یک ساختار منطقی مشخص کار کنند، هرچند در عمل، مرز بین این لایه‌ها گاهی مبهم است و اجزای مختلف می‌توانند فراتر از محدوده لایه خود عمل کنند.

```c
/**
 * Simplified representation of layered interactions in Linux kernel
 * Shows how a system call travels through kernel layers
 */

/* User space application making a system call */
int main() {
    int fd = open("/path/to/file", O_RDONLY);  // User application calling open()
    // ...
}

/* System Call Interface Layer */
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
    /* Validate user parameters */
    if (IS_ERR(filename))
        return PTR_ERR(filename);
    
    /* Process Management Layer (checking permissions) */
    if (!may_open_file(current, filename, flags))
        return -EACCES;
    
    /* File System Layer */
    struct file *file = do_filp_open(AT_FDCWD, filename, flags, mode);
    if (IS_ERR(file))
        return PTR_ERR(file);
    
    /* Getting a file descriptor from the process's file table */
    fd = get_unused_fd_flags(flags);
    if (fd >= 0)
        fd_install(fd, file);
    
    return fd;
}

/* File System Layer functions */
struct file *do_filp_open(int dfd, struct filename *filename, int flags, umode_t mode)
{
    /* VFS operations to find and open the file */
    struct path path;
    struct file *file;
    
    /* Path lookup (traversing directories) */
    error = path_lookup(filename, flags, &path);
    
    /* Creating a file structure */
    file = alloc_file(&path, flags, fops);
    
    /* Device Driver Layer - if this is a device file */
    if (S_ISCHR(path.dentry->d_inode->i_mode))
        error = chrdev_open(path.dentry->d_inode, file);
        
    return file;
}

/* Device Driver Layer */
int chrdev_open(struct inode *inode, struct file *filp)
{
    const struct file_operations *fops;
    
    /* Find the appropriate driver */
    struct cdev *cdev = inode->i_cdev;
    
    /* Call the specific device driver's open function */
    if (cdev->ops->open)
        return cdev->ops->open(inode, filp);
        
    return 0;
}

/* Architecture Specific Layer (hardware interaction) */
static int device_specific_open(struct inode *inode, struct file *filp)
{
    /* Hardware specific operations */
    void __iomem *base = ioremap(DEVICE_BASE_ADDR, DEVICE_SIZE);
    
    /* Initialize the hardware */
    writel(DEVICE_INIT_VALUE, base + DEVICE_CONTROL_REG);
    
    return 0;
}
```

این نمونه کد به صورت ساده‌شده نشان می‌دهد که چگونه یک فراخوانی سیستمی مانند `open()` از لایه‌های مختلف کرنل عبور می‌کند تا در نهایت به عملیات سخت‌افزاری تبدیل شود.

### ماژول‌های کرنل

ماژول‌های کرنل یکی از نوآوری‌های مهم در طراحی لینوکس هستند که به این سیستم‌عامل انعطاف‌پذیری قابل توجهی بخشیده‌اند. ماژول‌ها بخش‌هایی از کد کرنل هستند که می‌توانند به صورت پویا در زمان اجرا بارگذاری یا از حافظه خارج شوند، بدون نیاز به راه‌اندازی مجدد سیستم.

**ویژگی‌های اصلی ماژول‌های کرنل:**

1. **بارگذاری پویا**: قابلیت افزودن و حذف عملکردها بدون نیاز به کامپایل مجدد کرنل یا راه‌اندازی مجدد سیستم

2. **بهینه‌سازی منابع**: فقط ماژول‌های مورد نیاز بارگذاری می‌شوند، که باعث صرفه‌جویی در حافظه و منابع سیستم می‌شود

3. **توسعه آسان‌تر**: توسعه‌دهندگان می‌توانند درایورها و ویژگی‌های جدید را بدون تغییر در هسته اصلی کرنل ایجاد کنند

4. **دسترسی کامل به API کرنل**: ماژول‌ها به تمام توابع و ساختارهای داده کرنل دسترسی دارند

**انواع ماژول‌های کرنل:**

- **درایورهای دستگاه**: بیشترین کاربرد ماژول‌ها، پیاده‌سازی درایورها برای سخت‌افزارهای مختلف است
- **سیستم‌های فایل**: پشتیبانی از سیستم‌های فایل مختلف اغلب به صورت ماژول پیاده‌سازی می‌شود
- **پروتکل‌های شبکه**: پروتکل‌های مختلف شبکه می‌توانند به صورت ماژول بارگذاری شوند
- **ویژگی‌های امنیتی**: ماژول‌های امنیتی مانند SELinux یا AppArmor
- **ماژول‌های کمکی**: برای اضافه کردن قابلیت‌های متنوع به کرنل

**مدیریت ماژول‌ها:**

لینوکس ابزارهایی برای مدیریت ماژول‌ها ارائه می‌دهد:

- `insmod`: برای نصب یک ماژول
- `rmmod`: برای حذف یک ماژول
- `modprobe`: برای نصب یا حذف ماژول با در نظر گرفتن وابستگی‌ها
- `lsmod`: برای نمایش لیست ماژول‌های فعال
- `modinfo`: برای نمایش اطلاعات درباره یک ماژول

**وابستگی‌های ماژول:**

ماژول‌ها می‌توانند به یکدیگر وابسته باشند. لینوکس از این وابستگی‌ها آگاه است و هنگام بارگذاری یک ماژول، ماژول‌های وابسته به آن را نیز بارگذاری می‌کند. همچنین، هنگام حذف یک ماژول، اطمینان حاصل می‌کند که هیچ ماژول دیگری به آن وابسته نباشد.

**امنیت ماژول‌ها:**

از آنجا که ماژول‌ها با امتیازات کامل کرنل اجرا می‌شوند، می‌توانند خطرات امنیتی ایجاد کنند. به همین دلیل:

- فقط کاربر ریشه (root) می‌تواند ماژول‌ها را نصب یا حذف کند
- در بسیاری از توزیع‌های لینوکس، ماژول‌ها باید امضای دیجیتال داشته باشند
- قابلیت بارگذاری ماژول می‌تواند برای افزایش امنیت غیرفعال شود

```c
/**
 * Example of module dependencies in Linux
 * Shows how modules can export symbols for other modules to use
 */

/* In module_a.c */
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

/* Function to be exported */
int shared_function(int value) {
    printk(KERN_INFO "Shared function called with value: %d\n", value);
    return value * 2;
}

/* Export the symbol so other modules can use it */
EXPORT_SYMBOL(shared_function);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Author Name");
MODULE_DESCRIPTION("Module A with exported function");

static int __init mod_a_init(void) {
    printk(KERN_INFO "Module A loaded\n");
    return 0;
}

static void __exit mod_a_exit(void) {
    printk(KERN_INFO "Module A unloaded\n");
}

module_init(mod_a_init);
module_exit(mod_a_exit);

/* In module_b.c - depends on module_a */
#include <linux/module.h>
#include <linux/kernel.h>
#include <linux/init.h>

/* Declare the external function */
extern int shared_function(int value);

MODULE_LICENSE("GPL");
MODULE_AUTHOR("Author Name");
MODULE_DESCRIPTION("Module B that depends on Module A");
/* Declare dependency */
MODULE_DEPENDS("module_a");

static int __init mod_b_init(void) {
    int result;
    printk(KERN_INFO "Module B loaded\n");
    
    /* Call the function from module_a */
    result = shared_function(10);
    printk(KERN_INFO "Result from shared function: %d\n", result);
    
    return 0;
}

static void __exit mod_b_exit(void) {
    printk(KERN_INFO "Module B unloaded\n");
}

module_init(mod_b_init);
module_exit(mod_b_exit);
```

این مثال نشان می‌دهد که چگونه ماژول‌ها می‌توانند توابع و سمبل‌های خود را برای استفاده سایر ماژول‌ها صادر کنند و چگونه وابستگی‌ها مدیریت می‌شوند.

### فضای کرنل و فضای کاربر

یکی از مفاهیم اساسی در طراحی سیستم‌عامل لینوکس، تفکیک بین "فضای کرنل" و "فضای کاربر" است. این جداسازی برای امنیت، پایداری و حفاظت از منابع سیستم ضروری است.

**فضای کرنل (Kernel Space):**

فضای کرنل بخشی از حافظه سیستم است که فقط برای کرنل سیستم‌عامل رزرو شده است. در این فضا:

- کد کرنل و داده‌های آن قرار دارند
- دسترسی مستقیم به سخت‌افزار وجود دارد
- تمام سطوح دسترسی CPU (حلقه‌های 0 تا 3 در معماری x86) در دسترس هستند
- کد با بالاترین امتیازات (حلقه 0) اجرا می‌شود
- ماژول‌های کرنل در این فضا بارگذاری و اجرا می‌شوند
- خطاها در این فضا می‌توانند باعث سقوط کل سیستم شوند

**فضای کاربر (User Space):**

فضای کاربر بخشی از حافظه است که برنامه‌های کاربردی در آن اجرا می‌شوند. در این فضا:

- برنامه‌های کاربردی، کتابخانه‌ها و داده‌های آنها قرار دارند
- دسترسی مستقیم به سخت‌افزار وجود ندارد
- کد با محدودترین امتیازات (حلقه 3 در معماری x86) اجرا می‌شود
- خطاها فقط به برنامه مربوطه محدود می‌شوند و کل سیستم را تحت تأثیر قرار نمی‌دهند
- دسترسی به منابع سیستم از طریق فراخوانی‌های سیستمی انجام می‌شود

**تعامل بین فضای کاربر و کرنل:**

برنامه‌های کاربردی برای دسترسی به منابع سیستم (مانند فایل‌ها، شبکه، حافظه، سخت‌افزار) باید با کرنل ارتباط برقرار کنند. این ارتباط از طریق "فراخوانی‌های سیستمی" انجام می‌شود:

1. برنامه کاربر درخواستی را از طریق فراخوانی سیستمی ارسال می‌کند
2. CPU از حالت کاربر (حلقه 3) به حالت کرنل (حلقه 0) تغییر وضعیت می‌دهد (context switch)
3. کرنل درخواست را بررسی، اعتبارسنجی و پردازش می‌کند
4. کرنل نتیجه را به فضای کاربر برمی‌گرداند
5. CPU به حالت کاربر بازمی‌گردد

**مکانیزم‌های حفاظتی:**

لینوکس از چندین مکانیزم برای محافظت از فضای کرنل استفاده می‌کند:

- **حفاظت حافظه**: MMU (Memory Management Unit) از دسترسی غیرمجاز به حافظه جلوگیری می‌کند
- **سطوح امتیازات پردازنده**: با استفاده از حلقه‌های حفاظتی CPU، دسترسی به دستورات حساس محدود می‌شود
- **فضای آدرس مجازی**: هر فرآیند فضای آدرس مجازی خود را دارد و نمی‌تواند به فضای دیگر فرآیندها دسترسی پیدا کند
- **کنترل دسترسی**: بررسی مجوزها و توانایی‌ها قبل از انجام عملیات

```c
/**
 * Example of userspace to kernel space transition via system call
 * This demonstrates how processes cross the boundary between user and kernel space
 */

/* User space C code calling write() system call */
#include <unistd.h>
#include <string.h>

int main() {
    const char *message = "Hello, Kernel!";
    write(1, message, strlen(message));  // System call to write to stdout (fd=1)
    return 0;
}

/* Inside the kernel: system call implementation */
SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)
{
    struct file *file;
    ssize_t ret = -EBADF;
    
    /* Get file from file descriptor - security check happens here */
    file = fget_light(fd, &fput_needed);
    if (!file)
        goto out;
    
    /* Verify user space buffer is accessible and valid */
    if (!access_ok(VERIFY_READ, buf, count)) {
        ret = -EFAULT;
        goto out_put;
    }
    
    /* Perform the actual writing operation */
    ret = vfs_write(file, buf, count, &pos);
    
out_put:
    fput_light(file, fput_needed);
out:
    return ret;
}
```

این نمونه کد نشان می‌دهد که چگونه یک برنامه در فضای کاربر با فراخوانی تابع `write()` به کرنل مراجعه می‌کند و چگونه کرنل بررسی‌های امنیتی را انجام می‌دهد تا از دسترسی معتبر اطمینان حاصل کند.

### سیستم فراخوانی سیستمی

فراخوانی‌های سیستمی (System Calls) واسط اصلی بین فضای کاربر و فضای کرنل هستند. این فراخوانی‌ها، API کرنل را برای برنامه‌های کاربردی فراهم می‌کنند تا بتوانند از خدماتی مانند عملیات ورودی/خروجی، مدیریت فرآیند، مدیریت حافظه و دسترسی به سخت‌افزار استفاده کنند.

**ویژگی‌های فراخوانی‌های سیستمی:**

1. **نقطه ورود کنترل‌شده**: تنها راه ورود امن به کرنل از فضای کاربر هستند
2. **انتزاع سخت‌افزار**: جزئیات پیچیده سخت‌افزار را از برنامه‌های کاربردی پنهان می‌کنند
3. **کنترل دسترسی**: کرنل می‌تواند درخواست‌ها را اعتبارسنجی کرده و از دسترسی‌های غیرمجاز جلوگیری کند
4. **هزینه عملکردی**: فراخوانی‌های سیستمی نسبت به فراخوانی‌های تابع معمولی هزینه اجرایی بیشتری دارند
5. **پایداری API**: فراخوانی‌های سیستمی به عنوان بخشی از ABI (Application Binary Interface) لینوکس، نسبتاً پایدار هستند

**دسته‌بندی فراخوانی‌های سیستمی در لینوکس:**

لینوکس بیش از 300 فراخوانی سیستمی دارد که می‌توان آنها را به گروه‌های زیر تقسیم کرد:

- **مدیریت فرآیند**: `fork()`, `exec()`, `exit()`, `wait()`, `kill()`
- **مدیریت حافظه**: `brk()`, `mmap()`, `munmap()`
- **عملیات فایل**: `open()`, `read()`, `write()`, `close()`, `stat()`
- **مدیریت دایرکتوری**: `mkdir()`, `rmdir()`, `link()`, `unlink()`
- **ارتباطات بین فرآیندی**: `pipe()`, `socket()`, `shmget()`
- **مدیریت زمان**: `time()`, `gettimeofday()`, `nanosleep()`
- **مدیریت سیستم**: `mount()`, `reboot()`, `syslog()`
- **کنترل دسترسی**: `chmod()`, `chown()`, `setuid()`

**مکانیزم فراخوانی سیستمی:**

روند یک فراخوانی سیستمی به طور کلی به شرح زیر است:

1. **آماده‌سازی پارامترها**: برنامه کاربردی پارامترهای لازم را در رجیسترهای CPU یا پشته قرار می‌دهد
2. **ایجاد وقفه نرم‌افزاری**: از طریق دستور خاص معماری (مثلاً `syscall` در x86_64 یا `svc` در ARM)
3. **تغییر به حالت کرنل**: CPU به حالت کرنل (حلقه 0) منتقل می‌شود
4. **یافتن کد مناسب**: کرنل شماره فراخوانی سیستمی را بررسی و تابع مربوطه را پیدا می‌کند
5. **اعتبارسنجی پارامترها**: کرنل پارامترهای ارائه شده را بررسی می‌کند
6. **اجرای سرویس**: کرنل درخواست را پردازش می‌کند
7. **بازگشت نتیجه**: کرنل نتیجه را در رجیستر مشخصی قرار می‌دهد
8. **بازگشت به حالت کاربر**: CPU به حالت کاربر (حلقه 3) بازمی‌گردد و اجرای برنامه ادامه می‌یابد

**پیاده‌سازی فراخوانی‌های سیستمی در لینوکس:**

در کد منبع کرنل لینوکس، فراخوانی‌های سیستمی به وسیله ماکروی `SYSCALL_DEFINEx` تعریف می‌شوند، که در آن `x` نشان‌دهنده تعداد پارامترهای فراخوانی سیستمی است.

```c
/**
 * Example of system call implementation in Linux kernel
 * Shows how the open() system call is defined
 */

/* System call definition for open() */
SYSCALL_DEFINE3(open, const char __user *, filename, int, flags, umode_t, mode)
{
    /* Convert user-provided filename to kernel struct */
    struct filename *tmp = getname(filename);
    int fd;
    
    /* Check for errors in filename */
    if (IS_ERR(tmp))
        return PTR_ERR(tmp);
    
    /* Call the actual implementation */
    fd = do_sys_open(AT_FDCWD, tmp, flags, mode);
    putname(tmp);
    return fd;
}

/* Actual implementation that does the work */
long do_sys_open(int dfd, const char __user *filename, int flags, umode_t mode)
{
    struct open_flags op;
    int fd;
    
    /* Validate flags */
    int ret = build_open_flags(flags, mode, &op);
    if (ret)
        return ret;
    
    /* Allocate a new file descriptor */
    fd = get_unused_fd_flags(flags);
    if (fd >= 0) {
        struct file *f = do_filp_open(dfd, filename, &op);
        if (IS_ERR(f)) {
            put_unused_fd(fd);
            fd = PTR_ERR(f);
        } else {
            /* Associate the file descriptor with the file */
            fd_install(fd, f);
        }
    }
    
    return fd;
}
```

**لایه‌های کتابخانه‌ای:**

برنامه‌های کاربردی معمولاً به جای فراخوانی مستقیم سیستمی، از توابع کتابخانه‌ای مانند کتابخانه استاندارد C (glibc) استفاده می‌کنند. این کتابخانه‌ها یک لایه انتزاعی اضافی ارائه می‌دهند که:

- فراخوانی‌های سیستمی را ساده‌تر می‌کنند
- سازگاری بین پلتفرم‌های مختلف را فراهم می‌کنند
- در برخی موارد، با بافرینگ و پردازش‌های دیگر، کارایی را بهبود می‌بخشند

به عنوان مثال، تابع `printf()` در کتابخانه C در نهایت از فراخوانی سیستمی `write()` برای نمایش متن استفاده می‌کند، اما پیش از آن، قالب‌بندی متن را انجام می‌دهد.

**مقایسه با سایر سیستم‌عامل‌ها:**

تقریباً تمام سیستم‌عامل‌های مدرن از مفهوم فراخوانی سیستمی استفاده می‌کنند، اما تعداد، نام و رفتار آنها متفاوت است. برای مثال:

- **Windows**: از مکانیزم متفاوتی به نام Windows API استفاده می‌کند که در آن، فراخوانی‌ها پیچیده‌تر و لایه‌ای‌تر هستند
- **macOS/iOS**: از فراخوانی‌های سیستمی سازگار با UNIX همراه با اضافات خاص اپل استفاده می‌کند
- **BSD**: فراخوانی‌های سیستمی مشابه با لینوکس دارد اما با تفاوت‌های جزئی

**تغییرات و تکامل:**

سیستم فراخوانی سیستمی لینوکس به مرور زمان تکامل یافته است:

- برخی فراخوانی‌های قدیمی منسوخ شده‌اند
- نسخه‌های جدیدتر با پارامترهای بیشتر یا رفتار بهبود یافته اضافه شده‌اند (مانند `openat()` به جای `open()`)
- مکانیزم‌های جدیدی مانند `ioctl()` برای عملیات اختصاصی دستگاه‌ها اضافه شده‌اند
- معرفی syscall multiplexer مانند `socketcall()` برای کاهش تعداد نقاط ورودی

توسعه‌دهندگان کرنل لینوکس تلاش می‌کنند تا سازگاری رو به عقب را حفظ کنند، به این معنی که برنامه‌های قدیمی‌تر همچنان باید با نسخه‌های جدیدتر کرنل کار کنند، بدون نیاز به تغییر یا کامپایل مجدد.

### خلاصه معماری کرنل لینوکس

معماری کرنل لینوکس یک طراحی مونولیتیک با قابلیت‌های ماژولار است که در عین حفظ کارایی بالا، انعطاف‌پذیری قابل توجهی را فراهم می‌کند. ویژگی‌های کلیدی این معماری عبارتند از:

1. **کرنل مونولیتیک ماژولار**: یک معماری کرنل واحد که با سیستم ماژول‌ها قابلیت گسترش پویا را دارد

2. **ساختار لایه‌ای منطقی**: سازماندهی کد در لایه‌های مختلف از فراخوانی‌های سیستمی تا درایورهای سخت‌افزاری

3. **جداسازی فضای کاربر و کرنل**: تفکیک امنیتی بین برنامه‌های کاربردی و کد امتیاز بالای کرنل

4. **واسط فراخوانی سیستمی**: مکانیزم کنترل‌شده برای تعامل بین برنامه‌های کاربردی و کرنل

5. **سیستم ماژول‌های پویا**: امکان افزودن و حذف قابلیت‌ها بدون نیاز به راه‌اندازی مجدد

این معماری به لینوکس اجازه داده است تا ضمن حفظ عملکرد بالا، در طیف گسترده‌ای از دستگاه‌ها از ریزپردازنده‌های نهفته تا ابررایانه‌ها مورد استفاده قرار گیرد. تعادل بین کارایی معماری مونولیتیک و انعطاف‌پذیری سیستم ماژولار، یکی از دلایل اصلی موفقیت لینوکس بوده است.

طراحی هوشمندانه معماری کرنل لینوکس، امکان توسعه سریع و مداوم این سیستم‌عامل را فراهم کرده است، به طوری که در طول بیش از سه دهه، کرنل لینوکس توانسته است با تغییرات سریع فناوری همگام شده و همزمان سازگاری با کدهای قدیمی را حفظ کند.

## ویژگی‌های اصلی کرنل لینوکس

کرنل لینوکس دارای ویژگی‌های متعددی است که آن را به یک انتخاب مناسب برای طیف گسترده‌ای از کاربردها، از سیستم‌های نهفته گرفته تا ابررایانه‌ها، تبدیل کرده است. در این بخش، مهم‌ترین ویژگی‌های کرنل لینوکس را بررسی می‌کنیم.

### چند وظیفه‌ای پیشگیرانه

یکی از ویژگی‌های اصلی کرنل لینوکس، پشتیبانی از چند وظیفه‌ای پیشگیرانه (Preemptive Multitasking) است. در این نوع چند وظیفه‌ای، کرنل می‌تواند اجرای یک فرآیند را متوقف کرده و به فرآیند دیگری زمان پردازنده تخصیص دهد، حتی اگر فرآیند اول تمایلی به واگذاری پردازنده نداشته باشد.

**مزایای چند وظیفه‌ای پیشگیرانه:**

- **پاسخگویی بهتر سیستم**: فرآیندهای با اولویت بالاتر می‌توانند سریع‌تر به منابع پردازنده دسترسی پیدا کنند
- **توزیع عادلانه‌تر منابع**: یک فرآیند نمی‌تواند به طور نامحدود پردازنده را اشغال کند
- **قابلیت اطمینان بیشتر**: حتی اگر یک برنامه وارد حلقه بی‌نهایت شود، سیستم همچنان پاسخگو خواهد بود

لینوکس از الگوریتم‌های پیچیده زمانبندی استفاده می‌کند که بر اساس اولویت‌ها، مدت زمان اجرا، و سایر فاکتورها فرآیندها را زمانبندی می‌کنند. همچنین، کرنل لینوکس از نسخه 2.6 به بعد، قابلیت پیشگیری کامل (Fully Preemptible) را ارائه می‌دهد که حتی کد کرنل نیز می‌تواند تحت شرایط خاصی پیشگیری شود.

```c
/**
 * Example of scheduler code in Linux that demonstrates preemption
 * Simplified version of schedule() function
 */
asmlinkage __visible void __sched schedule(void)
{
    struct task_struct *prev, *next;
    struct rq *rq;
    int cpu;

    cpu = smp_processor_id();
    rq = cpu_rq(cpu);
    prev = rq->curr;

    /* Find the highest priority task that is ready to run */
    next = pick_next_task(rq, prev);

    /* If a different task is selected, switch to it */
    if (likely(prev != next)) {
        rq->curr = next;
        /* Context switch - save current state and load new task state */
        context_switch(rq, prev, next);
    }
}
```

این نمونه کد ساده‌شده نشان می‌دهد چگونه لینوکس به طور دوره‌ای تابع `schedule()` را فراخوانی می‌کند تا فرآیند با بالاترین اولویت را انتخاب کرده و در صورت لزوم، تعویض زمینه (context switch) انجام دهد.

### پشتیبانی از چند پردازنده

لینوکس از نسخه 2.0 (1996) از سیستم‌های چندپردازنده‌ای (SMP - Symmetric Multi-Processing) پشتیبانی می‌کند. این قابلیت به لینوکس اجازه می‌دهد تا از منابع محاسباتی چندین پردازنده (یا هسته پردازشی) به طور همزمان استفاده کند.

**ویژگی‌های پشتیبانی چندپردازنده‌ای در لینوکس:**

- **مقیاس‌پذیری**: قابلیت استفاده مؤثر از تعداد زیادی پردازنده (از چند هسته تا هزاران هسته در ابررایانه‌ها)
- **تعادل بار**: توزیع هوشمند فرآیندها بین پردازنده‌های موجود
- **تخصیص منابع پویا**: تخصیص پردازنده‌ها به فرآیندها بر اساس نیاز و بار سیستم
- **قفل‌های ظریف**: استفاده از مکانیزم‌های قفل‌گذاری با سطوح مختلف برای بهینه‌سازی هم‌روندی
- **جداسازی NUMA**: آگاهی از توپولوژی حافظه غیریکنواخت (Non-Uniform Memory Access) برای بهینه‌سازی دسترسی‌های حافظه

کرنل لینوکس در طول زمان، پشتیبانی خود از سیستم‌های چندپردازنده‌ای را به طور قابل توجهی بهبود بخشیده است. در نسخه‌های اولیه، یک قفل بزرگ کرنل (Big Kernel Lock) تنها یک پردازنده را به اجرای کد کرنل محدود می‌کرد، اما در نسخه‌های جدیدتر، با استفاده از قفل‌های ظریف‌تر و تکنیک‌های پیشرفته هم‌روندی، کرنل می‌تواند به طور همزمان روی چندین پردازنده اجرا شود.

```c
/**
 * Example of fine-grained locking in the Linux kernel
 * Demonstrates how Linux uses various locking mechanisms for SMP
 */
struct task_struct *find_task_by_pid_ns(pid_t nr, struct pid_namespace *ns)
{
    struct task_struct *task;
    
    /* Use RCU (Read-Copy-Update) for lockless read access */
    rcu_read_lock();
    
    task = pid_task(find_pid_ns(nr, ns), PIDTYPE_PID);
    
    rcu_read_unlock();
    
    return task;
}

static int write_task_data(struct task_struct *task, void __user *buffer, size_t size)
{
    int ret;
    
    /* Use spinlock for short critical section on SMP systems */
    spin_lock_irq(&task->sighand->siglock);
    
    /* Access protected data */
    ret = copy_to_user(buffer, &task->signal->data, size);
    
    spin_unlock_irq(&task->sighand->siglock);
    
    return ret;
}

/* Using RwLock for data that is read frequently but written rarely */
static int modify_shared_resource(struct shared_resource *res, int new_value)
{
    int ret;
    
    /* Get write lock (exclusive access) */
    write_lock(&res->lock);
    
    /* Modify the shared resource */
    res->value = new_value;
    ret = res->value;
    
    write_unlock(&res->lock);
    
    return ret;
}
```

این نمونه کد نشان می‌دهد چگونه لینوکس از انواع مختلف قفل‌ها (RCU، اسپین‌لاک، قفل خواندن/نوشتن) برای مدیریت دسترسی هم‌روند به منابع مشترک در محیط‌های چندپردازنده‌ای استفاده می‌کند.

### قابلیت حمل

یکی از قابلیت‌های برجسته کرنل لینوکس، قابلیت حمل (Portability) فوق‌العاده آن است. لینوکس برای طیف گسترده‌ای از معماری‌های پردازنده و پلتفرم‌های سخت‌افزاری پورت (انتقال) شده است، از میکروکنترلرهای کوچک تا ابررایانه‌های قدرتمند.

**معماری‌های پردازنده پشتیبانی شده توسط لینوکس:**

- **x86 و x86-64** (Intel، AMD)
- **ARM و ARM64** (Qualcomm، Samsung، Apple، و غیره)
- **PowerPC و POWER** (IBM)
- **MIPS** (پیش‌تر از SGI، اکنون در بسیاری از دستگاه‌های نهفته)
- **SPARC** (Oracle، پیش‌تر Sun)
- **RISC-V** (معماری متن‌باز جدید)
- **s390** (سرورهای مین‌فریم IBM)
- و بسیاری دیگر...

**عوامل کلیدی قابلیت حمل لینوکس:**

1. **جداسازی کد وابسته به معماری**: کرنل لینوکس به طور واضح کد وابسته به سخت‌افزار را از کد مستقل از سخت‌افزار جدا می‌کند. در ساختار درختی کد منبع، دایرکتوری `arch/` شامل کد خاص هر معماری است، در حالی که بخش‌های دیگر مستقل از معماری هستند.

2. **لایه انتزاعی سخت‌افزار**: لینوکس از چندین لایه انتزاعی استفاده می‌کند تا تفاوت‌های بین پلتفرم‌ها را پنهان کند.

3. **کامپایل متقاطع**: سیستم ساخت لینوکس به راحتی از کامپایل متقاطع (Cross-Compilation) پشتیبانی می‌کند، یعنی می‌توان کرنل را روی یک معماری برای اجرا روی معماری دیگر کامپایل کرد.

4. **معماری ماژولار درایورها**: سیستم درایور دستگاه لینوکس به گونه‌ای طراحی شده است که درایورهای جدید می‌توانند بدون تغییر در هسته کرنل اضافه شوند.

```c
/**
 * Example of architecture-specific code in Linux
 * Shows how Linux separates architecture-dependent code
 */

/* arch/x86/kernel/process.c - x86 specific process handling */
void arch_cpu_idle(void)
{
    /* x86 specific CPU idle implementation */
    native_safe_halt();
}

/* arch/arm/kernel/process.c - ARM specific process handling */
void arch_cpu_idle(void)
{
    /* ARM specific CPU idle implementation */
    cpu_do_idle();
}

/* Kernel/sched/idle.c - Architecture-independent code */
void cpu_idle(void)
{
    /* Common idle loop code that works on all architectures */
    while (1) {
        while (!need_resched()) {
            /* Call architecture-specific idle function */
            arch_cpu_idle();
        }
        
        schedule_preempt_disabled();
    }
}
```

این نمونه کد نشان می‌دهد چگونه لینوکس یک واسط عمومی (`cpu_idle()`) تعریف می‌کند که توسط همه معماری‌ها استفاده می‌شود، در حالی که پیاده‌سازی خاص هر معماری (`arch_cpu_idle()`) در فایل‌های جداگانه قرار می‌گیرد.

### استانداردهای POSIX

لینوکس به طور گسترده از استانداردهای POSIX (Portable Operating System Interface) پیروی می‌کند. POSIX مجموعه‌ای از استانداردهای IEEE است که سازگاری بین سیستم‌عامل‌های مختلف را تعریف می‌کند.

**مزایای پیروی از POSIX:**

- **قابلیت حمل برنامه‌ها**: برنامه‌های نوشته شده برای یک سیستم‌عامل سازگار با POSIX می‌توانند به راحتی روی سایر سیستم‌عامل‌های سازگار با POSIX (مانند مک‌او‌اس، FreeBSD و غیره) کامپایل و اجرا شوند.
- **آشنایی برای توسعه‌دهندگان**: برنامه‌نویسانی که با سیستم‌های UNIX آشنا هستند، می‌توانند به راحتی برای لینوکس برنامه‌نویسی کنند.
- **استفاده از ابزارها و کتابخانه‌های استاندارد**: امکان استفاده از ابزارها و کتابخانه‌های توسعه یافته برای سیستم‌های سازگار با POSIX.

**برخی از بخش‌های استاندارد POSIX که لینوکس پیاده‌سازی می‌کند:**

- **POSIX.1**: فراخوانی‌های سیستمی پایه
- **POSIX.1b**: امکانات زمان واقعی
- **POSIX.1c**: نخ‌ها (Threads)
- **POSIX.2**: پوسته و ابزارهای خط فرمان

البته لازم به ذکر است که لینوکس به طور کامل با تمام جزئیات POSIX سازگار نیست و برخی از گسترش‌های خاص خود را نیز دارد. با این حال، سطح سازگاری با POSIX به قدری بالاست که اکثر برنامه‌های نوشته شده برای UNIX می‌توانند با حداقل تغییرات روی لینوکس کامپایل و اجرا شوند.

```c
/**
 * Example of POSIX-compliant system calls in Linux
 * Demonstrates standard POSIX APIs implemented in Linux
 */

/* POSIX-compliant file operations */
#include <fcntl.h>
#include <unistd.h>
#include <sys/stat.h>

int create_and_write_file(const char *path, const char *data, size_t size)
{
    /* POSIX-defined open() with standard flags */
    int fd = open(path, O_WRONLY | O_CREAT | O_TRUNC, 0644);
    if (fd == -1)
        return -1;
    
    /* POSIX-defined write() */
    ssize_t written = write(fd, data, size);
    
    /* POSIX-defined close() */
    close(fd);
    
    return (written == size) ? 0 : -1;
}

/* POSIX-compliant process management */
#include <sys/wait.h>

int execute_command(const char *command)
{
    pid_t pid;
    int status;
    
    /* POSIX-defined fork() */
    pid = fork();
    
    if (pid == -1)
        return -1;
    
    if (pid == 0) {
        /* Child process - POSIX-defined execl() */
        execl("/bin/sh", "sh", "-c", command, NULL);
        /* If execl returns, an error occurred */
        _exit(127);
    } else {
        /* Parent process - POSIX-defined waitpid() */
        if (waitpid(pid, &status, 0) == -1)
            return -1;
        
        return WEXITSTATUS(status);
    }
}
```

این نمونه کد نشان می‌دهد چگونه لینوکس APIهای استاندارد POSIX مانند `open()`, `write()`, `close()`, `fork()`, `execl()`, و `waitpid()` را پیاده‌سازی می‌کند که باعث می‌شود برنامه‌های نوشته شده برای لینوکس روی سایر سیستم‌های سازگار با POSIX نیز قابل اجرا باشند.

### پشتیبانی از سخت‌افزارهای متنوع

یکی از قدرت‌های بزرگ کرنل لینوکس، توانایی آن در پشتیبانی از طیف گسترده‌ای از سخت‌افزارها است. این ویژگی به لینوکس اجازه می‌دهد تا در انواع مختلف دستگاه‌ها، از گوشی‌های هوشمند گرفته تا اتومبیل‌ها، تلویزیون‌های هوشمند، روترها، سرورها و ابررایانه‌ها مورد استفاده قرار گیرد.

**عوامل کلیدی در پشتیبانی گسترده از سخت‌افزار:**

1. **مدل درایور باز**: هر کسی می‌تواند برای سخت‌افزار جدید، درایور لینوکس بنویسد.
2. **تعداد بالای توسعه‌دهندگان**: هزاران توسعه‌دهنده در سراسر جهان به نوشتن و بهبود درایورها کمک می‌کنند.
3. **همکاری شرکت‌ها**: بسیاری از شرکت‌های بزرگ سخت‌افزاری مانند Intel، AMD، NVIDIA، و غیره به طور مستقیم در توسعه درایورهای لینوکس مشارکت می‌کنند.
4. **سیستم ماژولار درایورها**: درایورهای جدید می‌توانند بدون نیاز به تغییر در هسته کرنل اضافه شوند.
5. **چارچوب‌های زیرساختی**: کرنل لینوکس چارچوب‌های متعددی برای انواع مختلف سخت‌افزار (مانند شبکه، گرافیک، صدا، و غیره) ارائه می‌دهد.

**انواع سخت‌افزارهای پشتیبانی شده:**

- **پردازنده‌ها**: از میکروکنترلرهای 8 بیتی تا پردازنده‌های قدرتمند سرور
- **سیستم‌های حافظه**: DDR, LPDDR, ECC, Non-Volatile Memory (NVM)
- **دستگاه‌های ذخیره‌سازی**: HDD, SSD, NVMe, eMMC, SD/MMC, USB storage
- **واسط‌های شبکه**: Ethernet, Wi-Fi, Bluetooth, 5G/4G/3G, ZigBee
- **کارت‌های گرافیک**: Intel, AMD, NVIDIA, ARM Mali
- **دستگاه‌های ورودی**: کیبورد، موس، صفحه لمسی، قلم، جویستیک
- **دستگاه‌های صوتی**: کارت‌های صدا، بلندگوها، میکروفون‌ها
- **دستگاه‌های USB**: انواع مختلف دستگاه‌های USB
- **سنسورها**: سنسورهای حرکتی، دما، فشار، و غیره
- **تجهیزات صنعتی**: PLC، سیستم‌های کنترل صنعتی

```c
/**
 * Example of hardware abstraction in the Linux kernel
 * Shows how Linux provides a unified interface for different hardware types
 */

/* Example of block device operations structure */
static const struct block_device_operations example_fops = {
    .owner          = THIS_MODULE,
    .open           = example_open,
    .release        = example_release,
    .ioctl          = example_ioctl,
    .getgeo         = example_getgeo,
};

/* Example of character device operations structure */
static const struct file_operations example_char_fops = {
    .owner          = THIS_MODULE,
    .read           = example_read,
    .write          = example_write,
    .unlocked_ioctl = example_ioctl,
    .open           = example_open,
    .release        = example_release,
};

/* Example of network device operations structure */
static const struct net_device_ops example_netdev_ops = {
    .ndo_open               = example_net_open,
    .ndo_stop               = example_net_close,
    .ndo_start_xmit         = example_net_xmit,
    .ndo_get_stats          = example_net_stats,
    .ndo_set_mac_address    = example_set_mac,
    .ndo_validate_addr      = eth_validate_addr,
};

/**
 * driver_probe - Generic probe function for a device driver
 * @dev: Device to probe
 *
 * This is called when a device that potentially matches this driver is found
 */
static int example_driver_probe(struct device *dev)
{
    /* Identify the exact device and check compatibility */
    
    /* Allocate driver resources */
    
    /* Initialize hardware */
    
    /* Register with the appropriate subsystem */
    
    return 0;
}
```

این نمونه کد نشان می‌دهد چگونه لینوکس از ساختارهای عملیات استاندارد برای انواع مختلف دستگاه‌ها (بلوکی، کاراکتری، شبکه) استفاده می‌کند تا یک واسط یکپارچه برای توسعه‌دهندگان درایور فراهم کند، در حالی که جزئیات پیاده‌سازی برای سخت‌افزارهای خاص را پنهان می‌کند.

### مقیاس‌پذیری

کرنل لینوکس برای مقیاس‌پذیری عالی در طیف گسترده‌ای از سخت‌افزارها طراحی شده است. این سیستم‌عامل می‌تواند از دستگاه‌های بسیار کوچک با منابع محدود تا سیستم‌های بسیار بزرگ با صدها هسته پردازنده و ترابایت‌ها حافظه به خوبی کار کند.

**جنبه‌های مقیاس‌پذیری کرنل لینوکس:**

1. **مقیاس‌پذیری عمودی (Vertical Scaling)**: توانایی استفاده مؤثر از سیستم‌های با منابع بیشتر (پردازنده‌ها، حافظه، و غیره)

2. **مقیاس‌پذیری افقی (Horizontal Scaling)**: توانایی کار در محیط‌های توزیع‌شده و خوشه‌ای

3. **مقیاس‌پذیری رو به پایین (Scaling Down)**: توانایی کار با منابع محدود در دستگاه‌های کوچک

**تکنیک‌های کرنل لینوکس برای مقیاس‌پذیری:**

- **زمانبندی پیشرفته پردازنده**: الگوریتم‌های زمانبندی که می‌توانند صدها یا هزاران هسته پردازنده را مدیریت کنند
- **آگاهی از NUMA**: بهینه‌سازی دسترسی به حافظه در سیستم‌های با معماری دسترسی حافظه غیریکنواخت
- **قفل‌های بدون انسداد**: استفاده از تکنیک‌های هم‌روندی مانند RCU (Read-Copy-Update) برای کاهش تضاد در سیستم‌های چندپردازنده‌ای
- **سیستم‌های فایل با قابلیت مقیاس‌پذیری بالا**: ext4, XFS, Btrfs که می‌توانند با حجم‌های بسیار بزرگ داده کار کنند
- **زیرسیستم شبکه مقیاس‌پذیر**: پشتیبانی از پهنای باند بالا و تعداد زیاد اتصالات همزمان
- **حافظه نهان هوشمند**: سیستم‌های کش پیشرفته برای بهبود کارایی در محدوده‌های مختلف منابع
- **پیکربندی‌پذیری**: امکان حذف ویژگی‌های غیرضروری از کرنل برای کاهش اندازه و مصرف منابع

```c
/**
 * Example of Linux scalability features
 * Shows RCU (Read-Copy-Update) mechanism for lockless reads
 */

/* Example of RCU usage for a scalable data structure */
struct data_item {
    int key;
    int value;
    struct list_head list;
    struct rcu_head rcu;
};

/* Reading data without locking (scales well with many readers) */
int find_item_value(struct list_head *head, int key)
{
    struct data_item *item;
    int value = -1;
    
    /* RCU read lock is very lightweight and scales to many CPUs */
    rcu_read_lock();
    
    /* Safe to read the list even if another CPU is modifying it */
    list_for_each_entry_rcu(item, head, list) {
        if (item->key == key) {
            value = item->value;
            break;
        }
    }
    
    rcu_read_unlock();
    return value;
}

/* Updating data (less frequent operation) */
void update_item(struct list_head *head, int key, int new_value)
{
    struct data_item *old_item, *new_item;
    
    /* Traditional lock for writers - but readers proceed without waiting */
    spin_lock(&write_lock);
    
    list_for_each_entry(old_item, head, list) {
        if (old_item->key == key) {
            /* Create new version of the item */
            new_item = kmalloc(sizeof(*new_item), GFP_KERNEL);
            new_item->key = key;
            new_item->value = new_value;
            
            /* Replace old item with new one */
            list_replace_rcu(&old_item->list, &new_item->list);
            
            /* Schedule the old item for cleanup after all readers are done */
            call_rcu(&old_item->rcu, free_old_item);
            break;
        }
    }
    
    spin_unlock(&write_lock);
}

/* Cleanup function called after grace period */
static void free_old_item(struct rcu_head *rcu)
{
    struct data_item *item = container_of(rcu, struct data_item, rcu);
    kfree(item);
}
```

این نمونه کد استفاده از مکانیزم RCU در لینوکس را نشان می‌دهد، که یکی از تکنیک‌های کلیدی برای بهبود مقیاس‌پذیری است. RCU به خوانندگان متعدد اجازه می‌دهد بدون نیاز به قفل‌گذاری سنگین، به طور همزمان به داده‌ها دسترسی داشته باشند، در حالی که نویسندگان می‌توانند تغییرات را بدون مسدود کردن خوانندگان اعمال کنند.

**نمونه‌های مقیاس‌پذیری لینوکس:**

- **ابررایانه‌ها**: لینوکس روی بیش از 90% ابررایانه‌های فهرست TOP500 جهان اجرا می‌شود، که نشان‌دهنده قابلیت مقیاس‌پذیری آن در سیستم‌های بسیار بزرگ است.

- **سرورهای بزرگ**: لینوکس می‌تواند روی سرورهایی با صدها هسته پردازنده و چندین ترابایت حافظه کار کند.

- **گوشی‌های هوشمند**: همان کرنل (با تنظیمات متفاوت) در اندروید برای دستگاه‌های با منابع محدودتر استفاده می‌شود.

- **دستگاه‌های IoT**: نسخه‌های سبک لینوکس در دستگاه‌های بسیار کوچک با حافظه و توان پردازشی محدود کار می‌کنند.

لینوکس با ارائه این سطح از مقیاس‌پذیری، انعطاف‌پذیری و کارایی، خود را به عنوان یک انتخاب ایده‌آل برای طیف گسترده‌ای از کاربردها تثبیت کرده است.

## خلاصه ویژگی‌های اصلی کرنل لینوکس

کرنل لینوکس با ترکیبی از ویژگی‌های اساسی که در این بخش بررسی کردیم، یک سیستم‌عامل استثنایی و همه‌منظوره ارائه می‌دهد. چند وظیفه‌ای پیشگیرانه، پشتیبانی از چند پردازنده، قابلیت حمل به معماری‌های متنوع، سازگاری با استانداردهای POSIX، پشتیبانی گسترده از سخت‌افزارها و مقیاس‌پذیری فوق‌العاده، همگی به لینوکس اجازه می‌دهند تا در مجموعه متنوعی از محیط‌ها از کوچک‌ترین میکروکنترلرها تا بزرگترین ابررایانه‌ها با موفقیت مورد استفاده قرار گیرد.

علاوه بر این ویژگی‌های فنی، مدل توسعه متن‌باز لینوکس نیز یک مزیت کلیدی است که به این سیستم‌عامل امکان می‌دهد به سرعت تکامل یابد، مشکلات امنیتی را برطرف کند و با فناوری‌های جدید سازگار شود. این ترکیب از ویژگی‌های فنی قدرتمند و مدل توسعه پویا، لینوکس را به یکی از موفق‌ترین پروژه‌های نرم‌افزاری در تاریخ تبدیل کرده است.

## بررسی کد کرنل لینوکس

کد منبع کرنل لینوکس یکی از بزرگترین و پیچیده‌ترین پروژه‌های نرم‌افزاری متن‌باز در جهان است. بررسی و تحلیل این کد می‌تواند بینش عمیقی در مورد طراحی سیستم‌عامل، تکنیک‌های برنامه‌نویسی سطح پایین و مدیریت پروژه‌های بزرگ نرم‌افزاری ارائه دهد. در این بخش، به بررسی جنبه‌های مختلف کد کرنل لینوکس می‌پردازیم.

### زبان برنامه‌نویسی C و اسمبلی در کرنل

کرنل لینوکس عمدتاً به زبان C نوشته شده است، با بخش‌های کوچکی از کد اسمبلی برای وظایف خاص وابسته به معماری. انتخاب زبان C برای توسعه کرنل دلایل متعددی دارد:

1. **کارایی بالا**: زبان C کارایی نزدیک به اسمبلی ارائه می‌دهد اما با خوانایی و قابلیت نگهداری بهتر.
2. **کنترل سطح پایین**: امکان دسترسی مستقیم به حافظه، دستکاری بیت‌ها و ارتباط نزدیک با سخت‌افزار.
3. **قابلیت حمل**: کد C می‌تواند با تغییرات اندک برای معماری‌های مختلف کامپایل شود.
4. **استاندارد و گسترده**: C یک زبان استاندارد با کامپایلرهای در دسترس برای تقریباً همه پلتفرم‌ها است.

کد اسمبلی در کرنل لینوکس معمولاً در موارد زیر استفاده می‌شود:

1. **کد راه‌اندازی**: کد اولیه که هنگام بوت سیستم اجرا می‌شود
2. **روتین‌های تعویض زمینه**: تغییر بین فرآیندها یا بین حالت کاربر و حالت کرنل
3. **دستورات خاص CPU**: دسترسی به دستورات ویژه پردازنده که از طریق C امکان‌پذیر نیست
4. **روتین‌های بحرانی از نظر زمانی**: کدهایی که نیاز به بهینه‌سازی در سطح دستورالعمل دارند

مثالی از کد اسمبلی در کرنل لینوکس برای معماری x86:

```asm
/*
 * کد اسمبلی برای تعویض زمینه (context switch) در معماری x86-64
 * arch/x86/kernel/entry_64.S
 */
ENTRY(switch_to)
    /* ذخیره وضعیت پردازنده فعلی */
    pushq   %rbp
    pushq   %rbx
    pushq   %r12
    pushq   %r13
    pushq   %r14
    pushq   %r15
    
    /* ذخیره اشاره‌گر پشته */
    movq    %rsp, TASK_threadsp(%rdi)
    
    /* بارگذاری وضعیت پردازنده جدید */
    movq    TASK_threadsp(%rsi), %rsp
    
    popq    %r15
    popq    %r14
    popq    %r13
    popq    %r12
    popq    %rbx
    popq    %rbp
    
    ret
END(switch_to)
```

و یک مثال از کد C معمول در کرنل:

```c
/**
 * مثالی از کد C در کرنل لینوکس - تابع ساده مدیریت حافظه
 * mm/page_alloc.c
 */
struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)
{
    struct page *page;
    
    /* درخواست یک صفحه با ترتیب مشخص */
    page = alloc_pages_current(gfp_mask, order);
    
    /* بررسی موفقیت تخصیص */
    if (unlikely(!page))
        return NULL;
    
    /* پاک کردن صفحه در صورت نیاز */
    if (unlikely(gfp_mask & __GFP_ZERO))
        clear_highpage(page);
    
    return page;
}
```

نکته مهم در مورد کد C کرنل لینوکس این است که از تمام ویژگی‌های استاندارد C استفاده نمی‌کند. برخی محدودیت‌ها عبارتند از:

1. عدم استفاده از کتابخانه استاندارد C (libc)
2. عدم استفاده از حافظه پویا استاندارد (malloc/free)
3. حساسیت بالا به سرریز بافر و خطاهای مشابه
4. استفاده از توابع و ماکروهای خاص کرنل به جای توابع استاندارد

### ساختار درختی کد منبع

کد منبع کرنل لینوکس به صورت منطقی در یک ساختار درختی با دایرکتوری‌های متعدد سازماندهی شده است. این سازماندهی به مدیریت بهتر کد و تفکیک وظایف کمک می‌کند. ساختار اصلی به شرح زیر است:

```
/
├── arch/          # کد وابسته به معماری (x86, arm, powerpc و غیره)
├── block/         # زیرسیستم بلوکی برای دسترسی به دستگاه‌های ذخیره‌سازی
├── certs/         # گواهی‌ها برای امضای ماژول‌ها و امنیت
├── crypto/        # الگوریتم‌های رمزنگاری
├── Documentation/ # مستندات
├── drivers/       # درایورهای دستگاه (بزرگترین بخش کرنل)
├── fs/            # سیستم‌های فایل
├── include/       # فایل‌های هدر
├── init/          # کد راه‌اندازی کرنل
├── ipc/           # مکانیزم‌های ارتباط بین فرآیندی
├── kernel/        # هسته اصلی کرنل (زمانبندی، فرآیندها و غیره)
├── lib/           # کتابخانه‌های عمومی و توابع کمکی
├── mm/            # زیرسیستم مدیریت حافظه
├── net/           # زیرسیستم شبکه
├── samples/       # نمونه کدها
├── scripts/       # اسکریپت‌های ساخت و تحلیل
├── security/      # چارچوب‌های امنیتی (SELinux, AppArmor و غیره)
├── sound/         # پشتیبانی از صدا (ALSA)
├── tools/         # ابزارهای مختلف
└── virt/          # مجازی‌سازی
```

برخی از مهم‌ترین دایرکتوری‌ها را بررسی می‌کنیم:

**arch/**: این دایرکتوری شامل کد خاص معماری‌های مختلف است. هر معماری دایرکتوری خود را دارد، مانند `arch/x86/` برای پردازنده‌های Intel و AMD و `arch/arm/` برای پردازنده‌های ARM. این بخش شامل کد راه‌اندازی، تعریف وقفه‌ها، مدیریت حافظه خاص معماری و تنظیمات سخت‌افزاری است.

**kernel/**: این دایرکتوری شامل کد اصلی کرنل است که مستقل از معماری است. اینجا جایی است که زمانبند، مدیریت فرآیندها، سیگنال‌ها، مدیریت زمان و سایر عملکردهای اساسی کرنل پیاده‌سازی می‌شوند.

**mm/**: این دایرکتوری شامل زیرسیستم مدیریت حافظه است. این شامل مدیریت صفحات، حافظه مجازی، تخصیص حافظه، صفحه گردانی و سایر جنبه‌های مدیریت حافظه می‌شود.

**fs/**: این دایرکتوری شامل پیاده‌سازی سیستم‌های فایل مختلف (ext4, XFS, Btrfs و غیره) و سیستم فایل مجازی (VFS) است که یک لایه انتزاعی برای همه سیستم‌های فایل فراهم می‌کند.

**drivers/**: این بزرگترین بخش کرنل است و شامل درایورها برای انواع مختلف سخت‌افزارها مانند کارت‌های گرافیک، کارت‌های شبکه، کنترلرهای USB، و غیره است. این بخش به زیرشاخه‌های متعددی تقسیم می‌شود، هر کدام مربوط به نوع خاصی از دستگاه.

**net/**: این دایرکتوری شامل پیاده‌سازی پروتکل‌های شبکه مانند TCP/IP، سوکت‌ها، فیلترینگ بسته و سایر جنبه‌های شبکه است.

**include/**: این دایرکتوری شامل فایل‌های هدر مورد نیاز برای کامپایل کرنل است. زیرشاخه‌های مهم آن عبارتند از:
- `include/linux/`: هدرهای عمومی کرنل
- `include/asm-generic/`: هدرهای مشترک برای تمام معماری‌ها
- `include/uapi/`: واسط کاربر-کرنل برای فراخوانی‌های سیستمی

### استانداردهای کدنویسی

کرنل لینوکس یک سند استاندارد کدنویسی با عنوان "Linux kernel coding style" دارد که در `Documentation/process/coding-style.rst` یافت می‌شود. این استانداردها اطمینان می‌دهند که کد توسط همه توسعه‌دهندگان بتواند به راحتی خوانده و درک شود.

برخی از قوانین کلیدی عبارتند از:

1. **عرض تب**: از تب 8 کاراکتری استفاده می‌شود، نه فاصله.

2. **بلاک‌ها**: آکولادها به سبک K&R قرار می‌گیرند، یعنی آکولاد باز در همان خط دستور و آکولاد بسته در یک خط جدید:

```c
if (condition) {
    /* کد */
} else {
    /* کد بیشتر */
}
```

3. **حداکثر طول خط**: خطوط نباید بیش از 80 کاراکتر باشند (با استثناهای خاص).

4. **نامگذاری**: توابع و متغیرها با حروف کوچک نامگذاری می‌شوند، با زیرخط به عنوان جداکننده. ماکروها و enum ها با حروف بزرگ نوشته می‌شوند:

```c
int kernel_function_name(int parameter_name);
#define KERNEL_MACRO_NAME 1
```

5. **توضیحات**: توضیحات به سبک C `/* */` ترجیح داده می‌شوند، هرچند توضیحات خطی `//` نیز مجاز هستند.

6. **تورفتگی شرطی‌ها**: شرطی‌های متداخل با 8 کاراکتر تورفتگی می‌گیرند:

```c
if (condition1) {
    if (condition2) {
        /* کد */
    }
}
```

7. **فضای خالی**: استفاده از فضای خالی برای افزایش خوانایی، مثلاً بعد از کلمات کلیدی و قبل و بعد از عملگرها.

8. **مستندات کد**: استفاده از سیستم kernel-doc برای توضیح توابع، ساختارها و ماکروها.

مثالی از یک تابع با سبک استاندارد کرنل لینوکس:

```c
/**
 * get_device_by_id - پیدا کردن یک دستگاه با شناسه مشخص
 * @id: شناسه دستگاه برای جستجو
 *
 * این تابع جستجوی یک دستگاه با شناسه مشخص را انجام می‌دهد.
 * در صورت موفقیت، یک اشاره‌گر به ساختار دستگاه یا NULL در صورت عدم وجود
 * دستگاه برمی‌گرداند.
 *
 * بازگشت: اشاره‌گر به دستگاه یا NULL در صورت عدم وجود
 */
static struct device *get_device_by_id(unsigned int id)
{
    struct device *dev;
    unsigned long flags;
    
    if (unlikely(id == 0))
        return NULL;
    
    spin_lock_irqsave(&device_lock, flags);
    
    list_for_each_entry(dev, &device_list, list) {
        if (dev->id == id) {
            /* دستگاه یافت شد */
            get_device(dev);
            spin_unlock_irqrestore(&device_lock, flags);
            return dev;
        }
    }
    
    spin_unlock_irqrestore(&device_lock, flags);
    return NULL;
}
```

### تحلیل بخش‌های کلیدی کد کرنل

در این بخش، به بررسی برخی از بخش‌های کلیدی کد کرنل لینوکس می‌پردازیم تا درک بهتری از نحوه پیاده‌سازی عملکردهای مهم پیدا کنیم.

#### 1. فراخوانی سیستمی (System Call)

فراخوانی‌های سیستمی واسط بین فضای کاربر و کرنل هستند. بیایید ببینیم چگونه یک فراخوانی سیستمی در کرنل لینوکس تعریف می‌شود:

```c
/*
 * فراخوانی سیستمی write() - نوشتن داده به یک فایل
 * kernel/sys.c
 */
SYSCALL_DEFINE3(write, unsigned int, fd, const char __user *, buf, size_t, count)
{
    struct fd f = fdget_pos(fd);
    ssize_t ret = -EBADF;

    if (f.file) {
        loff_t pos, *ppos = file_ppos(f.file);
        if (ppos) {
            pos = *ppos;
            ppos = &pos;
        }
        ret = vfs_write(f.file, buf, count, ppos);
        if (ret >= 0 && ppos)
            f.file->f_pos = pos;
        fdput_pos(f);
    }

    return ret;
}
```

در این مثال:
- `SYSCALL_DEFINE3` یک ماکرو است که یک فراخوانی سیستمی با 3 پارامتر تعریف می‌کند.
- `__user` یک صفات‌گذار است که نشان می‌دهد اشاره‌گر از فضای کاربر آمده است و باید با دقت بررسی شود.
- تابع ابتدا فایل را با استفاده از توصیف‌گر فایل پیدا می‌کند، سپس عملیات نوشتن را انجام می‌دهد و در نهایت نتیجه را برمی‌گرداند.

#### 2. زمانبندی فرآیندها

زمانبند کرنل لینوکس یکی از پیچیده‌ترین بخش‌های آن است. بخشی از کد زمانبند CFS (Completely Fair Scheduler) را بررسی می‌کنیم:

```c
/*
 * زمانبند CFS - انتخاب بعدی فرآیند برای اجرا
 * kernel/sched/fair.c
 */
static struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev)
{
    struct cfs_rq *cfs_rq = &rq->cfs;
    struct sched_entity *se;
    
    if (!cfs_rq->nr_running)
        return NULL;
    
    /* انتخاب فرآیند با بیشترین اولویت */
    se = pick_next_entity(cfs_rq, NULL);
    
    /* تبدیل entity به task_struct */
    set_next_entity(cfs_rq, se);
    
    return task_of(se);
}

static struct sched_entity *pick_next_entity(struct cfs_rq *cfs_rq, struct sched_entity *curr)
{
    struct sched_entity *left = rb_entry(cfs_rq->rb_leftmost, struct sched_entity, run_node);
    
    /* همیشه چپ‌ترین نود در درخت را انتخاب کن (کمترین vruntime) */
    if (!curr)
        return left;
    
    /* مقایسه فرآیند فعلی با چپ‌ترین نود */
    if (entity_before(left, curr))
        return left;
    
    return curr;
}
```

در این نمونه:
- زمانبند CFS از یک درخت سرخ-سیاه برای نگهداری فرآیندهای قابل اجرا استفاده می‌کند.
- فرآیندها بر اساس "زمان اجرای مجازی" (`vruntime`) مرتب می‌شوند.
- `pick_next_task_fair` فرآیند با کمترین `vruntime` را انتخاب می‌کند (چپ‌ترین نود در درخت).

#### 3. مدیریت حافظه

یکی از عملکردهای اصلی کرنل، تخصیص و مدیریت حافظه است. یک مثال از تخصیص صفحه حافظه:

```c
/*
 * تخصیص یک صفحه حافظه
 * mm/page_alloc.c
 */
struct page *__alloc_pages_nodemask(gfp_t gfp_mask, unsigned int order,
                int preferred_nid, nodemask_t *nodemask)
{
    struct page *page;
    unsigned int cpu;
    struct alloc_context ac = {};
    
    /* تنظیم پارامترهای تخصیص */
    gfp_mask &= gfp_allowed_mask;
    ac.high_zoneidx = gfp_zone(gfp_mask);
    ac.zonelist = node_zonelist(preferred_nid, gfp_mask);
    ac.nodemask = nodemask;
    ac.migratetype = gfpflags_to_migratetype(gfp_mask);
    
    if (unlikely(!zonelist_zone_count(ac.zonelist))) {
        warn_alloc(gfp_mask, nodemask, "no zones available");
        return NULL;
    }
    
    /* آیا می‌توانیم از کش CPU استفاده کنیم؟ */
    if (!(gfp_mask & __GFP_THISNODE) && !ac.nodemask) {
        cpu = get_cpu();
        if (cpu_has_pgoff(cpu) && order == 0)
            page = cpu_pgoff_alloc(gfp_mask, &ac);
        put_cpu();
        if (page)
            return page;
    }
    
    /* مسیر اصلی تخصیص */
    page = get_page_from_freelist(gfp_mask, order, &ac);
    if (likely(page))
        return page;
    
    /* مسیر آهسته (کمبود حافظه) */
    return __alloc_pages_slowpath(gfp_mask, order, &ac);
}
```

در این نمونه:
- تابع `__alloc_pages_nodemask` برای تخصیص یک یا چند صفحه حافظه متوالی استفاده می‌شود.
- پارامتر `order` تعداد صفحات متوالی را مشخص می‌کند (2^order صفحه).
- ابتدا سعی می‌کند از کش CPU استفاده کند، سپس از لیست صفحات آزاد، و در نهایت اگر حافظه کافی نباشد، به مسیر آهسته می‌رود که شامل آزادسازی حافظه کش، صفحه گردانی و غیره است.

#### 4. سیستم فایل مجازی (VFS)

سیستم فایل مجازی یک لایه انتزاعی است که تمام سیستم‌های فایل را یکپارچه می‌کند. مثالی از عملیات خواندن فایل:

```c
/*
 * خواندن از یک فایل
 * fs/read_write.c
 */
ssize_t vfs_read(struct file *file, char __user *buf, size_t count, loff_t *pos)
{
    ssize_t ret;
    
    if (!(file->f_mode & FMODE_READ))
        return -EBADF;
    if (unlikely(!file->f_op->read && !file->f_op->read_iter))
        return -EINVAL;
    
    /* آیا محدودیت اندازه وجود دارد؟ */
    if (unlikely(count > MAX_RW_COUNT))
        count = MAX_RW_COUNT;
    
    /* بررسی مجوزها */
    if (unlikely(!access_ok(buf, count)))
        return -EFAULT;
    
    /* استفاده از رابط مدرن در صورت وجود */
    if (file->f_op->read_iter) {
        struct kiocb kiocb;
        struct iov_iter iter;
        
        init_sync_kiocb(&kiocb, file);
        kiocb.ki_pos = *pos;
        iov_iter_init(&iter, READ, &buf, count, count);
        
        ret = file->f_op->read_iter(&kiocb, &iter);
        *pos = kiocb.ki_pos;
    } else {
        /* استفاده از رابط قدیمی */
        ret = file->f_op->read(file, buf, count, pos);
    }
    
    return ret;
}
```

در این نمونه:
- `vfs_read` یک تابع عمومی برای خواندن از هر نوع فایل است، صرف نظر از سیستم فایل زیربنایی.
- ابتدا بررسی‌های امنیتی انجام می‌شود (مجوزها، محدودیت‌های اندازه، و غیره).
- سپس فراخوانی به تابع خواندن خاص سیستم فایل (`read_iter` یا `read`) منتقل می‌شود.
- این الگوی انتزاع اجازه می‌دهد کرنل با انواع مختلف سیستم‌های فایل به طور یکسان کار کند.

### بررسی نمونه کدهای کرنل

در این بخش، به بررسی چند نمونه کد بیشتر از کرنل لینوکس می‌پردازیم تا تکنیک‌های برنامه‌نویسی استفاده شده در آن را بهتر درک کنیم.

#### 1. مدیریت وقفه‌ها

وقفه‌ها یکی از مکانیزم‌های اساسی برای تعامل با سخت‌افزار هستند. بیایید ببینیم چگونه یک درایور، یک وقفه را ثبت می‌کند:

```c
/**
 * ثبت یک وقفه در کرنل لینوکس
 * drivers/example/example_driver.c
 */
static int example_probe(struct pci_dev *pdev, const struct pci_device_id *id)
{
    struct example_device *dev;
    int ret, irq;
    
    /* تخصیص و مقداردهی اولیه ساختار دستگاه */
    dev = kzalloc(sizeof(*dev), GFP_KERNEL);
    if (!dev)
        return -ENOMEM;
    
    /* فعال‌سازی دستگاه PCI */
    ret = pci_enable_device(pdev);
    if (ret) {
        dev_err(&pdev->dev, "Failed to enable PCI device\n");
        goto err_free_dev;
    }
    
    /* درخواست منابع I/O */
    ret = pci_request_regions(pdev, DRIVER_NAME);
    if (ret) {
        dev_err(&pdev->dev, "Failed to request regions\n");
        goto err_disable_device;
    }
    
    /* نگاشت فضای آدرس دستگاه */
    dev->regs = pci_iomap(pdev, 0, 0);
    if (!dev->regs) {
        dev_err(&pdev->dev, "Failed to map registers\n");
        ret = -ENOMEM;
        goto err_release_regions;
    }
    
    /* دریافت شماره وقفه */
    irq = pdev->irq;
    if (irq < 0) {
        dev_err(&pdev->dev, "No IRQ assigned\n");
        ret = -ENODEV;
        goto err_unmap;
    }
    
    /* ثبت روتین وقفه */
    ret = request_irq(irq, example_interrupt, IRQF_SHARED,
                     DRIVER_NAME, dev);
    if (ret) {
        dev_err(&pdev->dev, "Failed to request IRQ %d\n", irq);
        goto err_unmap;
    }
    
    /* ذخیره اطلاعات دستگاه */
    pci_set_drvdata(pdev, dev);
    dev->pdev = pdev;
    dev->irq = irq;
    
    /* فعال‌سازی وقفه‌ها در دستگاه */
    writel(INTR_ENABLE_ALL, dev->regs + REG_INTR_ENABLE);
    
    return 0;
    
err_unmap:
    pci_iounmap(pdev, dev->regs);
err_release_regions:
    pci_release_regions(pdev);
err_disable_device:
    pci_disable_device(pdev);
err_free_dev:
    kfree(dev);
    return ret;
}

/* روتین مدیریت وقفه */
static irqreturn_t example_interrupt(int irq, void *dev_id)
{
    struct example_device *dev = dev_id;
    u32 status;
    
    /* خواندن وضعیت وقفه */
    status = readl(dev->regs + REG_INTR_STATUS);
    
    /* اگر وقفه مربوط به این دستگاه نیست */
    if (!status)
        return IRQ_NONE;
    
    /* مدیریت وقفه‌های مختلف */
    if (status & INTR_DATA_READY)
        example_process_data(dev);
    
    if (status & INTR_ERROR)
        example_handle_error(dev);
    
    /* پاک کردن وقفه */
    writel(status, dev->regs + REG_INTR_CLEAR);
    
    return IRQ_HANDLED;
}

## مدیریت حافظه در کرنل لینوکس

مدیریت حافظه یکی از مهم‌ترین و پیچیده‌ترین وظایف هر سیستم‌عامل است. کرنل لینوکس سیستم مدیریت حافظه قدرتمندی دارد که به آن امکان می‌دهد منابع سخت‌افزاری را به طور کارآمد مدیریت کند و میان برنامه‌های مختلف تقسیم نماید. در این بخش، جنبه‌های مختلف مدیریت حافظه در کرنل لینوکس را بررسی می‌کنیم.

### حافظه فیزیکی و حافظه مجازی

سیستم مدیریت حافظه لینوکس بر پایه دو مفهوم اساسی حافظه فیزیکی و حافظه مجازی بنا شده است:

**حافظه فیزیکی (Physical Memory):**
حافظه فیزیکی به RAM واقعی موجود در سیستم اشاره دارد. این حافظه محدود است و باید به دقت میان فرآیندهای مختلف تقسیم شود. لینوکس حافظه فیزیکی را به صفحات (pages) تقسیم می‌کند که معمولاً اندازه هر صفحه 4 کیلوبایت است (هرچند در برخی معماری‌ها می‌تواند متفاوت باشد، مثلاً 8 کیلوبایت، 16 کیلوبایت یا حتی 2 مگابایت در برخی سیستم‌ها).

**حافظه مجازی (Virtual Memory):**
حافظه مجازی یک انتزاع است که به هر فرآیند اجازه می‌دهد فضای آدرس خود را داشته باشد، به گونه‌ای که گویی کل حافظه سیستم را در اختیار دارد. این سیستم چندین مزیت دارد:

1. **جداسازی**: هر فرآیند نمی‌تواند به حافظه فرآیندهای دیگر دسترسی پیدا کند
2. **حفاظت**: کرنل می‌تواند دسترسی به مناطق مختلف حافظه را کنترل کند
3. **فضای آدرس بزرگتر**: فرآیندها می‌توانند فضای آدرسی بزرگتر از حافظه فیزیکی موجود داشته باشند
4. **حافظه اشتراکی**: امکان اشتراک‌گذاری مناطق حافظه میان فرآیندها فراهم می‌شود

کرنل لینوکس از واحد مدیریت حافظه (MMU) سخت‌افزاری برای ترجمه آدرس‌های مجازی به فیزیکی استفاده می‌کند. هر فرآیند جدول صفحات (page table) خود را دارد که نگاشت بین آدرس‌های مجازی و فیزیکی را نگهداری می‌کند.

```c
/**
 * Example of page allocation in Linux kernel
 * mm/page_alloc.c
 */
struct page *alloc_pages(gfp_t gfp_mask, unsigned int order)
{
    struct page *page;
    
    /* Try to allocate pages from the current node */
    page = alloc_pages_current(gfp_mask, order);
    
    /* Check if allocation was successful */
    if (unlikely(!page))
        return NULL;
    
    /* If zero flag is set, clear the pages */
    if (unlikely(gfp_mask & __GFP_ZERO))
        clear_highpage(page);
    
    return page;
}
```

### صفحه‌بندی و جدول صفحات

صفحه‌بندی (Paging) مکانیزم اصلی مدیریت حافظه مجازی در لینوکس است. در این سیستم، فضای آدرس مجازی و فیزیکی به صفحات با اندازه ثابت تقسیم می‌شوند. جدول صفحات، نگاشت بین صفحات مجازی و فیزیکی را نگهداری می‌کند.

در معماری‌های مدرن، جدول صفحات چند سطحی است تا بتواند فضای آدرس بزرگ را به طور کارآمد مدیریت کند. برای مثال، در معماری x86-64، لینوکس از ساختار 4 سطحی استفاده می‌کند:

1. **PGD (Page Global Directory)**
2. **PUD (Page Upper Directory)**
3. **PMD (Page Middle Directory)**
4. **PTE (Page Table Entry)**

هر سطح از جدول، بخشی از آدرس مجازی را برای مسیریابی به سطح بعدی استفاده می‌کند. در نهایت، PTE به صفحه فیزیکی واقعی اشاره می‌کند.

```c
/**
 * Function to translate a virtual address to physical
 * (simplified version)
 */
unsigned long translate_address(unsigned long vaddr, pgd_t *pgd)
{
    pgd_t *pgd_entry;
    pud_t *pud_entry;
    pmd_t *pmd_entry;
    pte_t *pte_entry;
    unsigned long paddr;
    
    /* Get the PGD entry */
    pgd_entry = pgd + pgd_index(vaddr);
    if (pgd_none(*pgd_entry))
        return -EFAULT;
    
    /* Get the PUD entry */
    pud_entry = pud_offset(pgd_entry, vaddr);
    if (pud_none(*pud_entry))
        return -EFAULT;
    
    /* Get the PMD entry */
    pmd_entry = pmd_offset(pud_entry, vaddr);
    if (pmd_none(*pmd_entry))
        return -EFAULT;
    
    /* Get the PTE entry */
    pte_entry = pte_offset_kernel(pmd_entry, vaddr);
    if (!pte_present(*pte_entry))
        return -EFAULT;
    
    /* Compute the physical address */
    paddr = (pte_val(*pte_entry) & PAGE_MASK) | (vaddr & ~PAGE_MASK);
    
    return paddr;
}
```

### فضای آدرس پروسه

هر فرآیند در لینوکس فضای آدرس مجازی خود را دارد که از طریق ساختار `mm_struct` مدیریت می‌شود. این ساختار شامل اطلاعاتی درباره تمام مناطق حافظه متعلق به فرآیند است، از جمله:

- کد اجرایی (text segment)
- داده‌های تغییرناپذیر (read-only data)
- داده‌های تغییرپذیر (data segment)
- پشته (stack)
- فضای آزاد (heap)
- کتابخانه‌های به اشتراک گذاشته شده
- مناطق نگاشت شده با `mmap()`

هر منطقه حافظه توسط یک ساختار `vm_area_struct` توصیف می‌شود که اطلاعاتی مانند آدرس شروع و پایان، مجوزهای دسترسی و پرچم‌های دیگر را نگهداری می‌کند.

```c
/**
 * Creating a new memory mapping for a process
 * mm/mmap.c
 */
unsigned long do_mmap(struct file *file, unsigned long addr,
                     unsigned long len, unsigned long prot,
                     unsigned long flags, unsigned long pgoff)
{
    struct mm_struct *mm = current->mm;
    struct vm_area_struct *vma;
    unsigned long ret;
    
    /* Various checks and validations */
    if (len > TASK_SIZE)
        return -ENOMEM;
    
    /* Round the address and length to page boundaries */
    addr = PAGE_ALIGN(addr);
    len = PAGE_ALIGN(len);
    
    /* Find a suitable region in the address space */
    addr = get_unmapped_area(file, addr, len, pgoff, flags);
    if (IS_ERR_VALUE(addr))
        return addr;
    
    /* Create a new VMA */
    vma = vm_area_alloc(mm);
    if (!vma)
        return -ENOMEM;
    
    /* Set up the VMA */
    vma->vm_start = addr;
    vma->vm_end = addr + len;
    vma->vm_flags = calc_vm_prot_bits(prot) | calc_vm_flag_bits(flags);
    vma->vm_page_prot = vm_get_page_prot(vma->vm_flags);
    vma->vm_pgoff = pgoff;
    
    /* Link the VMA to the file if needed */
    if (file) {
        vma->vm_file = get_file(file);
        if (flags & MAP_SHARED)
            vma->vm_flags |= VM_SHARED;
    }
    
    /* Insert the VMA into the process's memory regions */
    ret = insert_vm_struct(mm, vma);
    if (ret)
        return ret;
    
    /* Update the process's memory usage statistics */
    mm->total_vm += len >> PAGE_SHIFT;
    
    return addr;
}
```

### مدیریت حافظه نهان

حافظه نهان (Cache) در سیستم‌های کامپیوتری برای افزایش کارایی استفاده می‌شود. کرنل لینوکس چندین مکانیزم کش برای بهینه‌سازی دسترسی به حافظه دارد:

1. **Slab Allocator**: یک لایه روی تخصیص صفحه که امکان تخصیص و آزادسازی کارآمد اشیاء کرنل با اندازه‌های متعارف را فراهم می‌کند.

2. **Buffer Cache**: بافرهایی که داده‌های دستگاه‌های بلوکی را نگهداری می‌کنند تا دسترسی به آنها سریع‌تر شود.

3. **Page Cache**: صفحاتی از فایل‌ها که در حافظه نگهداری می‌شوند تا دسترسی سریع‌تر به داده‌های فایل امکان‌پذیر شود.

4. **dentry Cache**: کش مربوط به مدخل‌های دایرکتوری که باعث بهبود کارایی عملیات سیستم فایل می‌شود.

5. **TLB (Translation Lookaside Buffer)**: یک کش سخت‌افزاری که نگاشت‌های آدرس مجازی به فیزیکی را ذخیره می‌کند تا سرعت ترجمه آدرس افزایش یابد.

```c
/**
 * Example of slab allocator usage
 * mm/slab.c (simplified)
 */
void *kmem_cache_alloc(struct kmem_cache *cachep, gfp_t flags)
{
    void *objp;
    
    /* Get an object from the cache */
    objp = slab_alloc(cachep, flags, _RET_IP_);
    
    /* If needed, run the constructor on the object */
    if (likely(objp) && unlikely(cachep->ctor))
        cachep->ctor(objp);
    
    return objp;
}

void kmem_cache_free(struct kmem_cache *cachep, void *objp)
{
    /* Free an object back to the cache */
    slab_free(cachep, objp, _RET_IP_);
}
```

### تخصیص و آزادسازی حافظه

تخصیص حافظه در کرنل لینوکس به چند دسته تقسیم می‌شود:

1. **تخصیص صفحه**: برای تخصیص یک یا چند صفحه متوالی استفاده می‌شود (توابع `alloc_pages` و `__get_free_pages`).

2. **تخصیص عمومی**: برای تخصیص حافظه به اندازه دلخواه (توابع `kmalloc` و `kfree`).

3. **تخصیص اشیاء**: برای تخصیص اشیاء با اندازه ثابت (توابع `kmem_cache_alloc` و `kmem_cache_free`).

4. **تخصیص حافظه پیوسته**: برای تخصیص حافظه فیزیکی پیوسته که برای برخی دستگاه‌ها لازم است (تابع `dma_alloc_coherent`).

کرنل لینوکس از پرچم‌های `GFP` (Get Free Page) برای کنترل رفتار تخصیص حافظه استفاده می‌کند. مثال‌هایی از این پرچم‌ها عبارتند از:

- `GFP_KERNEL`: تخصیص حافظه معمولی (ممکن است بخوابد)
- `GFP_ATOMIC`: تخصیص حافظه در بافت‌های اتمیک مانند وقفه‌ها (نمی‌تواند بخوابد)
- `GFP_USER`: تخصیص حافظه برای فضای کاربر
- `GFP_DMA`: تخصیص حافظه مناسب برای DMA
- `__GFP_ZERO`: پر کردن حافظه تخصیص یافته با صفر

```c
/**
 * Example of different memory allocation techniques
 */
void memory_allocation_examples(void)
{
    struct page *pages;
    void *ptr1, *ptr2, *ptr3;
    struct kmem_cache *cache;
    struct my_struct *obj;
    
    /* Page allocation - get 2^3 = 8 consecutive pages */
    pages = alloc_pages(GFP_KERNEL, 3);
    if (pages)
        __free_pages(pages, 3);
    
    /* General purpose allocation */
    ptr1 = kmalloc(1024, GFP_KERNEL);
    if (ptr1)
        kfree(ptr1);
    
    /* Zero-initialized memory */
    ptr2 = kzalloc(1024, GFP_KERNEL);
    if (ptr2)
        kfree(ptr2);
    
    /* Virtually contiguous but maybe physically non-contiguous */
    ptr3 = vmalloc(1024 * 1024);
    if (ptr3)
        vfree(ptr3);
    
    /* Object allocation with slab allocator */
    cache = kmem_cache_create("my_cache", sizeof(struct my_struct),
                             0, 0, NULL);
    if (cache) {
        obj = kmem_cache_alloc(cache, GFP_KERNEL);
        if (obj)
            kmem_cache_free(cache, obj);
        kmem_cache_destroy(cache);
    }
}
```

### صفحه گردانی

صفحه گردانی (Paging) یکی از مکانیزم‌های مهم مدیریت حافظه مجازی است. هنگامی که حافظه فیزیکی پر می‌شود، کرنل برخی صفحات کمتر استفاده شده را به دیسک منتقل می‌کند تا فضا برای صفحات جدید آزاد شود. این فرآیند "صفحه گردانی" (swapping یا paging) نامیده می‌شود.

لینوکس از الگوریتم‌های پیچیده‌ای برای انتخاب صفحات برای تعویض استفاده می‌کند. این الگوریتم‌ها سعی می‌کنند صفحاتی را انتخاب کنند که در آینده نزدیک احتمال استفاده از آنها کمتر است. صفحات دستکاری شده (dirty pages) باید قبل از تعویض به دیسک نوشته شوند، در حالی که صفحات بدون تغییر می‌توانند مستقیماً آزاد شوند.

```c
/**
 * Example of page reclaim code (simplified)
 * mm/vmscan.c
 */
static unsigned long shrink_page_list(struct list_head *page_list,
                                     struct pglist_data *pgdat,
                                     struct scan_control *sc)
{
    LIST_HEAD(ret_pages);
    LIST_HEAD(free_pages);
    unsigned nr_reclaimed = 0;
    
    while (!list_empty(page_list)) {
        struct page *page;
        
        /* Get a page from the list */
        page = lru_to_page(page_list);
        list_del(&page->lru);
        
        /* Try to lock the page */
        if (!trylock_page(page))
            continue;
        
        /* Skip if page is already being reclaimed */
        if (PageWriteback(page))
            continue;
        
        /* Check if page can be reclaimed */
        if (page_referenced(page, 0, sc->target_mem_cgroup, &sc->vm_flags))
            continue;
        
        /* If page is dirty, start writeback */
        if (PageDirty(page)) {
            start_writeback(page);
            continue;
        }
        
        /* Page is clean, can be reclaimed */
        del_page_from_lru_list(page, lruvec, page_lru(page));
        list_add(&page->lru, &free_pages);
        nr_reclaimed++;
    }
    
    /* Free the reclaimed pages */
    nr_reclaimed += free_hot_cold_page_list(&free_pages, true);
    
    return nr_reclaimed;
}
```

### زباله‌روبی و جمع‌آوری حافظه

برخلاف زبان‌های برنامه‌نویسی سطح بالا، کرنل لینوکس به صورت مستقیم از جمع‌آوری زباله (garbage collection) خودکار پشتیبانی نمی‌کند. مدیریت حافظه به صورت دستی انجام می‌شود و توسعه‌دهندگان کرنل باید حافظه را به درستی تخصیص و آزاد کنند.

با این حال، لینوکس از چندین مکانیزم برای کمک به مدیریت حافظه استفاده می‌کند:

1. **شمارش ارجاع**: بسیاری از ساختارهای داده کرنل از شمارنده ارجاع استفاده می‌کنند. هر زمان که یک اشاره جدید به شیء ایجاد می‌شود، شمارنده افزایش می‌یابد و هر زمان که یک اشاره حذف می‌شود، شمارنده کاهش می‌یابد. وقتی شمارنده به صفر برسد، شیء آزاد می‌شود.

2. **RCU (Read-Copy-Update)**: یک مکانیزم هم‌روندی که به خوانندگان اجازه می‌دهد بدون قفل‌گذاری به داده‌ها دسترسی داشته باشند، در حالی که نویسندگان می‌توانند همزمان داده‌ها را به‌روزرسانی کنند. پاکسازی حافظه تنها پس از یک "دوره تنفس" (grace period) زمانی که تمام خوانندگان قدیمی کار خود را تمام کرده‌اند، انجام می‌شود.

3. **SLAB Allocator**: این تخصیص‌دهنده حافظه، کارایی را با استفاده مجدد از بلوک‌های حافظه برای اشیاء با اندازه مشابه بهبود می‌بخشد و می‌تواند مشکلات قطعه‌قطعه شدن حافظه را کاهش دهد.

```c
/**
 * Example of reference counting
 */
struct example_obj {
    struct kref refcount;
    /* other members */
};

static void example_obj_release(struct kref *ref)
{
    struct example_obj *obj = container_of(ref, struct example_obj, refcount);
    /* Cleanup resources */
    kfree(obj);
}

/* Create a new object */
struct example_obj *example_obj_create(void)
{
    struct example_obj *obj;
    
    obj = kzalloc(sizeof(*obj), GFP_KERNEL);
    if (!obj)
        return NULL;
    
    /* Initialize reference count to 1 */
    kref_init(&obj->refcount);
    
    return obj;
}

/* Get a reference to the object */
void example_obj_get(struct example_obj *obj)
{
    kref_get(&obj->refcount);
}

/* Release a reference to the object */
void example_obj_put(struct example_obj *obj)
{
    /* If this was the last reference, the release function will be called */
    kref_put(&obj->refcount, example_obj_release);
}
```

## زمانبندی فرآیندها

زمانبندی فرآیندها یکی از وظایف اصلی هر سیستم‌عامل است. زمانبند کرنل لینوکس مسئول تصمیم‌گیری درباره اینکه کدام فرآیند یا نخ باید در چه زمانی روی CPU اجرا شود، است. این بخش پیچیده و حیاتی از کرنل لینوکس، تأثیر مستقیمی بر کارایی، پاسخگویی و عدالت سیستم دارد.

### فرآیندها و نخ‌ها در لینوکس

در کرنل لینوکس، هم فرآیندها و هم نخ‌ها با ساختار داده `task_struct` نمایش داده می‌شوند که گاهی به آن "توصیف‌کننده فرآیند" (process descriptor) نیز می‌گویند. این ساختار حاوی تمام اطلاعات مورد نیاز برای مدیریت یک فرآیند یا نخ است، از جمله:

- شناسه فرآیند (PID)
- وضعیت فرآیند (در حال اجرا، آماده، خوابیده و غیره)
- اولویت و اطلاعات زمانبندی
- اشاره‌گرهایی به ساختارهای داده مربوط به حافظه، فایل‌های باز و غیره
- آمار و اطلاعات حسابداری

در لینوکس، نخ‌ها تنها فرآیندهایی هستند که فضای آدرس و برخی منابع دیگر را به اشتراک می‌گذارند. از دیدگاه زمانبند، تفاوت چندانی بین فرآیندها و نخ‌ها وجود ندارد و هر دو به عنوان "task" مدیریت می‌شوند.

```c
/**
 * Simplified version of the task_struct structure
 * include/linux/sched.h
 */
struct task_struct {
    /* Task state (TASK_RUNNING, TASK_INTERRUPTIBLE, etc.) */
    long state;
    
    /* Process identification */
    pid_t pid;
    pid_t tgid;
    
    /* Scheduling information */
    int prio, static_prio, normal_prio;
    unsigned int rt_priority;
    struct sched_entity se;
    struct sched_rt_entity rt;
    struct sched_dl_entity dl;
    unsigned int policy;
    
    /* Process hierarchy */
    struct task_struct *parent;
    struct list_head children;
    struct list_head sibling;
    
    /* Memory management */
    struct mm_struct *mm, *active_mm;
    
    /* File system info */
    struct fs_struct *fs;
    struct files_struct *files;
    
    /* Signal handlers */
    struct signal_struct *signal;
    struct sighand_struct *sighand;
    sigset_t blocked, real_blocked;
    
    /* ... many more fields ... */
};
```

### الگوریتم‌های زمانبندی

کرنل لینوکس از چندین الگوریتم زمانبندی مختلف پشتیبانی می‌کند که هر کدام برای سناریوهای خاصی بهینه شده‌اند. سه الگوریتم اصلی عبارتند از:

1. **زمانبند کاملاً عادلانه (CFS - Completely Fair Scheduler)**: 
   زمانبند پیش‌فرض برای فرآیندهای معمولی. این زمانبند سعی می‌کند زمان پردازنده را به طور عادلانه بین تمام فرآیندها تقسیم کند، با در نظر گرفتن اولویت آنها.

2. **زمانبند بلادرنگ (RT - Real-Time Scheduler)**:
   برای فرآیندهای بلادرنگ نرم که نیاز به پاسخگویی قابل پیش‌بینی دارند. این فرآیندها همیشه اولویت بالاتری نسبت به فرآیندهای معمولی دارند.

3. **زمانبند ضرب‌الاجل (DL - Deadline Scheduler)**:
   برای فرآیندهایی که باید کار مشخصی را در زمان مشخصی به پایان برسانند. این زمانبند از الگوریتم زمانبندی ضرب‌الاجل استفاده می‌کند که برای سیستم‌های بلادرنگ سخت مناسب است.

هر فرآیند با یکی از سیاست‌های زمانبندی زیر اجرا می‌شود که مشخص می‌کند کدام الگوریتم برای آن استفاده شود:

- `SCHED_NORMAL` (یا `SCHED_OTHER`): زمانبندی معمولی با CFS
- `SCHED_BATCH`: مشابه NORMAL، اما برای فرآیندهای دسته‌ای که نیاز به پاسخگویی ندارند
- `SCHED_IDLE`: برای فرآیندهایی با کمترین اولویت
- `SCHED_FIFO`: زمانبندی بلادرنگ first-in, first-out
- `SCHED_RR`: زمانبندی بلادرنگ round-robin
- `SCHED_DEADLINE`: زمانبندی ضرب‌الاجل

```c
/**
 * Example of setting a process's scheduling policy
 */
#include <sched.h>

int set_process_scheduling_policy(pid_t pid, int policy, int priority)
{
    struct sched_param param;
    
    /* Set the priority (for SCHED_FIFO and SCHED_RR) */
    param.sched_priority = priority;
    
    /* Change the scheduling policy and priority */
    return sched_setscheduler(pid, policy, &param);
}
```

### کلاس‌های زمانبندی

زمانبند لینوکس به صورت ماژولار طراحی شده است، به طوری که پیاده‌سازی‌های مختلف زمانبندی می‌توانند به عنوان "کلاس‌های زمانبندی" پیاده‌سازی شوند. هر کلاس زمانبندی باید یک مجموعه عملیات خاص را پیاده‌سازی کند که توسط زمانبند اصلی فراخوانی می‌شوند.

کلاس‌های زمانبندی به صورت سلسله مراتبی مرتب شده‌اند، به طوری که کلاس‌های با اولویت بالاتر همیشه ابتدا برای انتخاب فرآیند بعدی برای اجرا بررسی می‌شوند:

1. **کلاس زمانبندی ضرب‌الاجل (dl_sched_class)**
2. **کلاس زمانبندی بلادرنگ (rt_sched_class)**
3. **کلاس زمانبندی کاملاً عادلانه (fair_sched_class)**
4. **کلاس زمانبندی کاربران پیش‌زمینه (idle_sched_class)**

```c
/**
 * Structure defining a scheduling class
 * kernel/sched/sched.h
 */
struct sched_class {
    /* These methods are called from the main scheduler */
    const struct sched_class *next;
    
    /* Functions required by the scheduler */
    void (*enqueue_task) (struct rq *rq, struct task_struct *p, int flags);
    void (*dequeue_task) (struct rq *rq, struct task_struct *p, int flags);
    void (*yield_task) (struct rq *rq);
    
    void (*check_preempt_curr) (struct rq *rq, struct task_struct *p, int flags);
    
    struct task_struct *(*pick_next_task) (struct rq *rq,
                                          struct task_struct *prev);
    
    void (*put_prev_task) (struct rq *rq, struct task_struct *p);
    void (*set_curr_task) (struct rq *rq);
    void (*task_tick) (struct rq *rq, struct task_struct *p, int queued);
    
    /* ... more methods ... */
};
```

### زمانبند کاملاً قابل پیش‌بینی

زمانبند کاملاً عادلانه (CFS) که در نسخه 2.6.23 کرنل لینوکس معرفی شد، پیاده‌سازی زمانبند پیش‌فرض برای فرآیندهای معمولی است. این زمانبند بر اساس یک مفهوم ساده استوار است: هر فرآیند باید مقدار عادلانه‌ای از زمان CPU را دریافت کند.

CFS از یک درخت سرخ-سیاه (red-black tree) برای مرتب‌سازی فرآیندها بر اساس "زمان اجرای مجازی" (virtual runtime یا vruntime) آنها استفاده می‌کند. فرآیندی که کمترین vruntime را داشته باشد (یعنی کمترین زمان CPU را تا به حال دریافت کرده است)، بالاترین اولویت را برای اجرا دارد.

ویژگی‌های کلیدی CFS:

1. **عدالت**: هدف اصلی تقسیم عادلانه زمان CPU بین فرآیندها است.
2. **بهره‌وری**: CFS با استفاده از ساختارهای داده کارآمد، وظیفه زمانبندی را با پیچیدگی زمانی O(log n) انجام می‌دهد.
3. **مقیاس‌پذیری**: برای هر CPU یک صف جداگانه وجود دارد که به مقیاس‌پذیری در سیستم‌های چندپردازنده‌ای کمک می‌کند.
4. **پاسخگویی**: علی‌رغم تمرکز بر عدالت، CFS پاسخگویی مناسبی را برای فرآیندهای تعاملی فراهم می‌کند.

```c
/**
 * Simplified version of CFS's pick_next_task function
 * kernel/sched/fair.c
 */
static struct task_struct *pick_next_task_fair(struct rq *rq, struct task_struct *prev)
{
    struct cfs_rq *cfs_rq = &rq->cfs;
    struct sched_entity *se;
    
    if (!cfs_rq->nr_running)
        return NULL;
    
    /* Get the leftmost (lowest vruntime) entity from the red-black tree */
    se = pick_next_entity(cfs_rq, NULL);
    if (!se)
        return NULL;
    
    /* Convert the scheduling entity to its task */
    return task_of(se);
}
```

### زمانبندی بلادرنگ

زمانبند بلادرنگ (RT) لینوکس برای فرآیندهایی طراحی شده است که نیاز به پاسخگویی قابل پیش‌بینی دارند. این زمانبند دو سیاست را پیاده‌سازی می‌کند:

1. **SCHED_FIFO**: فرآیندها به ترتیب ورود اجرا می‌شوند و هر فرآیند تا زمانی که خودش تصمیم به واگذاری CPU نگیرد یا به حالت خواب برود، به اجرا ادامه می‌دهد.

2. **SCHED_RR**: مشابه FIFO است، با این تفاوت که هر فرآیند تنها برای یک کوانتوم زمانی مشخص اجرا می‌شود و سپس به انتهای صف فرآیندهای هم‌اولویت خود منتقل می‌شود.

هر فرآیند بلادرنگ یک عدد اولویت استاتیک بین 1 (کمترین) تا 99 (بیشترین) دارد. فرآیندهای بلادرنگ همیشه اولویت بالاتری نسبت به فرآیندهای معمولی دارند.

```c
/**
 * Simplified version of RT's pick_next_task function
 * kernel/sched/rt.c
 */
static struct task_struct *pick_next_task_rt(struct rq *rq)
{
    struct rt_prio_array *array = &rq->rt.active;
    struct rt_rq *rt_rq = &rq->rt;
    struct task_struct *p;
    
    /* If no RT tasks, return NULL */
    if (!rt_rq->rt_nr_running)
        return NULL;
    
    /* Find the highest priority non-empty queue */
    idx = sched_find_first_bit(array->bitmap);
    
    /* Get the first task from that queue */
    list_for_each_entry(p, &array->queue[idx], rt.run_list) {
        if (p->on_rq && p->prio == idx) {
            return p;
        }
    }
    
    return NULL;
}
```

### سیاست‌های زمانبندی

لینوکس از چندین سیاست زمانبندی پشتیبانی می‌کند که نحوه مدیریت فرآیندها توسط زمانبند را مشخص می‌کنند:

1. **SCHED_NORMAL (یا SCHED_OTHER)**: سیاست پیش‌فرض برای فرآیندهای معمولی. از الگوریتم CFS استفاده می‌کند.

2. **SCHED_BATCH**: برای فرآیندهای دسته‌ای (batch) که نیاز به پاسخگویی فوری ندارند. این فرآیندها برای بهینه‌سازی توان عملیاتی (throughput) زمانبندی می‌شوند.

3. **SCHED_IDLE**: برای فرآیندهای با اولویت بسیار پایین که تنها زمانی باید اجرا شوند که CPU بیکار است.

4. **SCHED_FIFO**: یک سیاست بلادرنگ که در آن فرآیندها به ترتیب ورود اجرا می‌شوند و تا زمان تکمیل یا بلوکه شدن، CPU را رها نمی‌کنند.

5. **SCHED_RR**: سیاست بلادرنگ Round-Robin که مشابه FIFO است، اما با محدودیت زمانی برای هر فرآیند.

6. **SCHED_DEADLINE**: برای فرآیندهایی که باید تا یک ضرب‌الاجل مشخص کار خود را تمام کنند. این فرآیندها با سه پارامتر مشخص می‌شوند: زمان اجرا، ضرب‌الاجل نسبی و دوره تناوب.

کاربران معمولی می‌توانند با استفاده از تابع سیستمی `sched_setscheduler()` یا از طریق ابزارهایی مانند `chrt` سیاست زمانبندی یک فرآیند را تغییر دهند، اما معمولاً تنها کاربر ریشه (root) می‌تواند سیاست‌های بلادرنگ را تنظیم کند.

```c
/**
 * System call implementation for setting scheduler policy
 * kernel/sched/core.c
 */
SYSCALL_DEFINE3(sched_setscheduler, pid_t, pid, int, policy,
               struct sched_param __user *, param)
{
    struct sched_param lparam;
    struct task_struct *p;
    
    if (!param || pid < 0)
        return -EINVAL;
    
    if (copy_from_user(&lparam, param, sizeof(struct sched_param)))
        return -EFAULT;
    
    /* Find the task */
    p = find_process_by_pid(pid);
    if (!p)
        return -ESRCH;
    
    /* Check permissions */
    if (!capable(CAP_SYS_NICE))
        return -EPERM;
    
    /* Set the scheduling policy */
    return sched_setscheduler(p, policy, &lparam);
}
```

### توزیع بار بین پردازنده‌ها

در سیستم‌های چندپردازنده‌ای، توزیع بار (load balancing) بین CPU ها یک جنبه مهم از زمانبندی است. هدف این است که بار کاری به طور متعادل بین همه CPU ها توزیع شود تا از منابع سیستم به طور بهینه استفاده شود.

زمانبند لینوکس از چندین راهبرد برای توزیع بار استفاده می‌کند:

1. **توزیع بار دوره‌ای**: در فواصل زمانی منظم، زمانبند بار کاری هر CPU را بررسی می‌کند و در صورت نیاز، فرآیندها را بین آنها جابجا می‌کند.

2. **توزیع بار در زمان ساخت فرآیند**: هنگام ایجاد یک فرآیند جدید، زمانبند سعی می‌کند آن را روی CPU با کمترین بار قرار دهد.

3. **توزیع بار هنگام بیدار شدن فرآیند**: وقتی یک فرآیند از حالت خواب خارج می‌شود، ممکن است روی CPU دیگری با بار کمتر قرار گیرد.

4. **گروه‌های عادلانه**: سیستم گروه‌بندی فرآیندها که اجازه می‌دهد منابع CPU به طور عادلانه بین گروه‌های مختلف فرآیندها تقسیم شود.

5. **دامنه‌های توزیع بار**: برای مقیاس‌پذیری بهتر در سیستم‌های بزرگ، توزیع بار در سطوح مختلف (CPU ها، هسته‌ها، گره‌های NUMA) انجام می‌شود.

لینوکس همچنین از ویژگی‌های سخت‌افزاری مانند SMT (Simultaneous Multi-Threading) و NUMA (Non-Uniform Memory Access) آگاه است و سعی می‌کند تصمیمات زمانبندی خود را بر اساس توپولوژی سیستم بهینه کند.

```c
/**
 * Simplified load balancing function
 * kernel/sched/fair.c
 */
static int load_balance(int this_cpu, struct rq *this_rq,
                       struct sched_domain *sd, enum cpu_idle_type idle)
{
    int nr_moved = 0;
    struct rq *busiest;
    
    /* Find the busiest CPU in this scheduling domain */
    busiest = find_busiest_queue(sd, this_cpu, idle);
    if (!busiest)
        return 0;
    
    /* Don't bother balancing if the difference is too small */
    if (!busiest->nr_running ||
        busiest->nr_running <= this_rq->nr_running + 1)
        return 0;
    
    /* Try to move tasks from the busiest CPU to this CPU */
    nr_moved = move_tasks(this_rq, this_cpu, busiest, sd);
    
    return nr_moved;
}
```

با این مکانیزم توزیع بار و سایر اجزای توصیف شده، زمانبند فرآیندهای لینوکس استفاده کارآمد از منابع CPU، توزیع عادلانه زمان پردازنده بین فرآیندها و پشتیبانی از سناریوهای مختلف کاربری - از برنامه‌های تعاملی تا سیستم‌های بلادرنگ و سرورهای با بار بالا - را تضمین می‌کند.

## سیستم فایل در لینوکس

یکی از ویژگی‌های قدرتمند و انعطاف‌پذیر کرنل لینوکس، سیستم فایل آن است. لینوکس از طیف گسترده‌ای از سیستم‌های فایل پشتیبانی می‌کند و یک ساختار انتزاعی قدرتمند به نام VFS (Virtual File System) را برای یکپارچه‌سازی آنها ارائه می‌دهد. در این بخش، اجزای مختلف سیستم فایل لینوکس را بررسی می‌کنیم.

### معماری VFS

سیستم فایل مجازی (VFS) یک لایه انتزاعی در کرنل لینوکس است که واسط یکپارچه‌ای برای تعامل با انواع مختلف سیستم‌های فایل فراهم می‌کند. این معماری به برنامه‌های کاربردی اجازه می‌دهد تا با استفاده از یک سری فراخوانی‌های سیستمی استاندارد، به سیستم‌های فایل متنوع دسترسی داشته باشند، بدون آنکه نیاز به آگاهی از جزئیات پیاده‌سازی آنها داشته باشند.

**اجزای اصلی VFS:**

1. **Superblock**: نماینده یک سیستم فایل نصب شده است و اطلاعات کلی آن را نگهداری می‌کند.
2. **Inode**: نماینده یک فایل منحصر به فرد است و ویژگی‌های آن را ذخیره می‌کند.
3. **Dentry**: نماینده یک مدخل دایرکتوری است که ارتباط بین نام فایل و inode را برقرار می‌کند.
4. **File**: نماینده یک فایل باز شده توسط یک فرآیند است.

VFS از یک مدل شیء‌گرا استفاده می‌کند که در آن هر سیستم فایل خاص، توابع عملیاتی خود را برای رسیدگی به اشیاء VFS پیاده‌سازی می‌کند.

```c
/**
 * ساختارهای داده اصلی VFS در کرنل لینوکس
 * include/linux/fs.h
 */

/* ساختار Superblock که اطلاعات سیستم فایل را نگهداری می‌کند */
struct super_block {
    struct file_system_type *s_type;
    struct dentry *s_root;
    struct super_operations *s_op;
    unsigned long s_magic;
    dev_t s_dev;
    // دیگر فیلدها...
};

/* ساختار Inode که اطلاعات یک فایل را نگهداری می‌کند */
struct inode {
    umode_t i_mode;
    uid_t i_uid;
    gid_t i_gid;
    dev_t i_rdev;
    loff_t i_size;
    struct timespec i_atime, i_mtime, i_ctime;
    struct inode_operations *i_op;
    struct file_operations *i_fop;
    struct super_block *i_sb;
    // دیگر فیلدها...
};

/* ساختار Dentry که ارتباط بین نام فایل و inode را برقرار می‌کند */
struct dentry {
    struct inode *d_inode;
    struct dentry *d_parent;
    struct qstr d_name;
    struct dentry_operations *d_op;
    // دیگر فیلدها...
};

/* ساختار File که نماینده یک فایل باز شده است */
struct file {
    struct path f_path;
    struct inode *f_inode;
    const struct file_operations *f_op;
    loff_t f_pos;
    unsigned int f_flags;
    // دیگر فیلدها...
};
```

**عملیات VFS:**

VFS عملیات خود را از طریق ساختارهایی مانند `super_operations`، `inode_operations` و `file_operations` انجام می‌دهد. این ساختارها شامل اشاره‌گرهایی به توابعی هستند که برای هر سیستم فایل خاص پیاده‌سازی می‌شوند.

```c
/**
 * عملیات فایل در VFS
 * include/linux/fs.h
 */
struct file_operations {
    ssize_t (*read) (struct file *, char __user *, size_t, loff_t *);
    ssize_t (*write) (struct file *, const char __user *, size_t, loff_t *);
    long (*unlocked_ioctl) (struct file *, unsigned int, unsigned long);
    int (*mmap) (struct file *, struct vm_area_struct *);
    int (*open) (struct inode *, struct file *);
    int (*release) (struct inode *, struct file *);
    // دیگر توابع...
};
```

### انواع سیستم فایل در لینوکس

لینوکس از تعداد زیادی سیستم فایل پشتیبانی می‌کند که می‌توان آنها را به چندین دسته تقسیم کرد:

1. **سیستم‌های فایل محلی**: برای ذخیره‌سازی داده روی دیسک‌های محلی استفاده می‌شوند.
   - ext2, ext3, ext4
   - XFS
   - Btrfs
   - F2FS
   - JFS
   - ReiserFS

2. **سیستم‌های فایل شبکه**: برای دسترسی به فایل‌های ذخیره شده روی سرورهای راه دور استفاده می‌شوند.
   - NFS (Network File System)
   - CIFS (Common Internet File System)
   - AFS (Andrew File System)

3. **سیستم‌های فایل ویژه**: برای اهداف خاص استفاده می‌شوند.
   - procfs: دسترسی به اطلاعات فرآیندها و کرنل
   - sysfs: دسترسی به اطلاعات سیستم و پیکربندی
   - tmpfs: سیستم فایل موقت در حافظه
   - devfs/udev: مدیریت فایل‌های دستگاه

4. **سیستم‌های فایل فشرده**: برای دسترسی به فایل‌های فشرده بدون نیاز به استخراج آنها.
   - squashfs
   - cramfs

5. **سیستم‌های فایل رمزگذاری شده**: برای ذخیره‌سازی امن داده‌ها.
   - eCryptfs
   - LUKS/dm-crypt

### ext2، ext3 و ext4

خانواده Extended File System (ext) طی سال‌ها سیستم‌های فایل استاندارد در بسیاری از توزیع‌های لینوکس بوده‌اند. این سیستم‌های فایل نسل به نسل تکامل یافته‌اند تا قابلیت‌های بیشتر، کارایی بهتر و اطمینان‌پذیری بالاتری را فراهم کنند.

**ext2:**
- سیستم فایل ابتدایی لینوکس بدون قابلیت ژورنالینگ
- ساختار ساده و کارآمد
- مناسب برای رسانه‌های با تعداد نوشتن محدود مانند کارت‌های SD و حافظه‌های فلش

**ext3:**
- نسخه بهبود یافته ext2 با قابلیت ژورنالینگ
- ژورنالینگ باعث افزایش اطمینان‌پذیری می‌شود و از آسیب دیدن فایل‌سیستم در صورت قطع ناگهانی برق جلوگیری می‌کند
- سازگاری کامل با ext2

**ext4:**
- توسعه داده شده در سال 2008 به عنوان جانشین ext3
- پشتیبانی از فایل‌ها و پارتیشن‌های بسیار بزرگ (تا 16 تربایت)
- تخصیص حافظه اختصاصی برای کاهش قطعه‌قطعه شدن
- تأخیر در تخصیص بلوک برای بهبود کارایی
- چک‌سام‌های داده و ژورنال برای افزایش اطمینان‌پذیری
- نگاشت مستقیم برای فایل‌های بزرگ

```c
/**
 * ساختار بلوک super در ext4
 * fs/ext4/ext4.h
 */
struct ext4_super_block {
    __le32  s_inodes_count;         /* تعداد inodeها */
    __le32  s_blocks_count_lo;      /* تعداد بلوک‌ها */
    __le32  s_r_blocks_count_lo;    /* تعداد بلوک‌های رزرو شده */
    __le32  s_free_blocks_count_lo; /* تعداد بلوک‌های آزاد */
    __le32  s_free_inodes_count;    /* تعداد inodeهای آزاد */
    __le32  s_first_data_block;     /* اولین بلوک داده */
    __le32  s_log_block_size;       /* لگاریتم 2 از اندازه بلوک */
    __le32  s_log_cluster_size;     /* لگاریتم 2 از اندازه خوشه */
    __le32  s_blocks_per_group;     /* تعداد بلوک‌ها در هر گروه */
    __le32  s_clusters_per_group;   /* تعداد خوشه‌ها در هر گروه */
    __le32  s_inodes_per_group;     /* تعداد inodeها در هر گروه */
    // دیگر فیلدها...
};
```

### Btrfs و ZFS

Btrfs (B-tree File System) و ZFS دو سیستم فایل پیشرفته هستند که ویژگی‌های نسل جدید را ارائه می‌دهند، مانند نسخه‌برداری از داده‌ها، اسنپ‌شات، RAID نرم‌افزاری و چک‌سام‌های داده.

**Btrfs:**
- توسط Oracle توسعه داده شده و به عنوان "باتر‌اف‌اس" تلفظ می‌شود
- طراحی شده برای رفع محدودیت‌های سیستم‌های فایل قدیمی‌تر
- قابلیت‌های کلیدی شامل:
  - اسنپ‌شات‌های قابل نوشتن
  - زیرحجم‌ها (Subvolumes)
  - RAID نرم‌افزاری داخلی
  - فشرده‌سازی
  - تدبیر (deduplication)
  - چک‌سام‌های داده برای تشخیص خرابی‌ها

**ZFS:**
- در اصل توسط Sun Microsystems برای Solaris توسعه یافته
- معماری مبتنی بر استخر ذخیره‌سازی (storage pool)
- قابلیت‌های کلیدی شامل:
  - اعتبارسنجی و خودترمیمی داده‌ها
  - اسنپ‌شات‌ها و کلون‌ها
  - فشرده‌سازی
  - تدبیر
  - رمزگذاری
  - ظرفیت ذخیره‌سازی بسیار بالا

به دلیل مسائل مربوط به مجوز، ZFS به طور پیش‌فرض در هسته لینوکس قرار ندارد و معمولاً باید به صورت ماژول جداگانه نصب شود.

### سیستم‌های فایل شبکه

سیستم‌های فایل شبکه امکان دسترسی به فایل‌های ذخیره شده روی سرورهای راه دور را فراهم می‌کنند. لینوکس از چندین سیستم فایل شبکه محبوب پشتیبانی می‌کند:

**NFS (Network File System):**
- توسط Sun Microsystems توسعه داده شده
- رایج‌ترین سیستم فایل شبکه در محیط‌های UNIX/Linux
- از پروتکل RPC (Remote Procedure Call) استفاده می‌کند
- نسخه‌های مختلف: NFSv2, NFSv3, NFSv4
- ویژگی‌های NFSv4 شامل:
  - احراز هویت و رمزگذاری بهبود یافته
  - بهبود عملکرد در شبکه‌های WAN
  - پشتیبانی از استیت‌فول (stateful) بودن
  - تجمیع چندین فراخوانی روال در یک عملیات

**CIFS/SMB:**
- Common Internet File System/Server Message Block
- استفاده شده توسط Windows برای اشتراک‌گذاری فایل
- در لینوکس توسط پروژه Samba پیاده‌سازی شده
- قابلیت‌ها:
  - احراز هویت و کنترل دسترسی Windows
  - یکپارچه‌سازی با دامنه‌های Windows
  - اشتراک‌گذاری چاپگر

**SSHFS:**
- سیستم فایل بر پایه SFTP
- امکان نصب سیستم فایل راه دور از طریق SSH
- مزایا:
  - امنیت بالا (رمزگذاری)
  - سادگی راه‌اندازی (نیاز به نصب هیچ سرویس اضافی ندارد)
  - عبور از فایروال‌ها (معمولاً پورت SSH باز است)

```c
/**
 * مثالی از کد کرنل لینوکس برای NFS
 * fs/nfs/nfs4proc.c
 */
static int nfs4_do_open(struct inode *inode, struct file *filp, int flags)
{
    struct nfs_open_context *ctx;
    struct nfs4_state *state = NULL;
    struct nfs4_opendata *opendata;
    int ret;
    
    ctx = nfs_open_context_alloc();
    if (!ctx)
        return -ENOMEM;
    
    opendata = nfs4_opendata_alloc(filp->f_path.dentry, ctx);
    if (!opendata) {
        ret = -ENOMEM;
        goto out;
    }
    
    /* انجام عملیات باز کردن NFSv4 */
    ret = _nfs4_do_open(opendata);
    if (ret)
        goto out_opendata;
    
    state = opendata->state;
    ret = nfs4_opendata_check_status(opendata);
    if (ret)
        goto out_opendata;
    
    /* تنظیم حالت فایل و دیگر داده‌های مرتبط */
    ctx->state = state;
    filp->private_data = ctx;
    
out_opendata:
    nfs4_opendata_put(opendata);
out:
    if (ret)
        nfs_free_open_context(ctx);
    return ret;
}
```

### عملکرد ورودی/خروجی

سیستم ورودی/خروجی (I/O) لینوکس مسئول مدیریت درخواست‌های خواندن و نوشتن به دستگاه‌های ذخیره‌سازی است. این سیستم شامل چندین لایه است که هر کدام وظایف خاصی را انجام می‌دهند:

**لایه VFS:**
- واسط یکپارچه برای دسترسی به سیستم‌های فایل
- ارائه فراخوانی‌های سیستمی استاندارد: open(), read(), write(), close() و غیره
- مدیریت حافظه کش برای فایل‌ها (Page Cache)

**لایه سیستم فایل:**
- تبدیل درخواست‌های سطح بالا به عملیات سطح بلوک
- مدیریت ساختار منطقی سیستم فایل (دایرکتوری‌ها، inodeها و غیره)

**لایه Generic Block Layer:**
- برنامه‌ریزی درخواست‌های I/O
- ادغام و مرتب‌سازی درخواست‌ها برای بهینه‌سازی عملکرد
- سیستم I/O صف‌بندی شده (I/O Schedulers)

**لایه درایور بلوکی:**
- تعامل مستقیم با سخت‌افزار ذخیره‌سازی
- پیاده‌سازی پروتکل‌های خاص سخت‌افزار (SATA, SCSI, NVMe و غیره)

**برنامه‌ریزهای I/O (I/O Schedulers):**

لینوکس از چندین برنامه‌ریز I/O پشتیبانی می‌کند که هر کدام برای سناریوهای خاصی بهینه شده‌اند:

1. **CFQ (Completely Fair Queuing)**: تلاش می‌کند زمان I/O را به طور عادلانه بین فرآیندها تقسیم کند. مناسب برای workstation.
2. **Deadline**: برای کاهش زمان پاسخ طراحی شده و ضرب‌الاجل‌هایی برای خواندن و نوشتن تنظیم می‌کند. مناسب برای سرورهای پایگاه داده.
3. **NOOP**: ساده‌ترین برنامه‌ریز که ادغام درخواست‌های مجاور را انجام می‌دهد اما مرتب‌سازی پیچیده انجام نمی‌دهد. مناسب برای دستگاه‌های فلش و درایوهای SSD.
4. **BFQ (Budget Fair Queuing)**: به هر فرآیند بودجه I/O اختصاص می‌دهد. برای سیستم‌هایی با انواع مختلف بار کاری مناسب است.

```c
/**
 * نمونه ساده‌ای از کد برنامه‌ریز I/O
 * block/deadline-iosched.c (ساده شده)
 */
static int deadline_dispatch(struct request_queue *q, int force)
{
    struct deadline_data *dd = q->elevator->elevator_data;
    struct request *rq;
    
    /* ابتدا سعی کن از صف‌های خواندن با ضرب‌الاجل برداری */
    rq = deadline_check_fifo(dd, DEADLINE_READ);
    if (rq)
        goto dispatch;
    
    /* سپس صف‌های نوشتن با ضرب‌الاجل را بررسی کن */
    rq = deadline_check_fifo(dd, DEADLINE_WRITE);
    if (rq)
        goto dispatch;
    
    /* اگر صف‌های با ضرب‌الاجل خالی بودند، از صف‌های عادی استفاده کن */
    if (dd->next_batch == DEADLINE_BATCH_READ)
        rq = deadline_next_request(dd, DEADLINE_READ);
    else
        rq = deadline_next_request(dd, DEADLINE_WRITE);
    
    if (!rq) {
        /* تغییر بین خواندن و نوشتن */
        dd->next_batch = !dd->next_batch;
        rq = deadline_next_request(dd, dd->next_batch);
    }
    
dispatch:
    if (rq) {
        /* درخواست را به لایه پایین‌تر ارسال کن */
        dd->dispatched++;
        elv_dispatch_add_tail(q, rq);
        return 1;
    }
    
    return 0;
}
```

### کش و بافر سیستم فایل

کرنل لینوکس از چندین مکانیزم کش برای بهبود عملکرد سیستم فایل استفاده می‌کند:

**Page Cache:**
- حافظه کش اصلی برای داده‌های فایل
- صفحات خوانده شده از دیسک را در حافظه نگه می‌دارد
- خواندن‌ها و نوشتن‌های بعدی به همان داده می‌توانند بدون دسترسی به دیسک انجام شوند
- کاهش قابل توجه زمان دسترسی به داده‌ها
- از الگوریتم LRU (Least Recently Used) برای مدیریت حافظه استفاده می‌کند

**Buffer Cache:**
- کش برای بلوک‌های دیسک (بیشتر برای متاداده‌های سیستم فایل)
- در نسخه‌های جدید کرنل، Buffer Cache در Page Cache ادغام شده است

**Dentry Cache:**
- کش برای مدخل‌های دایرکتوری (dentry)
- نگاشت بین نام‌های فایل و inodeها را ذخیره می‌کند
- تسریع جستجوی مسیر فایل

**Inode Cache:**
- کش برای inodeهای پر استفاده
- اطلاعات متاداده فایل‌ها را در حافظه نگه می‌دارد

**مکانیزم‌های نوشتن:**

برای نوشتن داده‌های تغییر یافته از Page Cache به دیسک، کرنل لینوکس از چندین استراتژی استفاده می‌کند:

1. **نوشتن همزمان (Synchronous Write)**: داده‌ها بلافاصله به دیسک نوشته می‌شوند.
2. **نوشتن با تأخیر (Delayed Write)**: داده‌های تغییر یافته در حافظه نگهداری می‌شوند و در زمان مناسب‌تری به دیسک نوشته می‌شوند.
3. **نوشتن دوره‌ای (Periodic Write)**: دیمون `pdflush` یا `kworker` (در کرنل‌های جدیدتر) به طور دوره‌ای داده‌های تغییر یافته را به دیسک می‌نویسد.
4. **نوشتن پیش‌گیرانه (Writeback)**: سیستم به طور خودکار و بر اساس فشار حافظه، داده‌های تغییر یافته را به دیسک می‌نویسد.

```c
/**
 * نمونه‌ای از کد مرتبط با Page Cache
 * mm/filemap.c
 */
void do_generic_file_read(struct file *filp, loff_t *ppos, 
                          struct kiocb *iocb, struct iov_iter *iter)
{
    struct address_space *mapping = filp->f_mapping;
    pgoff_t index = *ppos >> PAGE_SHIFT;
    struct page *page;
    int ret;
    
    /* سعی کن صفحه را از Page Cache بیابی */
    page = find_get_page(mapping, index);
    if (!page) {
        /* صفحه در کش نیست، آن را از دیسک بخوان */
        page = page_cache_alloc_cold(mapping);
        if (!page)
            return -ENOMEM;
        
        /* صفحه را از دیسک بخوان */
        ret = mapping->a_ops->readpage(filp, page);
        if (ret) {
            put_page(page);
            return ret;
        }
        
        /* صفحه را به Page Cache اضافه کن */
        add_to_page_cache_lru(page, mapping, index, GFP_KERNEL);
    }
    
    /* داده را از صفحه به فضای کاربر کپی کن */
    copy_page_to_iter(page, 0, PAGE_SIZE, iter);
    
    put_page(page);
    return 0;
}
```

سیستم فایل در لینوکس یک طراحی پیچیده، انعطاف‌پذیر و کارآمد است که به کرنل اجازه می‌دهد از انواع مختلف رسانه‌های ذخیره‌سازی، سیستم‌های فایل و پروتکل‌های شبکه پشتیبانی کند. لایه VFS نقش کلیدی در ارائه یک واسط یکپارچه بازی می‌کند، در حالی که مکانیزم‌های کش و برنامه‌ریزی I/O، عملکرد را بهبود می‌بخشند.

## مدیریت دستگاه‌ها

مدیریت دستگاه‌ها در کرنل لینوکس یکی از وظایف اصلی و پیچیده‌ای است که این سیستم‌عامل را قادر می‌سازد با انواع مختلف سخت‌افزارها تعامل داشته باشد. لینوکس از یک مدل مبتنی بر درایور استفاده می‌کند که انتزاع سطح بالایی از سخت‌افزار فراهم می‌کند و به برنامه‌های کاربردی اجازه می‌دهد بدون نیاز به دانستن جزئیات سخت‌افزار، با دستگاه‌ها ارتباط برقرار کنند.

### درایورهای دستگاه

درایورهای دستگاه، ماژول‌های کرنلی هستند که عملکرد یک دستگاه سخت‌افزاری خاص را کنترل می‌کنند. آنها واسط بین سخت‌افزار و بقیه کرنل هستند و وظیفه ترجمه درخواست‌های سطح بالا به دستورات خاص سخت‌افزار را بر عهده دارند.

**انواع درایورهای دستگاه در لینوکس:**

1. **درایورهای کاراکتری (Character Drivers)**:
   - برای دستگاه‌هایی که داده را به صورت جریانی از بایت‌ها منتقل می‌کنند
   - دسترسی به داده به صورت متوالی (sequential)
   - مثال‌ها: پورت‌های سریال، کیبورد، موس، چاپگر

2. **درایورهای بلوکی (Block Drivers)**:
   - برای دستگاه‌های ذخیره‌سازی که داده را در بلوک‌های با اندازه ثابت ذخیره می‌کنند
   - دسترسی به داده به صورت تصادفی (random)
   - مثال‌ها: هارد دیسک، SSD، دیسک‌های فلش

3. **درایورهای شبکه (Network Drivers)**:
   - برای کارت‌های شبکه
   - از واسط خاصی به نام netdevice استفاده می‌کنند
   - مدیریت بسته‌های شبکه برای ارسال و دریافت

4. **درایورهای USB**:
   - برای مدیریت دستگاه‌های متصل به پورت USB
   - با استفاده از چارچوب USB کرنل

5. **درایورهای گرافیکی**:
   - برای کارت‌های گرافیک و نمایشگرها
   - از چارچوب‌های DRM (Direct Rendering Manager)، KMS (Kernel Mode Setting) و Framebuffer استفاده می‌کنند

```c
/**
 * مثالی از یک درایور کاراکتری ساده
 * درایورهای کاراکتری از ساختار file_operations استفاده می‌کنند
 */
static struct file_operations simple_driver_fops = {
    .owner = THIS_MODULE,
    .open = simple_open,
    .read = simple_read,
    .write = simple_write,
    .release = simple_release,
};

/* ثبت درایور در سیستم */
static int __init simple_init(void)
{
    int ret;
    
    /* ثبت شماره major برای درایور */
    ret = register_chrdev(SIMPLE_MAJOR, "simple", &simple_driver_fops);
    if (ret < 0) {
        printk(KERN_ERR "Failed to register simple driver\n");
        return ret;
    }
    
    printk(KERN_INFO "Simple driver loaded\n");
    return 0;
}

/* خروج درایور از سیستم */
static void __exit simple_exit(void)
{
    /* لغو ثبت درایور */
    unregister_chrdev(SIMPLE_MAJOR, "simple");
    printk(KERN_INFO "Simple driver unloaded\n");
}

module_init(simple_init);
module_exit(simple_exit);
```

### سیستم‌های فایل دستگاه

یکی از مفاهیم اساسی در لینوکس این است که "همه چیز یک فایل است". این فلسفه شامل دستگاه‌های سخت‌افزاری نیز می‌شود. لینوکس از دو سیستم فایل ویژه برای ارائه اطلاعات و کنترل دستگاه‌ها استفاده می‌کند: `/dev` و `/proc`.

**/dev (Device Filesystem):**
- حاوی فایل‌های ویژه‌ای است که دستگاه‌های سخت‌افزاری را نمایش می‌دهند
- انواع اصلی فایل‌های دستگاه:
  - **دستگاه‌های کاراکتری**: با حرف "c" در خروجی دستور `ls -l` مشخص می‌شوند
  - **دستگاه‌های بلوکی**: با حرف "b" در خروجی دستور `ls -l` مشخص می‌شوند
- هر فایل دستگاه با یک جفت عدد (major, minor) مشخص می‌شود:
  - **Major number**: مشخص کننده درایور مورد استفاده
  - **Minor number**: مشخص کننده یک دستگاه خاص کنترل شده توسط آن درایور
- مدیریت `/dev` معمولاً توسط `udev` انجام می‌شود (جایگزین مدرن برای devfs)

**/proc (Process Filesystem):**
- سیستم فایل مجازی که اطلاعاتی درباره فرآیندها و کرنل ارائه می‌دهد
- دایرکتوری‌های شماره‌دار نماینده فرآیندهای در حال اجرا هستند
- فایل‌های متعددی اطلاعات سیستم را ارائه می‌دهند، مانند:
  - `/proc/cpuinfo`: اطلاعات CPU
  - `/proc/meminfo`: اطلاعات حافظه
  - `/proc/interrupts`: آمار وقفه‌ها
  - `/proc/devices`: لیست دستگاه‌های ثبت شده

**/sys (Sysfs):**
- سیستم فایل مجازی جدیدتر که اطلاعات بیشتری درباره دستگاه‌ها و درایورها ارائه می‌دهد
- ساختار سلسله مراتبی با دایرکتوری‌های مختلف:
  - `/sys/devices`: نمایش سلسله مراتب دستگاه‌های فیزیکی
  - `/sys/bus`: اطلاعات مربوط به باس‌های سیستم
  - `/sys/class`: دستگاه‌ها بر اساس کلاس (مثلاً، دیسک، شبکه و غیره)
  - `/sys/block`: دستگاه‌های بلوکی
  - `/sys/module`: ماژول‌های کرنل بارگذاری شده

```bash
# نمونه‌ای از خروجی ls -l در دایرکتوری /dev
$ ls -l /dev/sda /dev/tty1
brw-rw---- 1 root disk    8, 0 Jun 30 12:34 /dev/sda
crw--w---- 1 root tty     4, 1 Jun 30 12:35 /dev/tty1
# b نشان دهنده دستگاه بلوکی و c نشان دهنده دستگاه کاراکتری است
# 8,0 و 4,1 اعداد major و minor هستند
```

### مدل درایور لینوکس

کرنل لینوکس دارای یک مدل منسجم و چارچوب قدرتمند برای نوشتن درایورهای دستگاه است. مدل درایور لینوکس دارای چندین ویژگی کلیدی است:

**1. مدل ماژولار:**
- درایورها می‌توانند به صورت ماژول‌های قابل بارگذاری پویا پیاده‌سازی شوند
- این امکان اضافه کردن یا حذف درایورها بدون نیاز به راه‌اندازی مجدد سیستم را فراهم می‌کند
- ماژول‌ها با دستورات `insmod`, `modprobe` و `rmmod` مدیریت می‌شوند

**2. چارچوب‌های زیرساختی:**
- کرنل چارچوب‌های متعددی برای انواع خاصی از دستگاه‌ها ارائه می‌دهد
- نویسندگان درایور می‌توانند از این چارچوب‌ها به جای نوشتن همه کد از ابتدا استفاده کنند
- مثال‌ها: USB، PCI، I2C، SPI، گرافیک، شبکه و غیره

**3. مدل رانشی (Driver Model):**
- چارچوب یکپارچه برای نمایش دستگاه‌ها، درایورها و باس‌ها
- تعریف واسط‌های استاندارد برای تعامل درایور-دستگاه
- پشتیبانی از hotplug و مدیریت انرژی

**4. مدل تطبیق درایور-دستگاه:**
- شناسایی خودکار دستگاه‌ها توسط کرنل
- تطبیق دستگاه‌های شناسایی شده با درایورهای مناسب
- از شناسه‌های دستگاه (مانند شناسه‌های PCI/USB) برای این تطبیق استفاده می‌شود

```c
/**
 * مثالی از ثبت یک درایور PCI در کرنل لینوکس
 * drivers/example/example_driver.c
 */

/* جدول شناسه‌های PCI پشتیبانی شده توسط این درایور */
static struct pci_device_id example_pci_ids[] = {
    { PCI_DEVICE(0x1234, 0x5678) }, /* Vendor ID 0x1234, Device ID 0x5678 */
    { PCI_DEVICE(0x1234, 0x9ABC) }, /* دستگاه دیگر از همان سازنده */
    { 0, }
};
MODULE_DEVICE_TABLE(pci, example_pci_ids);

/* تابع probe که زمانی فراخوانی می‌شود که یک دستگاه سازگار یافت شود */
static int example_probe(struct pci_dev *pdev, const struct pci_device_id *id)
{
    /* مقداردهی اولیه دستگاه و تخصیص منابع */
    /* ... */
    return 0;
}

/* تابع remove که زمانی فراخوانی می‌شود که دستگاه حذف شود */
static void example_remove(struct pci_dev *pdev)
{
    /* آزادسازی منابع و پاکسازی */
    /* ... */
}

/* عملیات درایور PCI */
static struct pci_driver example_driver = {
    .name = "example",
    .id_table = example_pci_ids,
    .probe = example_probe,
    .remove = example_remove,
    .suspend = example_suspend,    /* برای مدیریت انرژی */
    .resume = example_resume,      /* برای مدیریت انرژی */
};

/* تابع مقداردهی اولیه ماژول */
static int __init example_init(void)
{
    /* ثبت درایور PCI */
    return pci_register_driver(&example_driver);
}

/* تابع خروج ماژول */
static void __exit example_exit(void)
{
    /* لغو ثبت درایور PCI */
    pci_unregister_driver(&example_driver);
}

module_init(example_init);
module_exit(example_exit);

MODULE_AUTHOR("Example Author");
MODULE_DESCRIPTION("Example PCI Driver");
MODULE_LICENSE("GPL");
```

### hotplug و پشتیبانی از اتصال داغ

یکی از ویژگی‌های مهم کرنل لینوکس پشتیبانی از hotplug (اتصال داغ) است، که به سیستم‌عامل اجازه می‌دهد دستگاه‌ها را در حین اجرا اضافه یا حذف کند، بدون نیاز به راه‌اندازی مجدد. این قابلیت برای فناوری‌هایی مانند USB، PCIe و SATA که اتصال و جدا کردن سخت‌افزار در حین کار را پشتیبانی می‌کنند، ضروری است.

**سیستم hotplug لینوکس:**

1. **شناسایی دستگاه**:
   - وقتی یک دستگاه متصل می‌شود، کرنل به طور خودکار آن را شناسایی می‌کند
   - اطلاعات دستگاه از طریق baس های سیستم (مانند USB، PCI) جمع‌آوری می‌شود

2. **تولید رویداد**:
   - کرنل یک رویداد uevent تولید می‌کند
   - این رویداد حاوی اطلاعاتی درباره دستگاه جدید است

3. **مدیریت رویداد**:
   - در سیستم‌های مدرن، دیمون udev رویدادها را دریافت و پردازش می‌کند
   - udev قوانینی را اجرا می‌کند که نحوه پیکربندی دستگاه را مشخص می‌کنند

4. **بارگذاری درایور**:
   - بر اساس اطلاعات دستگاه، درایور مناسب بارگذاری می‌شود
   - از `modprobe` برای بارگذاری ماژول‌های کرنل استفاده می‌شود

5. **ایجاد گره‌های دستگاه**:
   - فایل‌های دستگاه مناسب در `/dev` ایجاد می‌شوند
   - مجوزها و مالکیت این فایل‌ها تنظیم می‌شود

6. **اعلام به برنامه‌های کاربردی**:
   - سیستم‌هایی مانند D-Bus می‌توانند به برنامه‌های کاربردی اطلاع دهند که دستگاه جدیدی متصل شده است

**پیاده‌سازی hotplug در درایورها:**

درایورها باید برای پشتیبانی از hotplug، توابع خاصی را پیاده‌سازی کنند:

- **probe()**: زمانی فراخوانی می‌شود که یک دستگاه جدید متصل شود
- **remove()**: زمانی فراخوانی می‌شود که یک دستگاه جدا شود
- **suspend()/resume()**: برای مدیریت انرژی (به ویژه برای دستگاه‌های قابل حمل)

```c
/**
 * مثالی از پیاده‌سازی hotplug در یک درایور USB
 */
static struct usb_device_id example_usb_ids[] = {
    { USB_DEVICE(0x1234, 0x5678) }, /* Vendor ID 0x1234, Product ID 0x5678 */
    { }
};
MODULE_DEVICE_TABLE(usb, example_usb_ids);

static int example_probe(struct usb_interface *interface, 
                         const struct usb_device_id *id)
{
    struct example_device *dev;
    
    /* تخصیص ساختار داده دستگاه */
    dev = kzalloc(sizeof(*dev), GFP_KERNEL);
    if (!dev)
        return -ENOMEM;
    
    /* مقداردهی اولیه دستگاه */
    dev->udev = usb_get_dev(interface_to_usbdev(interface));
    dev->interface = interface;
    
    /* ذخیره اشاره‌گر به داده‌های خصوصی */
    usb_set_intfdata(interface, dev);
    
    /* ثبت دستگاه کاراکتری */
    if (register_example_device(dev) < 0) {
        kfree(dev);
        return -ENODEV;
    }
    
    dev_info(&interface->dev, "USB Example device connected\n");
    return 0;
}

static void example_disconnect(struct usb_interface *interface)
{
    struct example_device *dev;
    
    /* بازیابی داده‌های خصوصی */
    dev = usb_get_intfdata(interface);
    
    /* حذف دستگاه از سیستم */
    unregister_example_device(dev);
    
    /* پاکسازی */
    usb_set_intfdata(interface, NULL);
    usb_put_dev(dev->udev);
    kfree(dev);
    
    dev_info(&interface->dev, "USB Example device disconnected\n");
}

static struct usb_driver example_driver = {
    .name = "example",
    .id_table = example_usb_ids,
    .probe = example_probe,
    .disconnect = example_disconnect,
};

static int __init example_init(void)
{
    return usb_register(&example_driver);
}

static void __exit example_exit(void)
{
    usb_deregister(&example_driver);
}

module_init(example_init);
module_exit(example_exit);
```

### مدیریت انرژی

مدیریت انرژی یک جنبه مهم از کرنل لینوکس، به ویژه برای دستگاه‌های قابل حمل است. کرنل لینوکس از چندین مکانیزم برای کاهش مصرف انرژی استفاده می‌کند:

**1. ACPI (Advanced Configuration and Power Interface):**
- استاندارد صنعتی برای مدیریت انرژی و پیکربندی
- لینوکس یک پیاده‌سازی کامل از ACPI دارد
- پشتیبانی از حالت‌های مختلف خواب سیستم (S0 تا S5)
- مدیریت حرارتی و کنترل فن

**2. CPUFreq:**
- چارچوب مدیریت فرکانس و ولتاژ پردازنده
- اجازه می‌دهد فرکانس پردازنده بر اساس بار سیستم تغییر کند
- فرمانرواهای مختلف (governors) برای استراتژی‌های مختلف:
  - **performance**: حداکثر فرکانس
  - **powersave**: حداقل فرکانس
  - **ondemand**: تنظیم فرکانس بر اساس استفاده از CPU
  - **conservative**: مشابه ondemand اما با تغییرات تدریجی‌تر
  - **schedutil**: استفاده از اطلاعات زمانبند برای تصمیم‌گیری

**3. CPUIdle:**
- مدیریت حالت‌های بیکاری (idle) پردازنده
- انتخاب حالت بیکاری مناسب بر اساس الگوی کاری و زمان پیش‌بینی شده تا رویداد بعدی
- پشتیبانی از حالت‌های عمیق بیکاری با مصرف کمتر انرژی

**4. Runtime Power Management:**
- مدیریت انرژی دستگاه‌ها در زمان اجرا
- امکان خاموش کردن دستگاه‌هایی که استفاده نمی‌شوند
- درایورها باید توابع suspend و resume را پیاده‌سازی کنند

**5. Suspend to RAM / Disk:**
- ذخیره وضعیت سیستم در RAM (suspend to RAM یا S3)
- ذخیره وضعیت سیستم در دیسک (suspend to disk یا S4، همچنین hibernate نامیده می‌شود)
- فرآیند منظم خاموش کردن و روشن کردن مجدد دستگاه‌ها

```c
/**
 * مثالی از پیاده‌سازی مدیریت انرژی در یک درایور
 */
static int example_suspend(struct device *dev)
{
    struct example_device *example_dev = dev_get_drvdata(dev);
    
    /* ذخیره وضعیت دستگاه */
    example_dev->saved_state = example_read_device_state(example_dev);
    
    /* خاموش کردن دستگاه */
    example_disable_device(example_dev);
    
    /* قطع وقفه‌ها */
    if (example_dev->irq)
        disable_irq(example_dev->irq);
    
    return 0;
}

static int example_resume(struct device *dev)
{
    struct example_device *example_dev = dev_get_drvdata(dev);
    
    /* فعال کردن وقفه‌ها */
    if (example_dev->irq)
        enable_irq(example_dev->irq);
    
    /* روشن کردن دستگاه */
    example_enable_device(example_dev);
    
    /* بازیابی وضعیت دستگاه */
    example_write_device_state(example_dev, example_dev->saved_state);
    
    return 0;
}

static const struct dev_pm_ops example_pm_ops = {
    .suspend = example_suspend,
    .resume = example_resume,
    .runtime_suspend = example_runtime_suspend,
    .runtime_resume = example_runtime_resume,
    .runtime_idle = example_runtime_idle,
};

static struct pci_driver example_driver = {
    .name = "example",
    .id_table = example_pci_ids,
    .probe = example_probe,
    .remove = example_remove,
    .driver = {
        .pm = &example_pm_ops,
    },
};
```

### درایورهای گرافیکی

درایورهای گرافیکی در لینوکس یکی از پیچیده‌ترین انواع درایورها هستند. برای مدیریت کارت‌های گرافیکی مدرن، لینوکس از چندین زیرسیستم استفاده می‌کند:

**1. DRM (Direct Rendering Manager):**
- زیرسیستم اصلی کرنل برای مدیریت کارت‌های گرافیکی
- فراهم کردن دسترسی کنترل شده به قابلیت‌های شتاب‌دهنده گرافیکی
- مدیریت منابع مانند حافظه ویدئویی و موتورهای رندر

**2. KMS (Kernel Mode Setting):**
- بخشی از DRM برای تنظیم مد نمایش (رزولوشن، عمق رنگ و غیره)
- کنترل مستقیم نمایشگر توسط کرنل به جای فضای کاربر
- پشتیبانی از hotplug نمایشگر و پیکربندی چندین نمایشگر

**3. GEM (Graphics Execution Manager):**
- مدیریت حافظه برای اشیاء گرافیکی
- اشتراک‌گذاری بافرهای گرافیکی بین برنامه‌های مختلف

**4. TTM (Translation Table Maps):**
- مدیریت حافظه گرافیکی پیشرفته
- استفاده شده توسط درایورهای AMD و Nouveau

**5. Framebuffer:**
- واسط ساده‌تر و قدیمی‌تر برای دسترسی به بافر فریم
- همچنان برای سیستم‌های نهفته و بوت استفاده می‌شود

**واسط‌های فضای کاربر:**

- **X.Org**: سیستم پنجره سنتی لینوکس
- **Wayland**: سیستم ترکیب کننده جدیدتر
- **Mesa**: پیاده‌سازی متن‌باز OpenGL، Vulkan و دیگر APIهای گرافیکی

**درایورهای گرافیکی اصلی در لینوکس:**

- **Intel i915**: برای GPUهای داخلی Intel
- **AMD (amdgpu)**: برای GPUهای جدیدتر AMD
- **NVIDIA (nouveau)**: درایور متن‌باز برای کارت‌های NVIDIA
- **NVIDIA (proprietary)**: درایور اختصاصی NVIDIA (از طریق DKMS)

```c
/**
 * مثالی از بخش‌های یک درایور DRM
 * (بسیار ساده‌سازی شده)
 */

/* مقداردهی اولیه درایور DRM */
static int example_drm_init(struct drm_device *dev)
{
    int ret;
    
    /* تنظیم قابلیت‌های DRM */
    ret = drmm_mode_config_init(dev);
    if (ret)
        return ret;
    
    /* مقداردهی اولیه موتورهای نمایش */
    ret = example_display_init(dev);
    if (ret)
        return ret;
    
    /* مقداردهی اولیه موتورهای رندر */
    ret = example_render_init(dev);
    if (ret)
        return ret;
    
    /* ثبت اشیاء KMS (نمایشگرها، کانکتورها، انکودرها و غیره) */
    ret = example_modeset_init(dev);
    if (ret)
        return ret;
    
    /* ثبت درایور DRM */
    ret = drm_dev_register(dev, 0);
    if (ret)
        return ret;
    
    return 0;
}

/* عملیات درایور DRM */
static const struct drm_driver example_drm_driver = {
    .driver_features = DRIVER_MODESET | DRIVER_GEM | DRIVER_RENDER,
    .dumb_create = example_dumb_create,      /* برای framebuffer ساده */
    .dumb_map_offset = example_dumb_map_offset,
    .dumb_destroy = example_dumb_destroy,
    .gem_free_object_unlocked = example_gem_free_object,
    .gem_vm_ops = &example_gem_vm_ops,
    .fops = &example_drm_fops,
    .name = "example",
    .desc = "Example Graphics Driver",
    .date = "20230601",
    .major = 1,
    .minor = 0,
};
```

### تعامل با سخت‌افزار

درایورهای دستگاه در لینوکس باید با سخت‌افزار واقعی تعامل داشته باشند. کرنل لینوکس چندین راه برای این تعامل فراهم می‌کند:

**1. دسترسی به پورت I/O:**
- برای دستگاه‌های قدیمی‌تر که از فضای پورت I/O استفاده می‌کنند
- توابع `inb()`, `outb()`, `inw()`, `outw()`, `inl()`, `outl()` برای خواندن و نوشتن در پورت‌ها
- نیاز به درخواست مجوز برای دسترسی به پورت‌ها با `request_region()`

**2. نگاشت حافظه I/O (MMIO):**
- دستگاه‌های مدرن‌تر معمولاً از MMIO استفاده می‌کنند
- نگاشت رجیسترهای سخت‌افزاری به فضای آدرس حافظه
- استفاده از `ioremap()` برای نگاشت آدرس‌های فیزیکی به فضای آدرس کرنل
- استفاده از `readb()`, `writeb()`, `readw()`, `writew()`, `readl()`, `writel()` برای دسترسی به رجیسترها

**3. DMA (Direct Memory Access):**
- برای انتقال داده‌های بزرگ بین دستگاه و حافظه اصلی
- انتقال داده بدون درگیر کردن CPU
- استفاده از API های DMA کرنل مانند `dma_alloc_coherent()`, `dma_map_single()`
- مدیریت همدوسی کش (cache coherency)

**4. وقفه‌ها (Interrupts):**
- مکانیزمی برای دستگاه‌ها تا به کرنل اطلاع دهند که رویدادی رخ داده است
- استفاده از `request_irq()` برای ثبت یک روتین وقفه
- پیاده‌سازی یک تابع مدیریت وقفه (IRQ handler)

**5. نخ‌های کرنل (Kernel Threads):**
- برای انجام وظایف پس‌زمینه در درایور
- ایجاد با `kthread_create()` و شروع با `wake_up_process()`

```c
/**
 * مثال‌هایی از روش‌های مختلف تعامل با سخت‌افزار
 */

/* دسترسی به پورت I/O */
static void example_io_port_access(void)
{
    unsigned long base = 0x378;  /* آدرس پورت پارالل استاندارد */
    
    /* درخواست مجوز برای استفاده از پورت‌ها */
    if (!request_region(base, 3, "example_driver")) {
        pr_err("Cannot request I/O ports\n");
        return;
    }
    
    /* نوشتن داده به پورت داده */
    outb(0x55, base);
    
    /* خواندن از پورت وضعیت */
    unsigned char status = inb(base + 1);
    
    /* آزاد کردن پورت‌ها */
    release_region(base, 3);
}

/* نگاشت حافظه I/O */
static void example_mmio_access(struct pci_dev *pdev)
{
    void __iomem *mmio_base;
    resource_size_t mmio_start, mmio_len;
    u32 value;
    
    /* یافتن منابع MMIO در دستگاه PCI */
    mmio_start = pci_resource_start(pdev, 0);
    mmio_len = pci_resource_len(pdev, 0);
    
    /* درخواست مجوز برای دسترسی به منابع */
    if (!request_mem_region(mmio_start, mmio_len, "example_driver")) {
        pr_err("Cannot request MMIO region\n");
        return;
    }
    
    /* نگاشت منابع فیزیکی به فضای آدرس کرنل */
    mmio_base = ioremap(mmio_start, mmio_len);
    if (!mmio_base) {
        pr_err("Cannot map MMIO region\n");
        release_mem_region(mmio_start, mmio_len);
        return;
    }
    
    /* خواندن از رجیستر */
    value = readl(mmio_base + 0x10);
    
    /* نوشتن به رجیستر */
    writel(0x1234, mmio_base + 0x14);
    
    /* پاکسازی */
    iounmap(mmio_base);
    release_mem_region(mmio_start, mmio_len);
}

/* استفاده از DMA */
static void example_dma_setup(struct pci_dev *pdev)
{
    dma_addr_t dma_handle;
    size_t size = 4096;  /* اندازه بافر 4KB */
    void *cpu_addr;
    
    /* تخصیص بافر DMA */
    cpu_addr = dma_alloc_coherent(&pdev->dev, size, &dma_handle, GFP_KERNEL);
    if (!cpu_addr) {
        pr_err("Failed to allocate DMA buffer\n");
        return;
    }
    
    /* پر کردن بافر با داده */
    memset(cpu_addr, 0, size);
    
    /* تنظیم دستگاه برای استفاده از آدرس DMA */
    writel((u32)dma_handle, mmio_base + DMA_ADDR_REG);
    writel(size, mmio_base + DMA_SIZE_REG);
    
    /* شروع انتقال DMA */
    writel(DMA_START_BIT, mmio_base + DMA_CONTROL_REG);
    
    /* آزادسازی بافر در زمان مناسب */
    dma_free_coherent(&pdev->dev, size, cpu_addr, dma_handle);
}

/* مدیریت وقفه‌ها */
static irqreturn_t example_irq_handler(int irq, void *dev_id)
{
    struct example_device *dev = dev_id;
    u32 status;
    
    /* خواندن رجیستر وضعیت وقفه */
    status = readl(dev->mmio_base + IRQ_STATUS_REG);
    
    /* اگر این وقفه برای این دستگاه نیست */
    if (!(status & IRQ_ACTIVE_BIT))
        return IRQ_NONE;
    
    /* پردازش وقفه */
    if (status & DATA_READY_BIT)
        example_process_data(dev);
    
    /* پاک کردن وقفه */
    writel(status, dev->mmio_base + IRQ_CLEAR_REG);
    
    return IRQ_HANDLED;
}

/* ثبت روتین وقفه */
static int example_setup_irq(struct example_device *dev)
{
    int ret;
    
    ret = request_irq(dev->irq, example_irq_handler,
                     IRQF_SHARED, "example_driver", dev);
    if (ret) {
        pr_err("Failed to request IRQ %d\n", dev->irq);
        return ret;
    }
    
    /* فعال کردن وقفه‌ها در دستگاه */
    writel(IRQ_ENABLE_BIT, dev->mmio_base + IRQ_CONTROL_REG);
    
    return 0;
}
```

کرنل لینوکس همچنین از سیستم‌های باس متنوعی پشتیبانی می‌کند:

- **PCI و PCIe**: برای کارت‌های توسعه و اجزای داخلی
- **USB**: برای دستگاه‌های خارجی
- **I2C**: برای ارتباط با حسگرها و دیگر دستگاه‌های کم‌سرعت
- **SPI**: برای ارتباط سریال مزیت
- **GPIO**: برای خطوط ورودی/خروجی دیجیتال ساده

هر سیستم باس API خاص خود را برای تعامل با دستگاه‌های روی آن باس ارائه می‌دهد.

مدیریت دستگاه‌ها در لینوکس یک زیرسیستم پیچیده و انعطاف‌پذیر است که امکان پشتیبانی از طیف گسترده‌ای از سخت‌افزارها را فراهم می‌کند. مدل درایور ماژولار، سیستم‌های فایل دستگاه، پشتیبانی از hotplug، مدیریت انرژی و رابط‌های متعدد برای تعامل با سخت‌افزار، همگی به توسعه آسان و کارآمد درایورها کمک می‌کنند. این معماری به لینوکس اجازه می‌دهد تا به طور مداوم با فناوری‌های سخت‌افزاری جدید سازگار شود و در انواع مختلف دستگاه‌ها از سیستم‌های نهفته گرفته تا ابررایانه‌ها استفاده شود.